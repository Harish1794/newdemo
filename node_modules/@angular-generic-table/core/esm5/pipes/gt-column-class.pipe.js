/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Pipe } from '@angular/core';
var GtColumnClassPipe = /** @class */ (function () {
    function GtColumnClassPipe() {
    }
    /**
     * @param {?} gtFields
     * @param {?} column
     * @param {?=} row
     * @return {?}
     */
    GtColumnClassPipe.prototype.transform = /**
     * @param {?} gtFields
     * @param {?} column
     * @param {?=} row
     * @return {?}
     */
    function (gtFields, column, row) {
        // find columns with columnClass property defined
        var /** @type {?} */ COLUMN_WITH_CLASS = gtFields
            .map(function (field) { return field; })
            .filter(function (field) { return field.columnClass && field.objectKey === column.objectKey; })[0];
        if (!COLUMN_WITH_CLASS) {
            return;
        }
        else if (typeof COLUMN_WITH_CLASS.columnClass === 'function') {
            // if column class is a function, try using the function...
            try {
                return COLUMN_WITH_CLASS.columnClass(row, column);
            }
            catch (/** @type {?} */ error) {
                console.log('Error when trying to get column class name using formula.', error);
            }
        }
        else {
            // if not a function, return plain string value
            return COLUMN_WITH_CLASS.columnClass;
        }
    };
    GtColumnClassPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gtColumnClass'
                },] },
    ];
    return GtColumnClassPipe;
}());
export { GtColumnClassPipe };
function GtColumnClassPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    GtColumnClassPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    GtColumnClassPipe.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3QtY29sdW1uLWNsYXNzLnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvIiwic291cmNlcyI6WyJwaXBlcy9ndC1jb2x1bW4tY2xhc3MucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7Ozs7Ozs7Ozs7SUFRbkQscUNBQVM7Ozs7OztJQUFULFVBQ0MsUUFBd0MsRUFDeEMsTUFBaUMsRUFDakMsR0FBVzs7UUFHWCxxQkFBTSxpQkFBaUIsR0FBRyxRQUFRO2FBQ2hDLEdBQUcsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUssRUFBTCxDQUFLLENBQUM7YUFDbkIsTUFBTSxDQUNOLFVBQUEsS0FBSyxJQUFJLE9BQUEsS0FBSyxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsU0FBUyxLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQXpELENBQXlELENBQ2xFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDTixJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDdkIsT0FBTztTQUNQO2FBQU0sSUFBSSxPQUFPLGlCQUFpQixDQUFDLFdBQVcsS0FBSyxVQUFVLEVBQUU7O1lBRS9ELElBQUk7Z0JBQ0gsT0FBTyxpQkFBaUIsQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQ2xEO1lBQUMsd0JBQU8sS0FBSyxFQUFFO2dCQUNmLE9BQU8sQ0FBQyxHQUFHLENBQ1YsMkRBQTJELEVBQzNELEtBQUssQ0FDTCxDQUFDO2FBQ0Y7U0FDRDthQUFNOztZQUVOLE9BQU8saUJBQWlCLENBQUMsV0FBVyxDQUFDO1NBQ3JDO0tBQ0Q7O2dCQS9CRCxJQUFJLFNBQUM7b0JBQ0wsSUFBSSxFQUFFLGVBQWU7aUJBQ3JCOzs0QkFORDs7U0FPYSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHdENvbmZpZ0ZpZWxkIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1jb25maWctZmllbGQnO1xuaW1wb3J0IHsgR3RSb3cgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LXJvdyc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0Q29sdW1uQ2xhc3MnXG59KVxuZXhwb3J0IGNsYXNzIEd0Q29sdW1uQ2xhc3NQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdHRyYW5zZm9ybShcblx0XHRndEZpZWxkczogQXJyYXk8R3RDb25maWdGaWVsZDxhbnksIGFueT4+LFxuXHRcdGNvbHVtbjogR3RDb25maWdGaWVsZDxHdFJvdywgYW55Pixcblx0XHRyb3c/OiBHdFJvd1xuXHQpOiBhbnkge1xuXHRcdC8vIGZpbmQgY29sdW1ucyB3aXRoIGNvbHVtbkNsYXNzIHByb3BlcnR5IGRlZmluZWRcblx0XHRjb25zdCBDT0xVTU5fV0lUSF9DTEFTUyA9IGd0RmllbGRzXG5cdFx0XHQubWFwKGZpZWxkID0+IGZpZWxkKVxuXHRcdFx0LmZpbHRlcihcblx0XHRcdFx0ZmllbGQgPT4gZmllbGQuY29sdW1uQ2xhc3MgJiYgZmllbGQub2JqZWN0S2V5ID09PSBjb2x1bW4ub2JqZWN0S2V5XG5cdFx0XHQpWzBdO1xuXHRcdGlmICghQ09MVU1OX1dJVEhfQ0xBU1MpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBDT0xVTU5fV0lUSF9DTEFTUy5jb2x1bW5DbGFzcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gaWYgY29sdW1uIGNsYXNzIGlzIGEgZnVuY3Rpb24sIHRyeSB1c2luZyB0aGUgZnVuY3Rpb24uLi5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBDT0xVTU5fV0lUSF9DTEFTUy5jb2x1bW5DbGFzcyhyb3csIGNvbHVtbik7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0XHQnRXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0IGNvbHVtbiBjbGFzcyBuYW1lIHVzaW5nIGZvcm11bGEuJyxcblx0XHRcdFx0XHRlcnJvclxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiBub3QgYSBmdW5jdGlvbiwgcmV0dXJuIHBsYWluIHN0cmluZyB2YWx1ZVxuXHRcdFx0cmV0dXJuIENPTFVNTl9XSVRIX0NMQVNTLmNvbHVtbkNsYXNzO1xuXHRcdH1cblx0fVxufVxuIl19