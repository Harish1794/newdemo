import { Component, EventEmitter, Input, Output, Pipe, Renderer2, ChangeDetectorRef, ComponentFactoryResolver, Directive, ViewContainerRef, ElementRef, HostListener, HostBinding, NgModule } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { ReplaySubject } from 'rxjs/ReplaySubject';
import { Subject } from 'rxjs/Subject';
import * as Tether from 'tether';
import { Observable } from 'rxjs/Observable';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
/**
 * @template R
 */
class GtExpandedRow {
    constructor() {
        this.redrawEvent = new EventEmitter();
        this.toggleRowEvent = new EventEmitter();
    }
    /**
     * @return {?}
     */
    $hide() {
        this.toggleRowEvent.emit(this.row);
    }
    /**
     * @param {?=} $event
     * @return {?}
     */
    $redraw($event) {
        this.redrawEvent.emit(this.row);
    }
    /**
     * @param {?} row
     * @param {?} $event
     * @return {?}
     */
    $rowClick(row, $event) {
        this.gtEvent.emit({
            name: 'gt-row-clicked',
            value: { row: row, event: $event }
        });
    }
}
// unsupported: template constraints.
// unsupported: template constraints.
/**
 * @template R, C
 */
class GtExpandingRowComponent {
    constructor() {
        this.redrawEvent = new EventEmitter();
        this.toggleRowEvent = new EventEmitter();
    }
    /**
     * @param {?} instance
     * @return {?}
     */
    newInstance(instance) {
        instance.row = this.row;
        instance.columnWidth = this.columnWidth;
        instance.gtSettings = this.gtSettings;
        instance.gtFields = this.gtFields;
        instance.gtOptions = this.gtOptions;
        instance.gtInfo = this.gtInfo;
        instance.data =
            typeof this.data === 'function' ? this.data(this.row) : this.data;
        instance.redrawEvent.subscribe(this.redrawEvent);
        instance.toggleRowEvent.subscribe(this.toggleRowEvent);
        instance.gtEvent = this.gtEvent;
    }
}
GtExpandingRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'gt-expanding-row',
                template: `
        <div gtComponentAnchor
             [ctor]="type" (instance)="newInstance($event)"></div>`
            },] },
];
/** @nocollapse */
GtExpandingRowComponent.propDecorators = {
    "type": [{ type: Input },],
    "row": [{ type: Input },],
    "columnWidth": [{ type: Input },],
    "gtSettings": [{ type: Input },],
    "gtFields": [{ type: Input },],
    "gtOptions": [{ type: Input },],
    "gtInfo": [{ type: Input },],
    "data": [{ type: Input },],
    "redrawEvent": [{ type: Output },],
    "toggleRowEvent": [{ type: Output },],
    "gtEvent": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtMetaPipe {
    /**
     * @param {?} allRows
     * @param {?=} rowIndex
     * @param {?=} page
     * @param {?=} recordLength
     * @return {?}
     */
    transform(allRows, rowIndex, page, recordLength) {
        for (let /** @type {?} */ i = 0; i < allRows.length; i++) {
            if (!allRows[i].$$gtRowId) {
                allRows[i].$$gtRowId = rowIndex
                    ? allRows[i][rowIndex]
                    : page
                        ? page * recordLength +
                            i +
                            '_' +
                            Math.random()
                                .toString(36)
                                .substr(2, 16)
                        : i +
                            '_' +
                            Math.random()
                                .toString(36)
                                .substr(2, 16);
            }
            if (!allRows[i].$$gtInitialRowIndex) {
                allRows[i].$$gtInitialRowIndex = i;
            }
        }
        return allRows;
    }
}
GtMetaPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtMeta'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
// unsupported: template constraints.
/**
 * @template R, C
 */
class GenericTableComponent {
    /**
     * @param {?} renderer
     * @param {?} gtMetaPipe
     */
    constructor(renderer, gtMetaPipe) {
        this.renderer = renderer;
        this.gtMetaPipe = gtMetaPipe;
        this.columnWidth = {};
        this.sortOrder = [];
        this.metaInfo = {};
        this.selectedRows = [];
        this.openRows = [];
        this._gtSettings = [];
        this._gtFields = [];
        this.gtDefaultTexts = {
            loading: 'Loading...',
            noData: 'No data',
            noMatchingData: 'No data matching results found',
            noVisibleColumnsHeading: 'No visible columns',
            noVisibleColumns: 'Please select at least one column to be visible.',
            tableInfo: 'Showing #recordFrom to #recordTo of #recordsAfterSearch entries.',
            tableInfoAfterSearch: 'Showing  #recordFrom to #recordTo of #recordsAfterSearch entries (filtered from a total of #recordsAll entries).',
            csvDownload: 'download',
            sortLabel: 'Sort:',
            paginateNext: 'Next page',
            paginatePrevious: 'Previous page',
            inlineEditEdited: 'Press enter to save'
        };
        this.gtTexts = this.gtDefaultTexts;
        this.gtEvent = new EventEmitter();
        this.gtDefaultOptions = {
            csvDelimiter: ';',
            stack: false,
            lazyLoad: false,
            cache: false,
            debounceTime: 200,
            highlightSearch: false,
            rowSelection: false,
            rowSelectionAllowMultiple: true,
            rowExpandAllowMultiple: true,
            numberOfRows: 10,
            reportColumnWidth: false,
            allowUnsorted: true,
            mutateData: true
        };
        this._gtOptions = this.gtDefaultOptions;
        this.store = [];
        this.loading = true;
        this.debounceTimer = null;
        this.lazyAllSelected = false;
        this.gtInfo = {
            pageCurrent: 1,
            pageTotal: 0,
            recordFrom: 0,
            recordTo: 0,
            recordLength: this.gtOptions.numberOfRows,
            recordsAll: 0,
            recordsAfterFilter: 0,
            recordsAfterSearch: 0
        };
        this.refreshPipe = false;
        this.refreshTotals = false;
        this.refreshSorting = false;
        this.refreshFilter = false;
        this.refreshPageArray = false;
        this.editedRows = {};
        this.data = { exportData: [] };
        /**
         * Sort table by object key.
         * @param objectKey - name of key to sort on.
         * @param event - such as key press during sorting.
         */
        this.gtSort = function (objectKey, event) {
            this.inlineEditCancel(); // cancel inline editing
            // loop through current settings
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    // check if sorting is disabled...
                    if (this._gtSettings[i].sort &&
                        this._gtSettings[i].sort.indexOf('disable') !== -1) {
                        // ...if so, exit function without applying any sorting
                        return;
                    }
                    else if (/* check if sorting is undefined... */ typeof this._gtSettings[i]
                        .sort === 'undefined') {
                        // ...is so, set sorting property to enable
                        this._gtSettings[i].sort = 'enable';
                    }
                }
            }
            // check length
            const /** @type {?} */ ctrlKey = event.metaKey || event.ctrlKey;
            const /** @type {?} */ sort = this.sortOrder.slice(0);
            let /** @type {?} */ match = -1;
            let /** @type {?} */ matchDesc = -1;
            let /** @type {?} */ pos = -1;
            // check if property already exits
            for (let /** @type {?} */ i = 0; i < sort.length; i++) {
                const /** @type {?} */ hit = sort[i].indexOf(objectKey);
                if (hit !== -1) {
                    match = this.sortOrder.indexOf(objectKey);
                    matchDesc =
                        match === -1 ? this.sortOrder.indexOf('-' + objectKey) : match;
                    pos = Math.max(match, matchDesc);
                }
            }
            // if ctrl key or meta key is press together with sort...
            if (ctrlKey) {
                if (this.sortOrder[this.sortOrder.length - 1] === '$$gtInitialRowIndex') {
                    this.sortOrder.pop();
                }
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...add property to sorting
                        this.sortOrder.push(objectKey);
                        break;
                    default:
                        // ...and property is sorted before...
                        if (match !== -1) {
                            // ...change from asc to desc if sorted asc
                            this.sortOrder[pos] = '-' + objectKey;
                        }
                        else if (this.sortOrder.length > 1) {
                            // ...remove sorting if sorted desc
                            if (ctrlKey) {
                                this.sortOrder[pos] = objectKey;
                            }
                            else {
                                this.sortOrder.splice(pos, 1);
                            }
                        }
                        else if (this.sortOrder.length === 1) {
                            // ...set sorting to asc if only sorted property
                            this.sortOrder[pos] = objectKey;
                        }
                        break;
                }
            }
            else {
                /* if ctrl key or meta key is not press together with sort... */
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...sort by property
                        this.sortOrder = [objectKey];
                        break;
                    default:
                        // ...change from desc to asc and vise versa
                        this.sortOrder =
                            match !== -1
                                ? ['-' + objectKey]
                                : ctrlKey || !this.gtOptions.allowUnsorted
                                    ? [objectKey]
                                    : [];
                        break;
                }
            }
            // update settings object with new sorting information
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    switch (this._gtSettings[i].sort) {
                        // if sorted asc...
                        case 'asc':
                            // ...change to desc
                            this._gtSettings[i].sort = 'desc';
                            break;
                        // if sorted desc...
                        case 'desc':
                            // ...change to asc if it's the only sorted property otherwise remove sorting
                            this._gtSettings[i].sort =
                                (this.sortOrder.length === 1 && sort.length < 2) ||
                                    ctrlKey ||
                                    !this.gtOptions.allowUnsorted
                                    ? 'asc'
                                    : 'enable';
                            break;
                        // if sorting enabled...
                        case 'enable':
                            // ...change to asc
                            this._gtSettings[i].sort = 'asc';
                            break;
                    }
                    this._gtSettings[i].sortOrder =
                        this._gtSettings[i].sort === 'enable'
                            ? this._gtSettings.length - 1
                            : this.sortOrder.indexOf(objectKey) === -1
                                ? this.sortOrder.indexOf('-' + objectKey)
                                : this.sortOrder.indexOf(objectKey);
                }
                else if (this._gtSettings[i].sort &&
                    this._gtSettings[i].sort.indexOf('disable') === -1 &&
                    this.sortOrder.indexOf(this._gtSettings[i].objectKey) === -1 &&
                    this.sortOrder.indexOf('-' + this._gtSettings[i].objectKey) === -1) {
                    this._gtSettings[i].sort = 'enable';
                    this._gtSettings[i].sortOrder = this._gtSettings.length - 1;
                }
            }
            // refresh sorting pipe
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            // sort by initial sort order as last resort
            this.sortOrder.push('$$gtInitialRowIndex');
            // emit sort event
            this.gtEvent.emit({
                name: 'gt-sorting-applied',
                value: this.sortOrder
            });
        };
        /**
         * Change number of rows to be displayed.
         * @param rowLength - total number of rows.
         * @param reset - should page be reset to first page.
         */
        this.changeRowLength = function (rowLength, reset) {
            let /** @type {?} */ lengthValue = isNaN(parseInt(rowLength, 10))
                ? 0
                : parseInt(rowLength, 10);
            let /** @type {?} */ newPosition = 1;
            if (!lengthValue && this.gtData) {
                lengthValue = this.gtData.length;
            }
            // if reset is not true and we're not lazy loading data...
            if (reset !== true && this._gtOptions.lazyLoad !== true) {
                // ...get current position in record set
                const /** @type {?} */ currentRecord = this.gtInfo.recordLength * (this.gtInfo.pageCurrent - 1);
                const /** @type {?} */ currentPosition = this._gtData.indexOf(this._gtData[currentRecord]) + 1;
                // ...get new position
                newPosition = Math.ceil(currentPosition / lengthValue);
            }
            // change row length
            this.gtInfo.recordLength = lengthValue;
            // go to new position
            this.gtInfo.pageCurrent = newPosition;
            // if lazy loading data...
            if (this._gtOptions.lazyLoad) {
                // ...replace data with place holders for new data
                this._gtData[0] = this.loadingContent(lengthValue);
                // ...empty current store
                this.store = [];
            }
            // this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-row-length-changed',
                value: lengthValue
            });
        };
        /**
         * Force a redraw of table rows.
         * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
         */
        this.redraw = function ($event) {
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            this.refreshPipe = !this.refreshPipe;
        };
        /**
         * Go to next page.
         */
        this.nextPage = function () {
            const /** @type {?} */ page = this.gtInfo.pageCurrent === this.gtInfo.pageTotal
                ? this.gtInfo.pageTotal
                : this.gtInfo.pageCurrent + 1;
            this.goToPage(page);
        };
        /**
         * Go to previous page.
         */
        this.previousPage = function () {
            const /** @type {?} */ page = this.gtInfo.pageCurrent === 1 ? 1 : this.gtInfo.pageCurrent - 1;
            this.goToPage(page);
        };
        /**
         * Request more data (used when lazy loading)
         */
        this.getData = function () {
            // ...emit event requesting for more data
            this.gtEvent.emit({
                name: 'gt-page-changed-lazy',
                value: {
                    pageCurrent: this.gtInfo.pageCurrent,
                    recordLength: this.gtInfo.recordLength
                }
            });
        };
        /**
         * Go to specific page.
         * @param page - page number.
         */
        this.goToPage = function (page) {
            const /** @type {?} */ previousPage = this.gtInfo.pageCurrent;
            this.gtInfo.pageCurrent = page;
            this.inlineEditCancel(); // cancel inline edit
            // if lazy loading and if page contains no records...
            if (this._gtOptions.lazyLoad) {
                // ...if data for current page contains no entries...
                if (this._gtOptions.cache === false ||
                    this._gtData[this.gtInfo.pageCurrent - 1].length === 0) {
                    // ...create temporary content while waiting for data
                    this._gtData[this.gtInfo.pageCurrent - 1] = this.loadingContent(this.gtInfo.recordLength);
                    this.loading = true; // loading true
                }
                // ...if first entry in current page equals our loading placeholder...
                if (this._gtData[this.gtInfo.pageCurrent - 1][0][this.loadingProperty] ===
                    this.gtTexts.loading) {
                    // ...get data
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(() => {
                        this.getData();
                    }, this._gtOptions.debounceTime);
                }
            }
            // this.updateRecordRange();
            // ...emit page change event
            if (previousPage !== page) {
                this.gtEvent.emit({
                    name: 'gt-page-changed',
                    value: {
                        pageCurrent: this.gtInfo.pageCurrent,
                        pagePrevious: previousPage,
                        recordLength: this.gtInfo.recordLength
                    }
                });
            }
        };
        /**
         * Sort by sort order
         */
        this.getSortOrder = function (a, b) {
            if (a.sortOrder < b.sortOrder) {
                return -1;
            }
            if (a.sortOrder > b.sortOrder || typeof a.sortOrder === 'undefined') {
                return 1;
            }
            return 0;
        };
        /**
         * Sort by column order
         */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder === undefined) {
                return -1;
            }
            if (a.columnOrder < b.columnOrder) {
                return -1;
            }
            if (a.columnOrder > b.columnOrder) {
                return 1;
            }
            return 0;
        };
        /**
         * Create a deep copy of data
         */
        this.cloneDeep = function (o) {
            return JSON.parse(JSON.stringify(o));
        };
        /**
         * Return property
         */
        this.getProperty = function (array, key) {
            for (let /** @type {?} */ i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
        this.restructureSorting = function () {
            /**
             * Check and store sort order upon initialization.
             *  This is done by checking sort properties in the settings array of the table, if no sorting is defined
             *  we'll sort the data by the first visible and enabled column in the table(ascending). Please note that actually
             *  sorting have to be done server side when lazy loading data for obvious reasons.
             */
            const /** @type {?} */ sorting = [];
            if (this._gtSettings) {
                // ...sort settings by sort order
                this._gtSettings.sort(this.getSortOrder);
                // ...loop through settings
                for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                    const /** @type {?} */ setting = this._gtSettings[i];
                    // ...if sorted ascending...
                    if (setting.sort === 'asc') {
                        // ... add to sorting
                        sorting.push(setting.objectKey);
                    }
                    else if (setting.sort === 'desc') {
                        /* ...else if sorted descending... */ 
                        // ... add to sorting
                        sorting.push('-' + setting.objectKey);
                    }
                }
                // ...if no sorting applied...
                if (sorting.length === 0) {
                    sorting.push('$$gtRowId');
                    /*// ...sort settings by column order
                                    this._gtSettings.sort(this.getColumnOrder);
                    
                                    // ...loop through settings
                                    for (let i = 0; i < this._gtSettings.length; i++) {
                                        const setting = this._gtSettings[i];
                    
                                        // ...if column is enabled and visible...
                                        if (setting.enabled !== false && setting.visible !== false) {
                                            // ...add first match and exit function
                                            this.sortOrder = [this._gtSettings[i].objectKey];
                                            return;
                                        }
                                    }*/
                }
            }
            if (this.sortOrder.length === 0) {
                this.sortOrder = sorting;
            }
        };
        /**
         *  Extend object function.
         */
        this.extend = function (a, b) {
            for (const /** @type {?} */ key in b) {
                if (b.hasOwnProperty(key)) {
                    a[key] = b[key];
                }
            }
            return a;
        };
        this.gtEvent.subscribe(($event) => {
            if ($event.name === 'gt-info') {
                this.updateRecordRange();
            }
            if ($event.name === 'gt-row-updated') {
                this.updateTotals();
            }
        });
    }
    /**
     * @return {?}
     */
    get gtRowComponent() {
        return this._gtRowComponent;
    }
    /**
     * @return {?}
     */
    get hasEdits() {
        return Object.keys(this.editedRows).length > 0;
    }
    /**
     * @return {?}
     */
    get gtOptions() {
        return this._gtOptions;
    }
    /**
     * @return {?}
     */
    get gtTotals() {
        return this._gtTotals;
    }
    /**
     * @return {?}
     */
    get gtFields() {
        return this._gtFields;
    }
    /**
     * @return {?}
     */
    get gtSettings() {
        return this._gtSettings;
    }
    /**
     * @return {?}
     */
    get gtData() {
        return this._gtData;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtOptions(value) {
        this._gtOptions = value;
        // if number of rows is passed and if number of rows differs from current record length...
        if (this.gtOptions.numberOfRows &&
            this.gtInfo.recordLength !== this.gtOptions.numberOfRows) {
            // ...update record length and redraw table
            this.gtInfo.recordLength = this.gtOptions.numberOfRows;
            this.redraw();
        }
        // ...extend gtOptions default values with values passed into component
        this._gtOptions = /** @type {?} */ (this.extend(this.gtDefaultOptions, this._gtOptions));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtTotals(value) {
        this._gtTotals = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtFields(value) {
        this._gtFields = value;
        const /** @type {?} */ COLUMNS_WITH_CLASS_NAMES = this._gtFields
            .map(column => column)
            .filter(column => column.classNames);
        // TODO: remove deprecated warning when setting has been removed
        if (COLUMNS_WITH_CLASS_NAMES.length > 0) {
            console.warn('Field setting "classNames" have been deprecated in favor for "columnClass" and will be removed in the future, please update field settings for column with object key: ' +
                COLUMNS_WITH_CLASS_NAMES[0].objectKey);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtSettings(value) {
        this._gtSettings = value;
        // loop through current settings
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            // set sort enabled/disabled setting
            this._gtSettings[i].sortEnabled =
                this._gtSettings[i].sortEnabled !== false
                    ? (this._gtSettings[i].sortEnabled = !(this._gtSettings[i].sort &&
                        this._gtSettings[i].sort.indexOf('disable') !== -1))
                    : false;
            // check if sorting is undefined...
            if (typeof this._gtSettings[i].sort === 'undefined') {
                // ...is so, set sorting property to enable
                this._gtSettings[i].sort = 'enable';
            }
            // check if column order is undefined...
            if (typeof this._gtSettings[i].columnOrder === 'undefined' &&
                this._gtSettings[i].enabled !== false) {
                // ...is so, set sorting property to enable
                this._gtSettings[i].columnOrder = this._gtSettings[i - 1]
                    ? this._gtSettings[i - 1].columnOrder + 1
                    : 0;
            }
            // check if column lock settings are undefined...
            if (typeof this._gtSettings[i].lockSettings === 'undefined') {
                // ...if so, set lock settings to false unless field is disabled (enable === false)
                this._gtSettings[i].lockSettings =
                    this._gtSettings[i].enabled === false || false;
            }
        }
        this.restructureSorting();
    }
    /**
     * @param {?} initialData
     * @return {?}
     */
    set gtData(initialData) {
        const /** @type {?} */ data = this._gtOptions.mutateData
            ? [...initialData]
            : this.cloneDeep(initialData);
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            this.gtMetaPipe.transform(data, this.gtOptions.rowIndex, this.gtInfo.pageCurrent - 1, this.gtInfo.recordLength);
            if (this.lazyAllSelected) {
                const /** @type {?} */ UNIQUE_ROWS = this.selectedRows.map(row => row.$$gtRowId);
                data.map(row => {
                    if (UNIQUE_ROWS.indexOf(row.$$gtRowId) === -1) {
                        this.selectedRows.push(row);
                    }
                });
                this._updateMetaInfo(this.selectedRows, 'isSelected', true);
            }
        }
        else {
            this.gtMetaPipe.transform(data, this.gtOptions.rowIndex);
        }
        if (this.gtOptions.rowSelectionInitialState) {
            data.map(row => {
                const /** @type {?} */ selected = typeof this.gtOptions.rowSelectionInitialState === 'function'
                    ? this.gtOptions.rowSelectionInitialState(row)
                    : this.gtOptions.rowSelectionInitialState;
                if (selected) {
                    if (typeof this.metaInfo[row.$$gtRowId] === 'undefined') {
                        this.metaInfo[row.$$gtRowId] = { isSelected: true };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId].isSelected = true;
                    }
                    this.selectedRows.push(row);
                }
            });
        }
        if (this.gtOptions.rowExpandInitialState &&
            this.gtOptions.rowExpandInitialComponent) {
            data.map(row => {
                const /** @type {?} */ expanded = typeof this.gtOptions.rowExpandInitialState === 'function'
                    ? this.gtOptions.rowExpandInitialState(row)
                    : this.gtOptions.rowExpandInitialState;
                this.expandedRow = this.gtOptions.rowExpandInitialComponent;
                if (expanded) {
                    if (typeof this.metaInfo[row.$$gtRowId] === 'undefined') {
                        this.metaInfo[row.$$gtRowId] = { isOpen: true };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId].isOpen = true;
                    }
                }
            });
        }
        this._gtData = data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtRowComponent(value) {
        console.warn('GtRowComponent has been deprecated and support will be removed in a future release, see https://github.com/hjalmers/angular-generic-table/issues/34');
        this._gtRowComponent = value;
    }
    /**
     * Update record range.
     * @return {?}
     */
    updateRecordRange() {
        this.gtInfo.recordFrom =
            this.gtInfo.recordsAfterSearch === 0
                ? 0
                : (this.gtInfo.pageCurrent - 1) * this.gtInfo.recordLength + 1;
        this.gtInfo.recordTo =
            this.gtInfo.recordsAfterSearch <
                this.gtInfo.pageCurrent * this.gtInfo.recordLength
                ? this.gtInfo.recordsAfterSearch
                : this.gtInfo.pageCurrent * this.gtInfo.recordLength;
    }
    /**
     * Update totals.
     * @return {?}
     */
    updateTotals() {
        this.refreshTotals = !this.refreshTotals;
    }
    /**
     * Get meta data for row.
     * @param {?} row
     * @return {?}
     */
    getRowState(row) {
        return typeof this.metaInfo[row.$$gtRowId] === 'undefined'
            ? null
            : this.metaInfo[row.$$gtRowId];
    }
    /**
     * Expand all rows.
     * @param {?} expandedRow - component to render when rows are expanded.
     * @return {?}
     */
    expandAllRows(expandedRow) {
        this.expandedRow = expandedRow;
        this._toggleAllRowProperty('isOpen', true);
    }
    /**
     * Collapse all rows.
     * @return {?}
     */
    collapseAllRows() {
        this._toggleAllRowProperty('isOpen', false);
    }
    /**
     * Select all rows.
     * @return {?}
     */
    selectAllRows() {
        this._toggleAllRowProperty('isSelected', true);
    }
    /**
     * Deselect all rows.
     * @return {?}
     */
    deselectAllRows() {
        this._toggleAllRowProperty('isSelected', false);
    }
    /**
     * Toggle all rows.
     * @return {?}
     */
    toggleAllRows() {
        if (this._gtOptions.lazyLoad) {
            if (!this.lazyAllSelected || this.selectedRows.length === 0) {
                this.selectAllRows();
                this.lazyAllSelected = true;
            }
            else {
                this.deselectAllRows();
                this.lazyAllSelected = false;
            }
        }
        else {
            if (this.selectedRows.length !== this.gtData.length) {
                this.selectAllRows();
            }
            else {
                this.deselectAllRows();
            }
        }
    }
    /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param {?} row - row object that should be expanded/collapsed.
     * @param {?=} expandedRow - component to render when row is expanded.
     * @return {?}
     */
    toggleCollapse(row, expandedRow) {
        if (expandedRow) {
            this.expandedRow = expandedRow;
        }
        this._toggleRowProperty(row, 'isOpen');
    }
    /**
     * Toggle row selected state ie. selected or not.
     * @param {?} row - row object that should be selected/deselected.
     * @return {?}
     */
    toggleSelect(row) {
        this._toggleRowProperty(row, 'isSelected');
    }
    /**
     * @param {?} row
     * @param {?} $event
     * @return {?}
     */
    rowClick(row, $event) {
        this.gtEvent.emit({
            name: 'gt-row-clicked',
            value: { row: row, event: $event }
        });
    }
    /**
     * Update row data.
     * @param {?} row - row object that has been edited.
     * @param {?} oldValue - row object before edit.
     * @return {?}
     */
    updateRow(row, oldValue) {
        this._toggleRowProperty(row, 'isUpdated', oldValue);
    }
    /**
     * removes a row from the table
     * @param {?} row - the row object to remove
     * @return {?}
     */
    removeRow(row) {
        if (this.isRowSelected(row)) {
            this.toggleSelect(row);
        }
        const /** @type {?} */ index = this._gtData.indexOf(row);
        this._gtData.splice(index, 1);
    }
    /**
     * check if a row is selected
     * @param {?} row - row object
     * @return {?}
     */
    isRowSelected(row) {
        return (this.metaInfo[row.$$gtRowId] && this.metaInfo[row.$$gtRowId].isSelected);
    }
    /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param {?} array - array that holds rows that need to be updated.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @param {?=} exception - update all rows except this one.
     * @return {?}
     */
    _updateMetaInfo(array, property, active, exception) {
        for (let /** @type {?} */ i = 0; i < array.length; i++) {
            if (!this.metaInfo[array[i].$$gtRowId]) {
                this.metaInfo[array[i].$$gtRowId] = {};
            }
            if (exception && array[i].$$gtRowId === exception.$$gtRowId) ;
            else {
                this.metaInfo[array[i].$$gtRowId][property] = active;
            }
        }
    }
    /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param {?} target - array to which rows should be added.
     * @param {?} source - array that holds rows that should be added.
     * @return {?} array with added rows.
     */
    _pushLazyRows(target, source) {
        const /** @type {?} */ UNIQUE_ROWS = target.map(row => row.$$gtRowId);
        for (let /** @type {?} */ i = 0; i < source.length; i++) {
            // only add if not already in list
            if (UNIQUE_ROWS.indexOf(source[i].$$gtRowId) === -1) {
                target.push(source[i]);
            }
        }
        return target;
    }
    /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @return {?}
     */
    _toggleAllRowProperty(property, active) {
        let /** @type {?} */ eventName;
        let /** @type {?} */ eventValue;
        switch (property) {
            case 'isOpen':
                // check if multiple expanded rows are allowed...
                if (this._gtOptions.rowExpandAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowExpandAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'expand-all';
                    this.openRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.openRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.openRows, property, active);
                }
                else {
                    eventName = 'collapse-all';
                    this._updateMetaInfo(this.openRows, property, active);
                    this.openRows = [];
                }
                eventValue = {
                    expandedRows: this.openRows,
                    changedRow: 'all'
                };
                break;
            case 'isSelected':
                // check if multi row selection is allowed...
                if (this._gtOptions.rowSelectionAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowSelectionAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'select-all';
                    this.selectedRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.selectedRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.selectedRows, property, active);
                }
                else {
                    eventName = 'deselect-all';
                    this._updateMetaInfo(this.selectedRows, property, active);
                    this.selectedRows = [];
                }
                eventValue = {
                    selectedRows: this.selectedRows,
                    changedRow: 'all'
                };
                break;
        }
        this.gtEvent.emit({
            name: 'gt-row-' + eventName,
            value: eventValue
        });
    }
    /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param {?} row - row object.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?=} propertyValues - optional property values that can be passed.
     * @return {?}
     */
    _toggleRowProperty(row, property, propertyValues) {
        let /** @type {?} */ eventName;
        let /** @type {?} */ eventValue;
        // make sure gtRowId exists on row object
        if (typeof row.$$gtRowId !== 'undefined') {
            // check if meta info exists for row
            if (!this.metaInfo[row.$$gtRowId]) {
                // if not, add object to store meta info
                this.metaInfo[row.$$gtRowId] = {};
            }
            switch (property) {
                case 'isOpen':
                    const /** @type {?} */ opened = this.metaInfo[row.$$gtRowId][property];
                    // check if multiple expanded rows are allowed...
                    if (this._gtOptions.rowExpandAllowMultiple === false) {
                        // ...if not, collapse all rows except current row
                        this._updateMetaInfo(this.openRows, property, false, row);
                        this.openRows = [];
                    }
                    // check if row is expanded
                    if (!opened) {
                        eventName = 'expand';
                        // add row to expanded rows
                        this.openRows.push(row);
                    }
                    else {
                        eventName = 'collapse';
                        // loop through expanded rows...
                        for (let /** @type {?} */ i = 0; i < this.openRows.length; i++) {
                            // if expanded row equals passed row...
                            if (this.openRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from expanded rows...
                                this.openRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        expandedRows: this.openRows,
                        changedRow: row
                    };
                    break;
                case 'isSelected':
                    const /** @type {?} */ selected = this.metaInfo[row.$$gtRowId][property];
                    // check if multi row selection is allowed...
                    if (this._gtOptions.rowSelectionAllowMultiple === false) {
                        // ...if not, deselect all rows except current row
                        this._updateMetaInfo(this.selectedRows, property, false, row);
                        this.selectedRows = [];
                    }
                    // check if row is selected
                    if (!selected) {
                        eventName = 'select';
                        // add row to selected rows
                        this.selectedRows.push(row);
                    }
                    else {
                        if (this.gtOptions.lazyLoad && this.lazyAllSelected) {
                            this.lazyAllSelected = false;
                        }
                        eventName = 'deselect';
                        // loop through selected rows...
                        for (let /** @type {?} */ i = 0; i < this.selectedRows.length; i++) {
                            // if selected row equals passed row...
                            if (this.selectedRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from selected rows...
                                this.selectedRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        selectedRows: this.selectedRows,
                        changedRow: row
                    };
                    break;
                case 'isUpdated':
                    eventName = 'updated';
                    const /** @type {?} */ oldValue = propertyValues;
                    // check if edit object exists for row
                    if (typeof this.metaInfo[row.$$gtRowId][property] === 'undefined') {
                        this.metaInfo[row.$$gtRowId][property] = {
                            originalValue: oldValue,
                            oldValue: oldValue,
                            newValue: row
                        };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId][property].oldValue = oldValue;
                        this.metaInfo[row.$$gtRowId][property].newValue = row;
                    }
                    eventValue = this.metaInfo[row.$$gtRowId][property];
                    this.redraw();
                    this.inlineEditCancel(row);
                    // this.gtData = [...this.gtData.map((r) => { return{...r}; })];
                    break;
            }
            this.gtEvent.emit({
                name: 'gt-row-' + eventName,
                value: eventValue
            });
            if (property !== 'isUpdated') {
                this.metaInfo[row.$$gtRowId][property] = !this.metaInfo[row.$$gtRowId][property];
            }
        }
    }
    /**
     * Update column.
     * @param {?} $event - key up event.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    gtUpdateColumn($event, row, column) {
        this._editRow(row, column);
    }
    /**
     * Dropdown select.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    gtDropdownSelect(row, column) {
        const /** @type {?} */ oldValue = Object.assign({}, row);
        row[column.objectKey] = column.renderValue;
        this.updateRow(row, oldValue);
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    _editRow(row, column) {
        const /** @type {?} */ OBJECT_KEY = column.objectKey; // declare object key which contains changes
        // check if cell has changed value
        column.edited = row[column.objectKey] !== column.renderValue;
        // check if row contains changes...
        if (!this.editedRows[row.$$gtRowId]) {
            // if not, create an object for the changed row
            this.editedRows[row.$$gtRowId] = {
                changes: {},
                // create placeholder for changes
                row: row // store reference to the row that should be updated
            };
        }
        // store changed column under changes if it has been edited
        if (column.edited) {
            this.editedRows[row.$$gtRowId].changes[OBJECT_KEY] = column;
        }
        else {
            // delete change object if column is unchanged
            delete this.editedRows[row.$$gtRowId].changes[OBJECT_KEY];
            // check how many columns have been changed
            const /** @type {?} */ CHANGED_COLUMNS = Object.keys(this.editedRows[row.$$gtRowId].changes).length;
            if (CHANGED_COLUMNS === 0) {
                // delete row from edited rows if no columns have been edited
                delete this.editedRows[row.$$gtRowId];
            }
        }
        // if no listener is present...
        if (!this.globalInlineEditListener) {
            // ...listen for update event
            this._listenForKeydownEvent();
        }
    }
    /**
     * Listen for key down event - listen for key down event during inline edit.
     * @return {?}
     */
    _listenForKeydownEvent() {
        // add global listener for key down events
        this.globalInlineEditListener = this.renderer.listen('document', 'keydown', $event => {
            switch ($event.key) {
                case 'Enter': // update data object
                    // update data object
                    this.inlineEditUpdate();
                    break;
                case 'Escape': // cancel
                    // cancel
                    this.inlineEditCancel();
                    break;
            }
        });
    }
    /**
     * Inline edit update - accept changes and update row values.
     * @return {?}
     */
    inlineEditUpdate() {
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(key => {
            const /** @type {?} */ ROW = this.editedRows[key].row; // row to update
            const /** @type {?} */ CHANGES = this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(objectKey => {
                const /** @type {?} */ oldValue = Object.assign({}, ROW);
                ROW[objectKey] = CHANGES[objectKey].renderValue; // update data value
                this.updateRow(ROW, oldValue); // update meta info for row and send event
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    }
    /**
     * Inline edit cancel - cancel and reset inline edits.
     * @param {?=} row
     * @return {?}
     */
    inlineEditCancel(row) {
        if (row) {
            delete this.editedRows[row.$$gtRowId];
            // remove listener
            this._stopListeningForKeydownEvent();
            return;
        }
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(key => {
            const /** @type {?} */ ROW = this.editedRows[key].row; // row to update
            const /** @type {?} */ CHANGES = this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(objectKey => {
                CHANGES[objectKey].renderValue = ROW[objectKey]; // reset rendered value
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    }
    /**
     * Stop listening for key down event - stop listening for key down events passed during inline edit.
     * @return {?}
     */
    _stopListeningForKeydownEvent() {
        if (this.globalInlineEditListener) {
            this.globalInlineEditListener();
            this.globalInlineEditListener = null;
        }
    }
    /**
     * Apply filter(s).
     * @param {?} filter - object containing key value pairs, where value should be array of values.
     * @return {?}
     */
    gtApplyFilter(filter) {
        this.gtInfo.filter = filter;
        // go to first page
        this.goToPage(1);
        this.updateTotals();
    }
    /**
     * Clear/remove applied filter(s).
     * @return {?}
     */
    gtClearFilter() {
        this.gtInfo.filter = false;
        this.updateTotals();
        // this.updateRecordRange();
    }
    /**
     * Search
     * @param {?} value - string containing one or more words
     * @return {?}
     */
    gtSearch(value) {
        this.gtInfo.searchTerms = value;
        // always go to first page when searching
        this.goToPage(1);
        this.updateTotals();
    }
    /**
     * Add rows
     * @param {?} rows - rows to add
     * @return {?} new data array.
     */
    gtAdd(rows) {
        this.gtData = [...this.gtData, ...rows];
        return [...this.gtData];
    }
    /**
     * Delete row
     * @param {?} objectKey - object key you want to find match with
     * @param {?} value - the value that should be deleted
     * @param {?=} match - all: delete all matches, first: delete first match (default)
     * @return {?} new data array.
     */
    gtDelete(objectKey, value, match = 'first') {
        if (match === 'first') {
            for (let /** @type {?} */ i = 0; i < this.gtData.length; i++) {
                if (this.gtData[i][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i])) {
                        this.toggleSelect(this.gtData[i]);
                    }
                    this.gtData.splice(i, 1);
                    this.gtData = [...this.gtData];
                    if (match === 'first') {
                        break;
                    }
                }
            }
        }
        else {
            for (let /** @type {?} */ i = this.gtData.length; i > 0; i--) {
                if (this.gtData[i - 1][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i - 1])) {
                        this.toggleSelect(this.gtData[i - 1]);
                    }
                    this.gtData.splice(i - 1, 1);
                    this.gtData = [...this.gtData];
                }
            }
        }
        return [...this.gtData];
    }
    /**
     * Create store to hold previously loaded records.
     * @param {?} records - total number of records in store.
     * @param {?} perPage - how many records to show per page.
     * @return {?} a nested array to hold records per page.
     */
    createStore(records, perPage) {
        const /** @type {?} */ stores = Math.ceil(records / perPage);
        const /** @type {?} */ store = [];
        for (let /** @type {?} */ i = 0; i < stores; i++) {
            store[i] = [];
        }
        return store;
    }
    /**
     * Create placeholders for rows while loading data from back-end.
     * @param {?} perPage - how many records to show per page.
     * @return {?} an array containing empty records to be presented while fetching real data.
     */
    loadingContent(perPage) {
        // create row object
        const /** @type {?} */ rowObject = {
            $$loading: true
        };
        let /** @type {?} */ order = 0;
        // sort settings by column order
        this._gtSettings.sort(this.getColumnOrder);
        // loop through all settings objects...
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            const /** @type {?} */ setting = this._gtSettings[i];
            // ...if column is visible and enabled...
            if (setting.visible !== false && setting.enabled !== false) {
                // ...if first column, set value to loading text otherwise leave it empty
                if (order === 0) {
                    rowObject[setting.objectKey] = this.gtTexts.loading;
                    this.loadingProperty = setting.objectKey;
                }
                else {
                    rowObject[setting.objectKey] = '';
                }
                order++;
            }
            else {
                rowObject[setting.objectKey] = '';
            }
        }
        // create content placeholder
        const /** @type {?} */ contentPlaceholder = [];
        // create equal number of rows as rows per page
        for (let /** @type {?} */ i = 0; i < perPage; i++) {
            // ...add temporary row object
            contentPlaceholder.push(rowObject);
        }
        return contentPlaceholder;
    }
    /**
     * Export data as CSV
     * @param {?=} fileName - optional file name (overrides default file name).
     * @param {?=} useBOM - use BOM (byte order marker).
     * @return {?}
     */
    exportCSV(fileName, useBOM = false) {
        const /** @type {?} */ data = this.data.exportData;
        let /** @type {?} */ csv = '';
        const /** @type {?} */ BOM = '\uFEFF';
        // csv export headers
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            if (this._gtSettings[i].export !== false) {
                csv += this.getProperty(this._gtFields, this._gtSettings[i].objectKey)
                    .name;
                if (i < this._gtSettings.length - 1) {
                    csv += this._gtOptions.csvDelimiter;
                }
            }
        }
        // csv export body
        data.forEach(row => {
            csv += '\n';
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].export !== false) {
                    // get field settings
                    const /** @type {?} */ fieldSetting = this.getProperty(this._gtFields, this._gtSettings[i].objectKey);
                    // get export value, if export function is defined use it otherwise check for value function and as a last resort export raw data
                    let /** @type {?} */ exportValue = fieldSetting.export && typeof fieldSetting.export === 'function'
                        ? fieldSetting.export(row)
                        : fieldSetting.value && typeof fieldSetting.value === 'function'
                            ? fieldSetting.value(row)
                            : row[this._gtSettings[i].objectKey];
                    // escape export value using double quotes (") if export value contains delimiter
                    exportValue =
                        typeof exportValue === 'string' &&
                            exportValue.indexOf(this._gtOptions.csvDelimiter) !== -1
                            ? '"' + exportValue + '"'
                            : exportValue;
                    csv += exportValue;
                    if (i < this._gtSettings.length - 1) {
                        csv += this._gtOptions.csvDelimiter;
                    }
                }
            }
        });
        const /** @type {?} */ blob = new Blob([(useBOM ? BOM : '') + csv], {
            type: 'text/csv;charset=utf-8'
        });
        if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
        }
        else {
            const /** @type {?} */ link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            if (link.download !== undefined) {
                link.setAttribute('href', 'data:text/csv;charset=utf-8,' +
                    encodeURIComponent((useBOM ? BOM : '') + csv)); // URL.createObjectURL(blob));
                link.setAttribute('download', fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
                document.body.appendChild(link);
                link.click();
            }
            else {
                csv = 'data:text/csv;charset=utf-8,' + (useBOM ? BOM : '') + csv;
                window.open(encodeURIComponent(csv));
            }
            document.body.removeChild(link);
        }
        // emit export event
        this.gtEvent.emit({
            name: 'gt-exported-csv',
            value: fileName ? fileName : this.gtTexts.csvDownload + '.csv'
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // if number of row to display from start is set to null or 0...
        if (!this.gtOptions.numberOfRows) {
            // ...change row length
            this.changeRowLength(this.gtOptions.numberOfRows);
        }
        this.restructureSorting();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // if gt texts have changed...
        if (changes['gtTexts']) {
            // ...extend gtOptions default values with values passed into component
            this.gtTexts = /** @type {?} */ (this.extend(this.gtDefaultTexts, this.gtTexts));
        }
        // if lazy loading data and paging information is available...
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            // ...calculate total number of pages
            this.gtInfo.pageTotal = Math.ceil(this.gtInfo.recordsAfterSearch / this.gtInfo.recordLength);
            // ...declare store position
            const /** @type {?} */ storePosition = this.gtInfo.pageCurrent - 1;
            // ...and if store is empty or page length has changed...
            if (this.store.length === 0 ||
                this.store[0].length !== this.gtInfo.recordLength) {
                // ...create store
                this.store = this.createStore(this.gtInfo.recordsAfterSearch, this.gtInfo.recordLength);
            }
            // ...store retrieved data in store at store position
            this.store[storePosition] = this.gtData;
            this.gtInfo.visibleRecords = [...this.gtData]; // add visible rows
            // replace data with store
            this._gtData = this.store;
            this.loading = false;
            this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-info',
                value: this.gtInfo
            });
        }
        else if (this._gtData &&
            this._gtData.length >= 0 &&
            changes['gtData'] &&
            changes['gtData'].previousValue) {
            this.loading = false;
        }
        else if (changes['gtData'] &&
            changes['gtData'].firstChange &&
            this._gtData &&
            this._gtData.length > 0) {
            this.loading = false;
        }
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByFn(index, item) {
        return item.$$gtRowId;
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByColumnFn(index, item) {
        return item.objectKey;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // remove listener
        this._stopListeningForKeydownEvent();
    }
}
GenericTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'generic-table',
                template: `<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length > 0">
  <thead>
  <tr>
    <th class="gt-sort-label" *ngIf="gtOptions.stack">{{gtTexts.sortLabel}}</th>
    <th *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe"
        ngClass="{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{column.sortEnabled ? 'sort-'+column.sort:''}} {{column.sortEnabled && column.sortOrder >= 0  ? 'sort-order-'+column.sortOrder:''}} {{ gtFields | gtColumnClass:column }}"
        (click)="column.sortEnabled ? gtSort(column.objectKey,$event):'';">
      <span *ngIf="!(gtFields | gtProperty:column.objectKey:'header')">{{gtFields | gtProperty:column.objectKey:'name'}}</span>
      <gt-custom-component-factory *ngIf="(gtFields | gtProperty:column.objectKey:'header')"
                                   [type]="(gtFields | gtProperty:column.objectKey:'header')?.type"
                                   [injector]="(gtFields | gtProperty:column.objectKey:'header')?.injector"
                                   [column]="gtFields | gtProperty:column.objectKey:'name'"></gt-custom-component-factory>
      <gt-checkbox *ngIf="(gtFields | gtProperty:column.objectKey:'columnComponent')?.type === 'checkbox'" [checked]="(gtOptions.lazyLoad ? lazyAllSelected:selectedRows.length === gtData.length)" (changed)="toggleAllRows()"></gt-checkbox>
    </th>
  </tr>
  </thead>
  <ng-template
    [ngIf]="gtTotals && (gtOptions.lazyLoad === false ? (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length).length > 0 : gtData.length > 0)">
    <thead class="gt-totals">
    <tr *ngFor="let total of gtTotals | gtTotalsPosition">
      <td *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;"
          ngClass="{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}">
        <span *ngIf="i === 0" class="float-left">{{total.name}}</span><span
        [innerHTML]="total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals"></span>
      </td>
    </tr>
    </thead>
    <tfoot class="gt-totals">
    <tr *ngFor="let total of gtTotals | gtTotalsPosition:'footer'">
      <td *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;"
          ngClass="{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}">
        <span *ngIf="i === 0" class="float-left">{{total.name}}</span><span
        [innerHTML]="total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals"></span>
      </td>
    </tr>
    </tfoot>
  </ng-template>
  <tbody *ngIf="gtData && gtInfo">
  <ng-template class="table-rows" ngFor let-row let-last="last" [ngForTrackBy]="trackByFn"
               [ngForOf]="gtOptions.lazyLoad && gtInfo ? (gtData[gtInfo.pageCurrent-1]) : (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length | gtOrderBy:sortOrder:gtFields:refreshSorting:gtData.length | gtChunk:gtInfo:gtInfo.recordLength:gtInfo.pageCurrent:refreshPageArray:gtData.length:gtEvent:data | gtRowClass:gtFields)">
    <tr [ngClass]="{'row-selected':metaInfo[row.$$gtRowId]?.isSelected, 'row-open':metaInfo[row.$$gtRowId]?.isOpen, 'row-loading':loading, 'row-expandable':gtRowComponent}"
        class="{{row.$$gtRowClass}}"
        (click)="gtOptions.rowSelection ? toggleSelect(row):rowClick(row, $event)">
      <td *ngFor="let column of row | gtRender:gtSettings:gtFields:refreshPipe:loading:gtOptions.highlightSearch:gtInfo.searchTerms;trackBy:trackByColumnFn"
          ngClass="{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{(gtFields | gtProperty:column.objectKey:'inlineEdit') ? 'gt-inline-edit':''}} {{column.edited ? 'gt-edited':''}} {{ gtFields | gtColumnClass:column:row }}">
                        <span class="gt-row-label"
                              *ngIf="gtOptions.stack">{{(gtFields | gtProperty:column.objectKey:'stackedHeading') ? (gtFields | gtProperty:column.objectKey:'stackedHeading') : (gtFields | gtProperty:column.objectKey:'name')}}</span>
        <gt-custom-component-factory *ngIf="column.columnComponent && column.columnComponent.type !== 'checkbox'" class="gt-row-content"
                                     [type]="column.columnComponent.type"
                                     [injector]="column.columnComponent.injector" [row]="row"
                                     [column]="column" (redrawEvent)="redraw($event)"
                                     [searchTerms]="gtInfo.searchTerms"  (searchEvent)="redraw($event)"
                                     (click)="column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''"></gt-custom-component-factory>
        <span *ngIf="!column.columnComponent && (!(gtFields | gtProperty:column.objectKey:'inlineEdit') || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || (!((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe)))"
              class="gt-row-content" [innerHTML]="column.renderValue"
              (click)="column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''"></span>
        <ng-template
          [ngIf]="!column.columnComponent && (((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe))">
          <ng-template [ngIf]="([true,'email','number','password', 'text'].indexOf((gtFields | gtProperty:column.objectKey:'inlineEdit').type) !== -1) || !(gtFields | gtProperty:column.objectKey:'inlineEdit').type">
            <input class="inline-edit" [attr.type]="!(gtFields | gtProperty:column.objectKey:'inlineEdit').type ? 'text' : !((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type:(gtFields | gtProperty:column.objectKey:'inlineEdit').type | async" [(ngModel)]="column.renderValue"
                   (keyup)="gtUpdateColumn($event,row, column)">
            <span class="gt-inline-edit-notice">{{gtTexts.inlineEditEdited}}</span>
          </ng-template>
          <gt-dropdown
            *ngIf="(((gtFields | gtProperty:column.objectKey:'inlineEdit').type) && ((gtFields | gtProperty:column.objectKey:'inlineEdit').type).length > 0) || ((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable)"
            [options]="!((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type : (gtFields | gtProperty:column.objectKey:'inlineEdit').type | async"
            [id]="'_' + row.$$gtRowId + '_' + column.objectKey"
            [(selected)]="column.renderValue" (selectedChange)="gtDropdownSelect(row, column)">Add
            inline editing module
          </gt-dropdown>
        </ng-template>
        <ng-template [ngIf]="!column.columnComponent && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active) ">
          <ng-template
            [ngIf]="[true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') !== -1">
            <input class="inline-edit" [attr.type]="(gtFields | gtProperty:column.objectKey:'inlineEdit') === true ? 'text':(gtFields | gtProperty:column.objectKey:'inlineEdit')" [(ngModel)]="column.renderValue"
                   (keyup)="gtUpdateColumn($event,row, column)">
            <span class="gt-inline-edit-notice">{{gtTexts.inlineEditEdited}}</span>
          </ng-template>
          <gt-dropdown
            *ngIf="(gtFields | gtProperty:column.objectKey:'inlineEdit') && [true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') === -1"
            [options]="gtFields | gtProperty:column.objectKey:'inlineEdit'"
            [id]="'_' + row.$$gtRowId + '_' + column.objectKey"
            [(selected)]="column.renderValue" (selectedChange)="gtDropdownSelect(row, column)">Add
            inline editing module
          </gt-dropdown>
        </ng-template>
        <gt-checkbox *ngIf="column.columnComponent && column.columnComponent.type === 'checkbox'" [checked]="metaInfo[row.$$gtRowId]?.isSelected" (changed)="toggleSelect(row)"></gt-checkbox>
      </td>
    </tr>
    <tr class="row-expanded" *ngIf="metaInfo[row.$$gtRowId]?.isOpen">
      <td [attr.colspan]="(gtFields | gtVisible:gtSettings:refreshPipe).length">
        <gt-expanding-row [row]="row"
                          [type]="expandedRow.component ? expandedRow.component:gtRowComponent"
                          [columnWidth]="columnWidth"
                          [gtFields]="gtFields"
                          [gtOptions]="gtOptions"
                          [gtEvent]="gtEvent"
                          [gtInfo]="gtInfo"
                          [gtSettings]="gtSettings"
                          [data]="expandedRow.data ? expandedRow.data:row"
                          (redrawEvent)="redraw($event)"
                          (toggleRowEvent)="toggleCollapse($event)"></gt-expanding-row>
      </td>
    </tr>
    <tr *ngIf="gtOptions.reportColumnWidth && last">
      <td style="padding: 0; border:none;"
          *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe" gtColumnWidth
          [objectKey]="column.objectKey" [widths]="columnWidth"></td>
    </tr>
  </ng-template>
  <tr *ngIf="gtInfo.pageTotal === 0 && (gtInfo.searchTerms || gtInfo.filter) && !loading">
    <td class="gt-no-matching-results" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">
      {{gtTexts.noMatchingData}}
    </td>
  </tr>
  <tr *ngIf="gtInfo.pageTotal === 0 && !(gtInfo.searchTerms || gtInfo.filter) && !loading">
    <td class="gt-no-results" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">{{gtTexts.noData}}
    </td>
  </tr>
  <tr *ngIf="gtInfo.pageTotal === 0 && loading">
    <td class="gt-loading-data" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">{{gtTexts.loading}}</td>
  </tr>
  </tbody>
</table>
<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length === 0">
  <thead>
  <tr>
    <th class="gt-no-visible-columns">{{gtTexts.noVisibleColumnsHeading}}</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="gt-no-visible-columns">{{gtTexts.noVisibleColumns}}</td>
  </tr>
  </tbody>
</table>
<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="!gtFields || !gtSettings">
  <thead>
  <tr>
    <th class="gt-loading-config">&nbsp;</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="gt-loading-config">&nbsp;</td>
  </tr>
  </tbody>
</table>
`
            },] },
];
/** @nocollapse */
GenericTableComponent.ctorParameters = () => [
    { type: Renderer2, },
    { type: GtMetaPipe, },
];
GenericTableComponent.propDecorators = {
    "gtOptions": [{ type: Input },],
    "gtTotals": [{ type: Input },],
    "gtFields": [{ type: Input },],
    "gtSettings": [{ type: Input },],
    "gtData": [{ type: Input },],
    "gtRowComponent": [{ type: Input },],
    "gtTexts": [{ type: Input },],
    "gtClasses": [{ type: Input },],
    "gtEvent": [{ type: Output },],
    "gtInfo": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtTableInfoComponent {
    /**
     * @param {?} _changeDetectionRef
     */
    constructor(_changeDetectionRef) {
        this._changeDetectionRef = _changeDetectionRef;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this._changeDetectionRef.detectChanges();
    }
}
GtTableInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'gt-table-info',
                template: `<span *ngIf="genericTable.gtInfo">{{(customText? customText:genericTable.gtTexts) | gtTableInfo:
		genericTable.gtInfo:
		genericTable.gtInfo.recordsAfterSearch:
		genericTable.gtInfo.recordFrom:
		genericTable.gtInfo.recordTo:
		genericTable.gtInfo.recordsAll:
		genericTable.gtTexts.loading:
		genericTable.gtTexts.tableInfoAfterSearch}}</span>`
            },] },
];
/** @nocollapse */
GtTableInfoComponent.ctorParameters = () => [
    { type: ChangeDetectorRef, },
];
GtTableInfoComponent.propDecorators = {
    "genericTable": [{ type: Input },],
    "customText": [{ type: Input },],
};
class TableInfoPipe {
    /**
     * @param {?} texts
     * @param {?} keys
     * @param {?} recordsAfterSearch
     * @param {?} recordFrom
     * @param {?} recordTo
     * @param {?} recordsAll
     * @param {?} loading
     * @param {?} tableInfoAfterSearch
     * @return {?}
     */
    transform(texts, keys, recordsAfterSearch, recordFrom, recordTo, recordsAll, loading, tableInfoAfterSearch) {
        let /** @type {?} */ text = typeof texts === 'object' ? texts.tableInfo : '';
        if (keys.recordsAfterSearch !== keys.recordsAll) {
            text = typeof texts === 'object' ? texts.tableInfoAfterSearch : '';
        }
        for (const /** @type {?} */ key in keys) {
            if (keys.hasOwnProperty(key)) {
                const /** @type {?} */ searchString = new RegExp('#' + key, 'g');
                text = text.replace(searchString, keys[key]);
            }
        }
        return text;
    }
}
TableInfoPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtTableInfo'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtPaginationComponent {
    constructor() {
        this.ready = false;
    }
    /**
     * @return {?}
     */
    get genericTable() {
        return this._genericTable;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set genericTable(value) {
        if (value) {
            value.gtEvent.subscribe((res) => {
                if (res.name === 'gt-info' && res.value.pageTotal > 0) {
                    this.ready = true;
                }
            });
        }
        this._genericTable = value;
    }
}
GtPaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'gt-pagination',
                template: `<nav class="gt-pagination" aria-label="Table navigation" *ngIf="genericTable && genericTable.gtInfo && ready && genericTable.gtData?.length > 0" [ngClass]="{'no-data':genericTable.gtInfo.pageTotal === 0}">
  <ul class="pagination" [ngClass]="gtClasses">
    <li class="page-item" [ngClass]="{'disabled' : genericTable.gtInfo.pageCurrent === 1 || genericTable.loading }"><a class="page-link" href="javascript:void(0);" (click)="genericTable.gtInfo.pageCurrent > 1 && genericTable.previousPage()" [attr.aria-label]="genericTable.gtTexts.paginatePrevious"><span aria-hidden="true">&laquo;</span><span class="sr-only">{{genericTable.gtTexts.paginatePrevious}}</span></a></li>
    <li class="page-item" [ngClass]="{'disabled' : genericTable.loading && genericTable.gtInfo.pageCurrent !== page, 'active' : genericTable.gtInfo.pageCurrent === page }" *ngFor="let page of genericTable.gtInfo.pageTotal | gtPaginationPipe:genericTable.gtInfo.pageCurrent"><a class="page-link" [tabindex]="page === true ? -1:0" href="javascript:void(0);" (click)="page === true ? '':genericTable.goToPage(page)">{{page === true ? '&hellip;':page}}</a></li>
    <li class="page-item" [ngClass]="{'disabled' : genericTable.gtInfo.pageCurrent === genericTable.gtInfo.pageTotal || genericTable.loading }"><a class="page-link gt-link" href="javascript:void(0);" (click)="genericTable.gtInfo.pageCurrent !== genericTable.gtInfo.pageTotal && genericTable.nextPage()" [attr.aria-label]="genericTable.gtTexts.paginateNext"><span aria-hidden="true">&raquo;</span><span class="sr-only">{{genericTable.gtTexts.paginateNext}}</span></a></li>
  </ul>
  </nav>
    `,
                styles: ['.gt-link {cursor: pointer;}']
            },] },
];
/** @nocollapse */
GtPaginationComponent.propDecorators = {
    "genericTable": [{ type: Input },],
    "gtClasses": [{ type: Input },],
};
class PaginationPipe {
    /**
     * @param {?} totalPages
     * @param {?} currentPage
     * @return {?}
     */
    transform(totalPages, currentPage) {
        if (totalPages === 0) {
            return [1];
        }
        const /** @type {?} */ pagination = []; // create new empty array for pagination
        const /** @type {?} */ siblings = 2; // sibling elements ie. number of elements on each side of current page
        const /** @type {?} */ paginationLength = totalPages < siblings * 2 + 1 ? totalPages : siblings * 2 + 1; // number of elements in pagination array
        const /** @type {?} */ start = currentPage <= siblings ? 1 : currentPage - siblings; // starting position for array
        const /** @type {?} */ modifier = totalPages - (currentPage + siblings) <= 0
            ? totalPages - (currentPage + siblings)
            : 0; // modifier for pagination values
        const /** @type {?} */ modifiedPosition = start + modifier <= 0 ? 1 : start + modifier;
        // push pages to pagination array
        for (let /** @type {?} */ i = 0; i < paginationLength; i++) {
            pagination.push(modifiedPosition + i);
        }
        // if first page is not included in pagination...
        if (pagination.indexOf(1) === -1) {
            // ...check if second page is in pagination...
            if (pagination.indexOf(2) === -1) {
                // ...if not check if total number of pages equals seven and number of siblings are two...
                if (totalPages === 7 && siblings === 2) {
                    // ...add second page and don't convert page number to ellipsis
                    pagination.unshift(2);
                }
                else {
                    // ...if not, use this placeholder for ellipsis instead of actual page number
                    pagination[0] = true;
                }
            }
            // ...add first page as first array item
            pagination.unshift(1);
        }
        else if (totalPages > paginationLength) {
            // if first page is included add extra page to keep number of items consistent
            pagination.splice(paginationLength, 0, paginationLength + 1);
        }
        // check if last page is included in pagination...
        if (pagination.indexOf(totalPages) === -1) {
            // ...if not, page next to last should either show ellipsis or actual page number for the page
            pagination[pagination.length - 1] =
                pagination[pagination.length - 1] === totalPages - 1
                    ? totalPages - 1
                    : true;
            // ...add last page to pagination
            pagination.push(totalPages);
        }
        return pagination;
    }
}
PaginationPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtPaginationPipe'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtDrilldownComponent extends GtExpandedRow {
    constructor() {
        super();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
GtDrilldownComponent.decorators = [
    { type: Component, args: [{
                selector: 'gt-drilldown',
                template: `
      <table class="table">
          <tr *ngFor="let row of data" (click)="$rowClick(row, $event)">
              <!--<td *ngFor="let column of gtSettings" [style.width]="columnWidth[column.objectKey]">{{column.objectKey}}</td>-->
              <td *ngFor="let column of row | gtRender:gtSettings:gtFields:null:null:gtOptions.highlightSearch:gtInfo.searchTerms;"
                  ngClass="{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{(gtFields | gtProperty:column.objectKey:'inlineEdit') ? 'gt-inline-edit':''}} {{column.edited ? 'gt-edited':''}} {{ gtFields | gtColumnClass:row:column }}" [style.width]="columnWidth[column.objectKey]" [style.max-width]="columnWidth[column.objectKey]">
                        <span class="gt-row-label"
                              *ngIf="gtOptions.stack">{{(gtFields | gtProperty:column.objectKey:'stackedHeading') ? (gtFields | gtProperty:column.objectKey:'stackedHeading') : (gtFields | gtProperty:column.objectKey:'name')}}</span>
                  <gt-custom-component-factory *ngIf="column.columnComponent" class="gt-row-content"
                                               [type]="column.columnComponent.type"
                                               [injector]="column.columnComponent.injector" [row]="row"
                                               [column]="column" (redrawEvent)="$redraw($event)"
                                               (click)="column.click ? column.click(row,column,$event):'';"></gt-custom-component-factory>
                  <span *ngIf="!column.columnComponent"
                        class="gt-row-content" [innerHTML]="column.renderValue"
                        (click)="column.click ? column.click(row,column,$event):''"></span>
              </td>

          </tr>
      </table>
  `,
                styles: []
            },] },
];
/** @nocollapse */
GtDrilldownComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtHighlightPipe {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    /**
     * @param {?} text
     * @param {?} searchTerm
     * @return {?}
     */
    transform(text, searchTerm) {
        const /** @type {?} */ haystackAlwaysString = text + '';
        let /** @type {?} */ highlightedText = haystackAlwaysString; // fallback
        let /** @type {?} */ searchPattern;
        try {
            searchPattern = new RegExp('(' +
                searchTerm
                    .toLowerCase()
                    .match(/".*?"|[^ ]+/g) // extract words
                    .map(needle => needle.replace(/"(.*?)"/, '$1') // strip away '"'
                )
                    .join('|') + // combine words
                ')', 'ig');
        }
        catch (/** @type {?} */ error) {
            return this.sanitizer.bypassSecurityTrustHtml(highlightedText);
        }
        const /** @type {?} */ containsTagPattern = /(<.*?>)(.*)(<\/.*?>)/gi;
        const /** @type {?} */ containsTagMatches = containsTagPattern.exec(haystackAlwaysString);
        if (containsTagMatches) {
            // tag exists in haystack
            highlightedText =
                containsTagMatches[1] +
                    containsTagMatches[2].replace(searchPattern, '<span class="gt-highlight-search">$1</span>') +
                    containsTagMatches[3];
        }
        else {
            highlightedText = haystackAlwaysString.replace(searchPattern, '<span class="gt-highlight-search">$1</span>');
        }
        return this.sanitizer.bypassSecurityTrustHtml(highlightedText);
    }
}
GtHighlightPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtHighlight'
            },] },
];
/** @nocollapse */
GtHighlightPipe.ctorParameters = () => [
    { type: DomSanitizer, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
/**
 * @template R
 */
class GtRenderPipe {
    /**
     * @param {?} sanitizer
     * @param {?} gtHighlightPipe
     */
    constructor(sanitizer, gtHighlightPipe) {
        this.sanitizer = sanitizer;
        this.gtHighlightPipe = gtHighlightPipe;
        /**
         * Sort by column order
         */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder < b.columnOrder) {
                return -1;
            }
            if (a.columnOrder > b.columnOrder || typeof a.columnOrder === 'undefined') {
                return 1;
            }
            return 0;
        };
        /**
         * Sort by length
         */
        this.getOrderByLength = function (a, b) {
            return b.length - a.length;
        };
        /**
         * Return property
         */
        this.getProperty = function (array, key) {
            for (let /** @type {?} */ i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
    }
    /**
     * @param {?} row
     * @param {?} settings
     * @param {?} fields
     * @param {?} updated
     * @param {?} loading
     * @param {?=} highlight
     * @param {?=} searchString
     * @return {?}
     */
    transform(row, settings, fields, updated, loading, highlight = false, searchString) {
        // let arr = [{"temp":123,"name":"happy"},{"temp":456,"name":"dfgdfg"},{"temp":789,"name":"asdasd"}];
        // console.log(arr,arr.map(function(item){return item.temp}));
        // console.log(settings.map('objectKey'));
        // console.log('render');
        const /** @type {?} */ columns = [];
        for (let /** @type {?} */ i = 0; i < settings.length; i++) {
            if (settings[i].visible !== false && settings[i].enabled !== false) {
                columns.push(settings[i].objectKey);
            }
        }
        for (let /** @type {?} */ i = 0; i < fields.length; i++) {
            // console.log(!row[fields[i].objectKey]);
            if (fields[i].value &&
                typeof fields[i].value === 'function' &&
                !row.hasOwnProperty(fields[i].objectKey)) {
                row[fields[i].objectKey] = loading ? '' : fields[i].value(row);
            }
        }
        // console.log(row);
        const /** @type {?} */ keys = [];
        for (const /** @type {?} */ key in row) {
            // console.log(key);
            if (columns.indexOf(key) !== -1) {
                let /** @type {?} */ fieldSetting;
                for (let /** @type {?} */ i = 0; i < fields.length; i++) {
                    if (fields[i].objectKey === key) {
                        fieldSetting = fields[i];
                        // console.log(fieldSetting);
                    }
                }
                const /** @type {?} */ columnObject = {
                    objectKey: key,
                    sortValue: row[key]
                };
                // add component if defined
                if (fieldSetting.columnComponent) {
                    columnObject.columnComponent = fieldSetting.columnComponent;
                }
                if (loading) {
                    columnObject.renderValue = row[key] !== null ? row[key] : '';
                }
                else if (highlight &&
                    searchString &&
                    this.getProperty(settings, key).search !== false) {
                    columnObject.renderValue =
                        fieldSetting.render && typeof fieldSetting.render === 'function'
                            ? this.gtHighlightPipe.transform(fieldSetting.render(row), searchString)
                            : this.gtHighlightPipe.transform(row[key] !== null ? row[key] : '', searchString);
                }
                else {
                    columnObject.renderValue =
                        fieldSetting.render && typeof fieldSetting.render === 'function'
                            ? this.sanitizer.bypassSecurityTrustHtml(fieldSetting.render(row))
                            : row[key] !== null
                                ? row[key]
                                : '';
                }
                if (fieldSetting.click && typeof fieldSetting.click === 'function') {
                    columnObject.click = fieldSetting.click;
                }
                if (fieldSetting.expand) {
                    columnObject.expand = fieldSetting.expand;
                }
                keys.push(columnObject);
            }
        }
        keys.sort(function (a, b) {
            return columns.indexOf(a.objectKey) < columns.indexOf(b.objectKey)
                ? -1
                : 1;
        });
        return keys;
    }
}
GtRenderPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtRender'
            },] },
];
/** @nocollapse */
GtRenderPipe.ctorParameters = () => [
    { type: DomSanitizer, },
    { type: GtHighlightPipe, },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
/**
 * @template R
 */
class GtVisiblePipe {
    constructor() {
        /**
         * Sort by column order
         */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder < b.columnOrder) {
                return -1;
            }
            if (a.columnOrder > b.columnOrder || typeof a.columnOrder === 'undefined') {
                return 1;
            }
            return 0;
        };
    }
    /**
     * @param {?} array
     * @param {?} settings
     * @param {?=} refreshPipe
     * @return {?}
     */
    transform(array, settings, refreshPipe) {
        const /** @type {?} */ visibleColumns = settings
            .sort(this.getColumnOrder)
            .map((setting) => {
            if (setting.visible !== false && setting.enabled !== false) {
                return setting.objectKey;
            }
        });
        return array
            .filter((column) => {
            return visibleColumns.indexOf(column.objectKey) !== -1;
        })
            .sort(function (a, b) {
            return visibleColumns.indexOf(a.objectKey) <
                visibleColumns.indexOf(b.objectKey)
                ? -1
                : 1;
        });
    }
}
GtVisiblePipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtVisible'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DashCasePipe {
    /**
     * @param {?} string
     * @return {?}
     */
    transform(string) {
        return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
}
DashCasePipe.decorators = [
    { type: Pipe, args: [{
                name: 'dashCase'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
/**
 * @template R
 */
class GtPropertyPipe {
    /**
     * @param {?} config
     * @param {?} objectKey
     * @param {?} property
     * @param {?=} refresh
     * @return {?}
     */
    transform(config, objectKey, property, refresh) {
        let /** @type {?} */ output = null;
        try {
            for (let /** @type {?} */ i = 0; i < config.length; i++) {
                if (config[i].objectKey === objectKey) {
                    output = config[i][property];
                }
            }
        }
        catch (/** @type {?} */ error) {
            console.log('cannot read property: "' +
                property +
                '" on missing key: "' +
                objectKey +
                '" in config.', error);
        }
        return output;
    }
}
GtPropertyPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtProperty'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtChunkPipe {
    /**
     * @param {?} array
     * @param {?} gtInfo
     * @param {?} chunkSize
     * @param {?} page
     * @param {?} refreshPageArray
     * @param {?} refreshData
     * @param {?} gtEvent
     * @param {?} data
     * @return {?}
     */
    transform(array, gtInfo, chunkSize, page, refreshPageArray, refreshData, gtEvent, data) {
        if (!Array.isArray(array)) {
            return array;
        }
        data.exportData = array; // store data for export
        const /** @type {?} */ PAGES = [];
        const /** @type {?} */ ENTRIES = array.length;
        for (let /** @type {?} */ i = 0; i < ENTRIES; i += chunkSize) {
            PAGES.push(array.slice(i, i + chunkSize));
        }
        gtInfo.visibleRecords = !PAGES[page - 1] ? [] : [...PAGES[page - 1]]; // add visible rows
        gtInfo.pageTotal = PAGES.length; // add number of pages
        setTimeout(() => gtEvent.emit({
            name: 'gt-info',
            value: gtInfo
        }), 0);
        return PAGES[page - 1];
    }
}
GtChunkPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtChunk'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtFilterPipe {
    /**
     * @param {?} allRows
     * @param {?} filterBy
     * @param {?} gtInfo
     * @param {?} refreshFilter
     * @param {?} refreshData
     * @return {?}
     */
    transform(allRows, filterBy, gtInfo, refreshFilter, refreshData) {
        // console.log(allRows,filterBy);
        gtInfo.recordsAll = allRows.length;
        if (!Array.isArray(allRows) || !filterBy) {
            // gtInfo.filtered = false;
            const /** @type {?} */ length = allRows === null ? 0 : allRows.length;
            gtInfo.recordsAfterFilter = length;
            return allRows;
        }
        const /** @type {?} */ output = [];
        for (let /** @type {?} */ i = 0; i < allRows.length; i++) {
            const /** @type {?} */ rowObject = allRows[i];
            let /** @type {?} */ match = true;
            for (const /** @type {?} */ property in filterBy) {
                if (filterBy.hasOwnProperty(property)) {
                    // console.log(property);
                    // console.log(filter[property].indexOf(obj[property]));
                    if (filterBy[property].indexOf(rowObject[property]) === -1) {
                        match = false;
                    }
                }
            }
            if (match) {
                output.push(rowObject);
            }
        }
        gtInfo.recordsAfterFilter = output.length; // .emit(output.length);
        return output;
    }
}
GtFilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtFilter'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
/**
 * @template R
 */
class GtOrderByPipe {
    constructor() {
        /**
         * Return property
         */
        this.getProperty = function (array, key) {
            for (let /** @type {?} */ i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    static _orderByComparator(a, b) {
        // sort boolean values as strings
        if (typeof a === 'boolean') {
            a = a.toString();
        }
        if (typeof b === 'boolean') {
            b = b.toString();
        }
        if (isNaN(parseFloat(a)) ||
            !isFinite(a) ||
            (isNaN(parseFloat(b)) || !isFinite(b))) {
            if (b === null ||
                (typeof b === 'undefined' && (a !== null && typeof a !== 'undefined'))) {
                return 1;
            }
            if (a === null ||
                (typeof a === 'undefined' && (b !== null && typeof b !== 'undefined'))) {
                return -1;
            }
            // isn't a number so lowercase the string to properly compare
            try {
                if (a.toLowerCase() < b.toLowerCase()) {
                    return -1;
                }
                if (a.toLowerCase() > b.toLowerCase()) {
                    return 1;
                }
            }
            catch (/** @type {?} */ error) {
                return 0;
            }
        }
        else {
            // parse strings as numbers to compare properly
            if (parseFloat(a) < parseFloat(b)) {
                return -1;
            }
            if (parseFloat(a) > parseFloat(b)) {
                return 1;
            }
        }
        return 0; // equal each other
    }
    /**
     * Return sort function
     * @param {?} field
     * @return {?}
     */
    getSortFunction(field) {
        if (!field) {
            // console.log('error trying to sort undefined field');
            return false;
        }
        if (typeof field.sort === 'function') {
            return field.sort;
        }
        else if (typeof field.value === 'function') {
            return field.value;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} input
     * @param {?} sortByProperties
     * @param {?} fields
     * @param {?} refreshSorting
     * @param {?} refreshData
     * @return {?}
     */
    transform(input, sortByProperties, fields, refreshSorting, refreshData) {
        if (!Array.isArray(input) || input === null) {
            return input;
        }
        if (!Array.isArray(sortByProperties) ||
            (Array.isArray(sortByProperties) && sortByProperties.length === 1)) {
            const /** @type {?} */ propertyToCheck = sortByProperties[0];
            const /** @type {?} */ desc = propertyToCheck.substr(0, 1) === '-';
            // basic array
            if (!propertyToCheck ||
                propertyToCheck === '-' ||
                propertyToCheck === '+') {
                return !desc ? input.sort() : input.sort().reverse();
            }
            else {
                const /** @type {?} */ property = propertyToCheck.substr(0, 1) === '+' ||
                    propertyToCheck.substr(0, 1) === '-'
                    ? propertyToCheck.substr(1)
                    : propertyToCheck;
                // check if custom sort function is defined
                const /** @type {?} */ sortFunction = this.getSortFunction(this.getProperty(fields, property));
                // console.log(property);
                return input.sort(function (a, b) {
                    // use custom sort function if one is defined
                    const /** @type {?} */ propertyA = sortFunction === false
                        ? property === '$$gtRowId'
                            ? +a.$$gtRowId.split('_')[0]
                            : a[property]
                        : sortFunction(a);
                    const /** @type {?} */ propertyB = sortFunction === false
                        ? property === '$$gtRowId'
                            ? +b.$$gtRowId.split('_')[0]
                            : b[property]
                        : sortFunction(b);
                    // if both values are undefined...
                    if (typeof propertyA === 'undefined' &&
                        typeof propertyB === 'undefined') {
                        // ...skip comparison
                        return;
                    }
                    return !desc
                        ? GtOrderByPipe._orderByComparator(propertyA, propertyB)
                        : -GtOrderByPipe._orderByComparator(propertyA, propertyB);
                });
            }
        }
        else {
            // loop over property of the array in order and sort
            return input.sort((a, b) => {
                // console.log('multiple');
                for (let /** @type {?} */ i = 0; i < sortByProperties.length; i++) {
                    const /** @type {?} */ desc = sortByProperties[i].substr(0, 1) === '-';
                    const /** @type {?} */ property = sortByProperties[i].substr(0, 1) === '+' ||
                        sortByProperties[i].substr(0, 1) === '-'
                        ? sortByProperties[i].substr(1)
                        : sortByProperties[i];
                    // console.log(property);
                    // check if custom sort function is defined
                    const /** @type {?} */ sortFunction = this.getSortFunction(this.getProperty(fields, property));
                    // use custom sort function if one is defined
                    const /** @type {?} */ propertyA = sortFunction === false
                        ? property === '$$gtRowId'
                            ? +a.$$gtRowId.split('_')[0]
                            : a[property]
                        : sortFunction(a);
                    const /** @type {?} */ propertyB = sortFunction === false
                        ? property === '$$gtRowId'
                            ? +b.$$gtRowId.split('_')[0]
                            : b[property]
                        : sortFunction(b);
                    const /** @type {?} */ comparison = !desc
                        ? GtOrderByPipe._orderByComparator(propertyA, propertyB)
                        : -GtOrderByPipe._orderByComparator(propertyA, propertyB);
                    // don't return 0 yet in case of needing to sort by next property
                    if (comparison !== 0) {
                        return comparison;
                    }
                }
                return 0; // equal each other
            });
        }
    }
}
GtOrderByPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtOrderBy'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// unsupported: template constraints.
/**
 * @template R
 */
class GtSearchPipe {
    constructor() {
        /**
         * Return property
         */
        this.getProperty = function (array, key) {
            for (let /** @type {?} */ i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
    }
    /**
     * @param {?} allRows
     * @param {?} searchTerms
     * @param {?} gtInfo
     * @param {?} settings
     * @param {?} fields
     * @param {?} refreshData
     * @return {?}
     */
    transform(allRows, searchTerms, gtInfo, settings, fields, refreshData) {
        //  if no search terms are defined...
        if (!searchTerms || searchTerms.replace(/"/g, '').length === 0) {
            // ...return all rows
            const /** @type {?} */ length = allRows === null ? 0 : allRows.length;
            gtInfo.recordsAfterSearch = length;
            return allRows;
        }
        const /** @type {?} */ searchFunction = {};
        const /** @type {?} */ fieldsTemp = [];
        for (let /** @type {?} */ k = 0; k < fields.length; k++) {
            const /** @type {?} */ field = fields[k];
            // check if field should be included in global search
            const /** @type {?} */ include = this.getProperty(settings, field.objectKey).search === false
                ? false
                : true;
            // if include...
            if (include) {
                // ...and if search function is defined...
                if (typeof field.search === 'function') {
                    // ...add it as search function for field
                    searchFunction[field.objectKey] = field.search;
                }
                // ...if no search function is defined but value function is defined...
                else if (typeof field.value === 'function') {
                    // ...add it as search function for field
                    searchFunction[field.objectKey] = field.value;
                }
                // ...push it to our fields array
                fieldsTemp.push(field);
            }
        }
        const /** @type {?} */ filteredRows = [];
        searchTerms = typeof searchTerms === 'undefined' ? '' : searchTerms;
        const /** @type {?} */ searchTermsArray = searchTerms.toLowerCase().match(/(".*"|[^\s]+)/g);
        for (let /** @type {?} */ i = 0; i < allRows.length; i++) {
            const /** @type {?} */ row = allRows[i];
            let /** @type {?} */ string = '';
            for (let /** @type {?} */ j = 0; j < fieldsTemp.length; j++) {
                const /** @type {?} */ separator = j === 0 ? '' : ' & ';
                string += searchFunction[fieldsTemp[j].objectKey]
                    ? separator + searchFunction[fieldsTemp[j].objectKey](row, j)
                    : separator + row[fieldsTemp[j].objectKey];
            }
            string = string.toLowerCase();
            let /** @type {?} */ match = true;
            for (let /** @type {?} */ k = 0; k < searchTermsArray.length; k++) {
                const /** @type {?} */ term = searchTermsArray[k].replace(/"/g, '');
                match = string.indexOf(term) !== -1;
                if (!match) {
                    break;
                }
            }
            if (match) {
                filteredRows.push(row);
            }
        }
        gtInfo.recordsAfterSearch = filteredRows.length;
        // gtInfo.refresh(filteredRows.length,gt);
        return filteredRows;
    }
}
GtSearchPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtSearch'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template C
 */
class ComponentAnchorDirective {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} viewContainer
     */
    constructor(componentFactoryResolver, viewContainer) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.viewContainer = viewContainer;
        this.instance = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        const /** @type {?} */ factory = this.componentFactoryResolver.resolveComponentFactory(this.ctor);
        const /** @type {?} */ component = this.viewContainer.createComponent(factory, 0, this.injector);
        this.instance.emit(component.instance);
    }
}
ComponentAnchorDirective.decorators = [
    { type: Directive, args: [{
                selector: '[gtComponentAnchor]'
            },] },
];
/** @nocollapse */
ComponentAnchorDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver, },
    { type: ViewContainerRef, },
];
ComponentAnchorDirective.propDecorators = {
    "ctor": [{ type: Input },],
    "injector": [{ type: Input },],
    "instance": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 * @template R
 */
class GtCustomComponent {
    constructor() {
        this.redrawEvent = new EventEmitter();
        this.$searchTerms = new ReplaySubject(1);
    }
    /**
     * @param {?=} $event
     * @return {?}
     */
    $redraw($event) {
        this.redrawEvent.emit({ row: this.row, column: this.column });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.$searchTerms.subscribe(terms => (this.searchTerms = terms));
    }
}
// unsupported: template constraints.
/**
 * @template R, C
 */
class GtCustomComponentFactory {
    constructor() {
        this.$searchTerms = new ReplaySubject(1);
        this.redrawEvent = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set searchTerms(value) {
        this.$searchTerms.next(value);
    }
    /**
     * @param {?} instance
     * @return {?}
     */
    instance(instance) {
        instance.row = this.row;
        instance.column = this.column;
        instance.$searchTerms = this.$searchTerms;
        instance.redrawEvent.subscribe(this.redrawEvent);
    }
}
GtCustomComponentFactory.decorators = [
    { type: Component, args: [{
                selector: 'gt-custom-component-factory',
                template: `<div gtComponentAnchor [ctor]="type"
                    [injector]="injector"
                    (instance)="instance($event)"></div>`
            },] },
];
/** @nocollapse */
GtCustomComponentFactory.propDecorators = {
    "searchTerms": [{ type: Input },],
    "type": [{ type: Input },],
    "injector": [{ type: Input },],
    "row": [{ type: Input },],
    "column": [{ type: Input },],
    "redrawEvent": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtDropdownComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this.selectedChange = new EventEmitter();
        this.active = false;
        this.state = new Subject();
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    set selected(selection) {
        this._selected = selection;
    }
    /**
     * @param {?} option
     * @return {?}
     */
    select(option) {
        this.active = false;
        this.state.next(this.active);
        if (this._selected !== option) {
            this.selectedChange.emit(option);
        }
    }
    /**
     * @return {?}
     */
    toggleDropdown() {
        this.active = !this.active;
        setTimeout(() => {
            this.state.next(this.active);
        }, 0);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.state.subscribe(state => {
            if (state) {
                this.tether = new Tether({
                    element: '#' + this.id + '_menu',
                    target: '#' + this.id,
                    attachment: 'top left',
                    targetAttachment: 'bottom left',
                    constraints: [
                        {
                            to: 'window',
                            attachment: 'together'
                        }
                    ]
                });
                this.tether.position();
                // set up click listener and listen for click outside dropdown
                this.clickListener = this.renderer.listen('document', 'click', (event) => {
                    this.active = false;
                    this.state.next(this.active);
                });
                // set up keyboard listener and listen for escape key up
                this.keyupListener = this.renderer.listen('document', 'keyup', (event) => {
                    switch (event.key) {
                        case 'Escape':
                            this.active = false;
                            this.state.next(this.active);
                            break;
                    }
                });
            }
            else {
                this.tether.destroy();
                this.removeListeners();
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListeners();
    }
    /**
     * @return {?}
     */
    removeListeners() {
        if (this.clickListener) {
            this.clickListener();
        }
        if (this.keyupListener) {
            this.keyupListener();
        }
    }
}
GtDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'gt-dropdown',
                template: `
    <div class="dropdown gt-dropdown" [ngClass]="{'show':active}" [attr.id]="id">
      <div class="dropdown-toggle" (click)="toggleDropdown()" [attr.aria-expanded]="active">{{selected}}</div>
      <div class="gt-dropdown-menu dropdown-menu" *ngIf="active" [ngClass]="{'show':active}" [attr.id]="id+'_menu'">
        <button *ngFor="let option of options;" class="dropdown-item" (click)="select(option)" [ngClass]="{'active':option === selected}">{{option}}</button>
      </div>
    </div>
  `,
                styles: [
                    `
    .gt-dropdown .dropdown-toggle {
      cursor: pointer;
    }
    .gt-dropdown .dropdown-toggle::after {
      transition: opacity 0.4s ease-in-out;
      opacity: 0;
    }
    .gt-dropdown .dropdown-toggle:hover::after {
      opacity: 1;
    }
  `
                ]
            },] },
];
/** @nocollapse */
GtDropdownComponent.ctorParameters = () => [
    { type: Renderer2, },
];
GtDropdownComponent.propDecorators = {
    "selected": [{ type: Input },],
    "options": [{ type: Input },],
    "id": [{ type: Input },],
    "selectedChange": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtTotalsPipe {
    /**
     * @param {?} value
     * @param {?} data
     * @param {?} objectKey
     * @param {?} refresh
     * @return {?}
     */
    transform(value, data, objectKey, refresh) {
        let /** @type {?} */ output;
        if (data.length === 0) {
            return;
        }
        if (typeof value === 'function') {
            output = value(data, objectKey);
        }
        else if (value) {
            output = value;
        }
        else {
            output = '';
        }
        return output;
    }
}
GtTotalsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtTotals'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtTotalsPositionPipe {
    /**
     * @param {?} array
     * @param {?=} position
     * @return {?}
     */
    transform(array, position = 'header') {
        return array.filter(total => {
            // if no position is defined assume position to be header
            const /** @type {?} */ totalPosition = total.position ? total.position : 'header';
            return totalPosition === position;
        });
    }
}
GtTotalsPositionPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtTotalsPosition'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtRowClassPipe {
    /**
     * @param {?} array
     * @param {?} gtFields
     * @return {?}
     */
    transform(array, gtFields) {
        if (array) {
            // find columns with rowClass property defined
            const /** @type {?} */ COLUMNS_WITH_CLASS = gtFields
                .map(column => column)
                .filter(column => column.rowClass);
            COLUMNS_WITH_CLASS.map(column => {
                // for each column with rowClass property defined...
                array.map(row => {
                    // loop through rows and set row class
                    if (typeof column.rowClass === 'function') {
                        // if row class is a function, try using the function...
                        try {
                            if (row.$$gtRowClass) {
                                row.$$gtRowClass = row.$$gtRowClass.concat(' ' + column.rowClass(row, column));
                            }
                            else {
                                row.$$gtRowClass = column.rowClass(row, column);
                            }
                        }
                        catch (/** @type {?} */ error) {
                            console.log('Error when trying to get row class name using formula.', error);
                        }
                    }
                    else {
                        // if not a function, return plain string value
                        if (row.$$gtRowClass) {
                            row.$$gtRowClass = row.$$gtRowClass.concat(' ' + column.rowClass);
                        }
                        else {
                            row.$$gtRowClass = column.rowClass;
                        }
                    }
                });
            });
        }
        return array;
    }
}
GtRowClassPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtRowClass'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtColumnClassPipe {
    /**
     * @param {?} gtFields
     * @param {?} column
     * @param {?=} row
     * @return {?}
     */
    transform(gtFields, column, row) {
        // find columns with columnClass property defined
        const /** @type {?} */ COLUMN_WITH_CLASS = gtFields
            .map(field => field)
            .filter(field => field.columnClass && field.objectKey === column.objectKey)[0];
        if (!COLUMN_WITH_CLASS) {
            return;
        }
        else if (typeof COLUMN_WITH_CLASS.columnClass === 'function') {
            // if column class is a function, try using the function...
            try {
                return COLUMN_WITH_CLASS.columnClass(row, column);
            }
            catch (/** @type {?} */ error) {
                console.log('Error when trying to get column class name using formula.', error);
            }
        }
        else {
            // if not a function, return plain string value
            return COLUMN_WITH_CLASS.columnClass;
        }
    }
}
GtColumnClassPipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtColumnClass'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtColumnWidthDirective {
    /**
     * @param {?} hostElement
     * @param {?} cdRef
     */
    constructor(hostElement, cdRef) {
        this.hostElement = hostElement;
        this.cdRef = cdRef;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onResize($event) {
        this.checkSize();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.checkSize();
    }
    /**
     * @return {?}
     */
    checkSize() {
        this.widths[this.objectKey] = window
            .getComputedStyle(this.hostElement.nativeElement, null)
            .getPropertyValue('width');
        this.cdRef.detectChanges();
    }
}
GtColumnWidthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[gtColumnWidth]'
            },] },
];
/** @nocollapse */
GtColumnWidthDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: ChangeDetectorRef, },
];
GtColumnWidthDirective.propDecorators = {
    "objectKey": [{ type: Input },],
    "widths": [{ type: Input },],
    "onResize": [{ type: HostListener, args: ['window:resize', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtCheckboxComponent {
    constructor() {
        this.class = 'd-flex justify-content-end';
        this.changed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get initialValue() {
        return this._initialValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set initialValue(value) {
        this._initialValue = value;
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        this._checked = value;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} checked
     * @return {?}
     */
    toggle(checked) {
        this.changed.emit(this.checked);
    }
}
GtCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'gt-checkbox',
                template: `
    <label class="custom-control custom-checkbox p-0" (click)="$event.stopPropagation()">
      <input #checkbox type="checkbox" class="custom-control-input" [(checked)]="checked" (change)="toggle($event);">
      <span class="custom-control-label"></span>
    </label>
  `,
                styles: []
            },] },
];
/** @nocollapse */
GtCheckboxComponent.ctorParameters = () => [];
GtCheckboxComponent.propDecorators = {
    "class": [{ type: HostBinding, args: ['class',] },],
    "initialValue": [{ type: Input },],
    "checked": [{ type: Input },],
    "changed": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtIsObservablePipe {
    /**
     * @param {?} input
     * @return {?}
     */
    transform(input) {
        return input instanceof Observable;
    }
}
GtIsObservablePipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtIsObservable'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GtIsEditablePipe {
    /**
     * @param {?} property
     * @param {?} row
     * @param {?} refreshPipe
     * @return {?}
     */
    transform(property, row, refreshPipe) {
        if (typeof property === 'function') {
            return property(row);
        }
        else {
            return false;
        }
    }
}
GtIsEditablePipe.decorators = [
    { type: Pipe, args: [{
                name: 'gtIsEditable'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class GenericTableModule {
}
GenericTableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ComponentAnchorDirective,
                    GenericTableComponent,
                    GtPaginationComponent,
                    GtVisiblePipe,
                    GtRenderPipe,
                    DashCasePipe,
                    GtPropertyPipe,
                    GtChunkPipe,
                    GtFilterPipe,
                    GtOrderByPipe,
                    GtExpandingRowComponent,
                    GtCustomComponentFactory,
                    GtSearchPipe,
                    PaginationPipe,
                    GtTableInfoComponent,
                    TableInfoPipe,
                    GtMetaPipe,
                    GtTotalsPipe,
                    GtTotalsPositionPipe,
                    GtRowClassPipe,
                    GtColumnClassPipe,
                    GtHighlightPipe,
                    GtIsObservablePipe,
                    GtIsEditablePipe,
                    GtDropdownComponent,
                    GtColumnWidthDirective,
                    GtDrilldownComponent,
                    GtCheckboxComponent
                ],
                imports: [CommonModule, FormsModule],
                exports: [
                    GenericTableComponent,
                    GtPaginationComponent,
                    GtTableInfoComponent,
                    GtPropertyPipe,
                    GtHighlightPipe,
                    GtExpandingRowComponent,
                    GtDropdownComponent,
                    GtDrilldownComponent,
                    GtCheckboxComponent
                ],
                entryComponents: [GtDrilldownComponent, GtCheckboxComponent],
                providers: [GtMetaPipe, GtHighlightPipe],
                bootstrap: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { GtExpandingRowComponent, GtExpandedRow, GenericTableComponent, GtTableInfoComponent, GtPaginationComponent, GtDrilldownComponent, GenericTableModule, GtCustomComponent, GtHighlightPipe, GtCheckboxComponent as v, GtCustomComponentFactory as c, GtDropdownComponent as t, PaginationPipe as b, TableInfoPipe as a, ComponentAnchorDirective as e, GtColumnWidthDirective as u, DashCasePipe as h, GtChunkPipe as j, GtColumnClassPipe as q, GtFilterPipe as k, GtIsEditablePipe as s, GtIsObservablePipe as r, GtMetaPipe as d, GtOrderByPipe as l, GtPropertyPipe as i, GtRenderPipe as g, GtRowClassPipe as p, GtSearchPipe as m, GtTotalsPositionPipe as o, GtTotalsPipe as n, GtVisiblePipe as f };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1nZW5lcmljLXRhYmxlLWNvcmUuanMubWFwIiwic291cmNlcyI6WyJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9jb21wb25lbnRzL2d0LWV4cGFuZGluZy1yb3cuY29tcG9uZW50LnRzIiwibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvcGlwZXMvZ3QtbWV0YS5waXBlLnRzIiwibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvY29tcG9uZW50cy9nZW5lcmljLXRhYmxlLmNvbXBvbmVudC50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL2NvbXBvbmVudHMvZ3QtdGFibGUtaW5mby5jb21wb25lbnQudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9jb21wb25lbnRzL2d0LXBhZ2luYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvY29tcG9uZW50cy9ndC1kcmlsbGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvcGlwZXMvZ3QtaGlnaGxpZ2h0LnBpcGUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9waXBlcy9ndC1yZW5kZXIucGlwZS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL3BpcGVzL2d0LXZpc2libGUucGlwZS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL3BpcGVzL2Rhc2gtY2FzZS5waXBlLnRzIiwibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvcGlwZXMvZ3QtcHJvcGVydHkucGlwZS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL3BpcGVzL2d0LWNodW5rLnBpcGUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9waXBlcy9ndC1maWx0ZXIucGlwZS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL3BpcGVzL2d0LW9yZGVyLWJ5LnBpcGUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9waXBlcy9ndC1zZWFyY2gucGlwZS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL2RpcmVjdGl2ZXMvY29tcG9uZW50LWFuY2hvci5kaXJlY3RpdmUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9jb21wb25lbnRzL2d0LWN1c3RvbS1jb21wb25lbnQtZmFjdG9yeS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL2NvbXBvbmVudHMvZ3QtZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvcGlwZXMvZ3QtdG90YWxzLnBpcGUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9waXBlcy9ndC10b3RhbHMtcG9zaXRpb24ucGlwZS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL3BpcGVzL2d0LXJvdy1jbGFzcy5waXBlLnRzIiwibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvcGlwZXMvZ3QtY29sdW1uLWNsYXNzLnBpcGUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9kaXJlY3RpdmVzL2d0LWNvbHVtbi13aWR0aC5kaXJlY3RpdmUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9jb21wb25lbnRzL2d0LWNoZWNrYm94L2d0LWNoZWNrYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL3BpcGVzL2d0LWlzLW9ic2VydmFibGUucGlwZS50cyIsIm5nOi8vQGFuZ3VsYXItZ2VuZXJpYy10YWJsZS9jb3JlL3BpcGVzL2d0LWlzLWVkaXRhYmxlLnBpcGUudHMiLCJuZzovL0Bhbmd1bGFyLWdlbmVyaWMtdGFibGUvY29yZS9jb3JlLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3RSb3csIEd0Q29uZmlnRmllbGQsIEd0Q29uZmlnU2V0dGluZywgR3RFdmVudCB9IGZyb20gJy4uJztcblxuZXhwb3J0IGNsYXNzIEd0RXhwYW5kZWRSb3c8UiBleHRlbmRzIEd0Um93PiB7XG5cdHJvdzogUjtcblx0Y29sdW1uV2lkdGg6IE9iamVjdDtcblx0Z3RTZXR0aW5nczogQXJyYXk8R3RDb25maWdTZXR0aW5nPjtcblx0Z3RGaWVsZHM6IEFycmF5PEd0Q29uZmlnRmllbGQ8UiwgYW55Pj47XG5cdGd0T3B0aW9uczogYW55O1xuXHRndEluZm86IGFueTtcblx0ZGF0YTogYW55O1xuXHRyZWRyYXdFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8Uj4oKTtcblx0Z3RFdmVudDogRXZlbnRFbWl0dGVyPEd0RXZlbnQ+O1xuXHR0b2dnbGVSb3dFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8Uj4oKTtcblxuXHRwdWJsaWMgJGhpZGUoKTogdm9pZCB7XG5cdFx0dGhpcy50b2dnbGVSb3dFdmVudC5lbWl0KHRoaXMucm93KTtcblx0fVxuXG5cdHB1YmxpYyAkcmVkcmF3KCRldmVudD86IGFueSk6IHZvaWQge1xuXHRcdHRoaXMucmVkcmF3RXZlbnQuZW1pdCh0aGlzLnJvdyk7XG5cdH1cblx0cHVibGljICRyb3dDbGljayhyb3c6IEd0Um93LCAkZXZlbnQ6IE1vdXNlRXZlbnQpIHtcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3Qtcm93LWNsaWNrZWQnLFxuXHRcdFx0dmFsdWU6IHsgcm93OiByb3csIGV2ZW50OiAkZXZlbnQgfVxuXHRcdH0pO1xuXHR9XG59XG5cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogJ2d0LWV4cGFuZGluZy1yb3cnLFxuXHR0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGd0Q29tcG9uZW50QW5jaG9yXG4gICAgICAgICAgICAgW2N0b3JdPVwidHlwZVwiIChpbnN0YW5jZSk9XCJuZXdJbnN0YW5jZSgkZXZlbnQpXCI+PC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBHdEV4cGFuZGluZ1Jvd0NvbXBvbmVudDxcblx0UiBleHRlbmRzIEd0Um93LFxuXHRDIGV4dGVuZHMgR3RFeHBhbmRlZFJvdzxSPlxuPiB7XG5cdEBJbnB1dCgpIHR5cGU6IFR5cGU8Qz47XG5cdEBJbnB1dCgpIHJvdzogUjtcblx0QElucHV0KCkgY29sdW1uV2lkdGg6IE9iamVjdDtcblx0QElucHV0KCkgZ3RTZXR0aW5nczogQXJyYXk8R3RDb25maWdTZXR0aW5nPjtcblx0QElucHV0KCkgZ3RGaWVsZHM6IEFycmF5PEd0Q29uZmlnRmllbGQ8UiwgYW55Pj47XG5cdEBJbnB1dCgpIGd0T3B0aW9uczogYW55O1xuXHRASW5wdXQoKSBndEluZm86IGFueTtcblx0QElucHV0KCkgZGF0YTogYW55O1xuXG5cdEBPdXRwdXQoKSByZWRyYXdFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8Uj4oKTtcblx0QE91dHB1dCgpIHRvZ2dsZVJvd0V2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxSPigpO1xuXHRASW5wdXQoKSBndEV2ZW50OiBhbnk7XG5cblx0bmV3SW5zdGFuY2UoaW5zdGFuY2U6IEMpOiB2b2lkIHtcblx0XHRpbnN0YW5jZS5yb3cgPSB0aGlzLnJvdztcblx0XHRpbnN0YW5jZS5jb2x1bW5XaWR0aCA9IHRoaXMuY29sdW1uV2lkdGg7XG5cdFx0aW5zdGFuY2UuZ3RTZXR0aW5ncyA9IHRoaXMuZ3RTZXR0aW5ncztcblx0XHRpbnN0YW5jZS5ndEZpZWxkcyA9IHRoaXMuZ3RGaWVsZHM7XG5cdFx0aW5zdGFuY2UuZ3RPcHRpb25zID0gdGhpcy5ndE9wdGlvbnM7XG5cdFx0aW5zdGFuY2UuZ3RJbmZvID0gdGhpcy5ndEluZm87XG5cdFx0aW5zdGFuY2UuZGF0YSA9XG5cdFx0XHR0eXBlb2YgdGhpcy5kYXRhID09PSAnZnVuY3Rpb24nID8gdGhpcy5kYXRhKHRoaXMucm93KSA6IHRoaXMuZGF0YTtcblx0XHRpbnN0YW5jZS5yZWRyYXdFdmVudC5zdWJzY3JpYmUodGhpcy5yZWRyYXdFdmVudCk7XG5cdFx0aW5zdGFuY2UudG9nZ2xlUm93RXZlbnQuc3Vic2NyaWJlKHRoaXMudG9nZ2xlUm93RXZlbnQpO1xuXHRcdGluc3RhbmNlLmd0RXZlbnQgPSB0aGlzLmd0RXZlbnQ7XG5cdH1cbn1cbiIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEd0Um93IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1yb3cnO1xuaW1wb3J0IHsgR3RSb3dNZXRhIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1yb3ctbWV0YSc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0TWV0YSdcbn0pXG5leHBvcnQgY2xhc3MgR3RNZXRhUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHR0cmFuc2Zvcm0oXG5cdFx0YWxsUm93czogQXJyYXk8R3RSb3c+LFxuXHRcdHJvd0luZGV4Pzogc3RyaW5nLFxuXHRcdHBhZ2U/OiBudW1iZXIsXG5cdFx0cmVjb3JkTGVuZ3RoPzogbnVtYmVyXG5cdCk6IEFycmF5PEd0Um93PiB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhbGxSb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoIWFsbFJvd3NbaV0uJCRndFJvd0lkKSB7XG5cdFx0XHRcdGFsbFJvd3NbaV0uJCRndFJvd0lkID0gcm93SW5kZXhcblx0XHRcdFx0XHQ/IGFsbFJvd3NbaV1bcm93SW5kZXhdXG5cdFx0XHRcdFx0OiBwYWdlXG5cdFx0XHRcdFx0XHQ/IHBhZ2UgKiByZWNvcmRMZW5ndGggK1xuXHRcdFx0XHRcdFx0ICBpICtcblx0XHRcdFx0XHRcdCAgJ18nICtcblx0XHRcdFx0XHRcdCAgTWF0aC5yYW5kb20oKVxuXHRcdFx0XHRcdFx0XHRcdC50b1N0cmluZygzNilcblx0XHRcdFx0XHRcdFx0XHQuc3Vic3RyKDIsIDE2KVxuXHRcdFx0XHRcdFx0OiBpICtcblx0XHRcdFx0XHRcdCAgJ18nICtcblx0XHRcdFx0XHRcdCAgTWF0aC5yYW5kb20oKVxuXHRcdFx0XHRcdFx0XHRcdC50b1N0cmluZygzNilcblx0XHRcdFx0XHRcdFx0XHQuc3Vic3RyKDIsIDE2KTtcblx0XHRcdH1cblx0XHRcdGlmICghYWxsUm93c1tpXS4kJGd0SW5pdGlhbFJvd0luZGV4KSB7XG5cdFx0XHRcdGFsbFJvd3NbaV0uJCRndEluaXRpYWxSb3dJbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhbGxSb3dzO1xuXHR9XG59XG4iLCJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdE9uSW5pdCxcblx0T25DaGFuZ2VzLFxuXHRPdXRwdXQsXG5cdElucHV0LFxuXHRFdmVudEVtaXR0ZXIsXG5cdFR5cGUsXG5cdFNpbXBsZUNoYW5nZXMsXG5cdFJlbmRlcmVyMixcblx0T25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcblx0R3RDb25maWcsXG5cdEd0Q29uZmlnRmllbGQsXG5cdEd0Q29uZmlnU2V0dGluZyxcblx0R3RUZXh0cyxcblx0R3RJbmZvcm1hdGlvbixcblx0R3RFeHBhbmRlZFJvdyxcblx0R3RSb3csXG5cdEd0T3B0aW9ucyxcblx0R3RSb3dNZXRhLFxuXHRHdFJlbmRlckZpZWxkLFxuXHRHdEV2ZW50XG59IGZyb20gJy4uJztcbmltcG9ydCB7IEd0TWV0YVBpcGUgfSBmcm9tICcuLi9waXBlcy9ndC1tZXRhLnBpcGUnO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdnZW5lcmljLXRhYmxlJyxcblx0dGVtcGxhdGU6IGA8dGFibGUgY2xhc3M9XCJ0YWJsZVwiIG5nQ2xhc3M9XCJ7e2d0Q2xhc3Nlc319IHt7Z3RPcHRpb25zLnN0YWNrID8gJ3RhYmxlLXN0YWNrZWQnOicnfX1cIlxuICAgICAgICpuZ0lmPVwiZ3RGaWVsZHMgJiYgZ3RTZXR0aW5ncyAmJiAoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZSkubGVuZ3RoID4gMFwiPlxuICA8dGhlYWQ+XG4gIDx0cj5cbiAgICA8dGggY2xhc3M9XCJndC1zb3J0LWxhYmVsXCIgKm5nSWY9XCJndE9wdGlvbnMuc3RhY2tcIj57e2d0VGV4dHMuc29ydExhYmVsfX08L3RoPlxuICAgIDx0aCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZVwiXG4gICAgICAgIG5nQ2xhc3M9XCJ7e2NvbHVtbi5vYmplY3RLZXkgKyctY29sdW1uJyB8IGRhc2hDYXNlfX0ge3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY2xhc3NOYW1lcyd9fSB7e2NvbHVtbi5zb3J0RW5hYmxlZCA/ICdzb3J0LScrY29sdW1uLnNvcnQ6Jyd9fSB7e2NvbHVtbi5zb3J0RW5hYmxlZCAmJiBjb2x1bW4uc29ydE9yZGVyID49IDAgID8gJ3NvcnQtb3JkZXItJytjb2x1bW4uc29ydE9yZGVyOicnfX0ge3sgZ3RGaWVsZHMgfCBndENvbHVtbkNsYXNzOmNvbHVtbiB9fVwiXG4gICAgICAgIChjbGljayk9XCJjb2x1bW4uc29ydEVuYWJsZWQgPyBndFNvcnQoY29sdW1uLm9iamVjdEtleSwkZXZlbnQpOicnO1wiPlxuICAgICAgPHNwYW4gKm5nSWY9XCIhKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKVwiPnt7Z3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnfX08L3NwYW4+XG4gICAgICA8Z3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5ICpuZ0lmPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0eXBlXT1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaGVhZGVyJyk/LnR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaW5qZWN0b3JdPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKT8uaW5qZWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OiduYW1lJ1wiPjwvZ3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5PlxuICAgICAgPGd0LWNoZWNrYm94ICpuZ0lmPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5Oidjb2x1bW5Db21wb25lbnQnKT8udHlwZSA9PT0gJ2NoZWNrYm94J1wiIFtjaGVja2VkXT1cIihndE9wdGlvbnMubGF6eUxvYWQgPyBsYXp5QWxsU2VsZWN0ZWQ6c2VsZWN0ZWRSb3dzLmxlbmd0aCA9PT0gZ3REYXRhLmxlbmd0aClcIiAoY2hhbmdlZCk9XCJ0b2dnbGVBbGxSb3dzKClcIj48L2d0LWNoZWNrYm94PlxuICAgIDwvdGg+XG4gIDwvdHI+XG4gIDwvdGhlYWQ+XG4gIDxuZy10ZW1wbGF0ZVxuICAgIFtuZ0lmXT1cImd0VG90YWxzICYmIChndE9wdGlvbnMubGF6eUxvYWQgPT09IGZhbHNlID8gKGd0RGF0YSB8IGd0RmlsdGVyOmd0SW5mby5maWx0ZXI6Z3RJbmZvOnJlZnJlc2hGaWx0ZXI6Z3REYXRhLmxlbmd0aCB8IGd0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtczpndEluZm86Z3RTZXR0aW5nczpndEZpZWxkczpndERhdGEubGVuZ3RoKS5sZW5ndGggPiAwIDogZ3REYXRhLmxlbmd0aCA+IDApXCI+XG4gICAgPHRoZWFkIGNsYXNzPVwiZ3QtdG90YWxzXCI+XG4gICAgPHRyICpuZ0Zvcj1cImxldCB0b3RhbCBvZiBndFRvdGFscyB8IGd0VG90YWxzUG9zaXRpb25cIj5cbiAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZTtsZXQgaSA9IGluZGV4O1wiXG4gICAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy10b3RhbHMtY29sdW1uJyB8IGRhc2hDYXNlfX0ge3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY2xhc3NOYW1lcyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6Y29sdW1uIH19XCI+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaSA9PT0gMFwiIGNsYXNzPVwiZmxvYXQtbGVmdFwiPnt7dG90YWwubmFtZX19PC9zcGFuPjxzcGFuXG4gICAgICAgIFtpbm5lckhUTUxdPVwidG90YWwuZmllbGRzW2NvbHVtbi5vYmplY3RLZXldIHwgZ3RUb3RhbHM6KHRvdGFsLnVwZGF0ZSA9PT0gZmFsc2UgfHwgZ3RPcHRpb25zLmxhenlMb2FkID09PSB0cnVlKSA/IGd0RGF0YTooZ3REYXRhIHwgZ3RGaWx0ZXI6Z3RJbmZvLmZpbHRlcjpndEluZm86cmVmcmVzaEZpbHRlcjpndERhdGEubGVuZ3RoIHwgZ3RTZWFyY2g6Z3RJbmZvLnNlYXJjaFRlcm1zOmd0SW5mbzpndFNldHRpbmdzOmd0RmllbGRzOmd0RGF0YS5sZW5ndGgpOmNvbHVtbi5vYmplY3RLZXk6cmVmcmVzaFRvdGFsc1wiPjwvc3Bhbj5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgICA8L3RoZWFkPlxuICAgIDx0Zm9vdCBjbGFzcz1cImd0LXRvdGFsc1wiPlxuICAgIDx0ciAqbmdGb3I9XCJsZXQgdG90YWwgb2YgZ3RUb3RhbHMgfCBndFRvdGFsc1Bvc2l0aW9uOidmb290ZXInXCI+XG4gICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBndFNldHRpbmdzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3M6cmVmcmVzaFBpcGU7bGV0IGkgPSBpbmRleDtcIlxuICAgICAgICAgIG5nQ2xhc3M9XCJ7e2NvbHVtbi5vYmplY3RLZXkgKyctdG90YWxzLWNvbHVtbicgfCBkYXNoQ2FzZX19IHt7Z3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2NsYXNzTmFtZXMnfX0ge3sgZ3RGaWVsZHMgfCBndENvbHVtbkNsYXNzOmNvbHVtbiB9fVwiPlxuICAgICAgICA8c3BhbiAqbmdJZj1cImkgPT09IDBcIiBjbGFzcz1cImZsb2F0LWxlZnRcIj57e3RvdGFsLm5hbWV9fTwvc3Bhbj48c3BhblxuICAgICAgICBbaW5uZXJIVE1MXT1cInRvdGFsLmZpZWxkc1tjb2x1bW4ub2JqZWN0S2V5XSB8IGd0VG90YWxzOih0b3RhbC51cGRhdGUgPT09IGZhbHNlIHx8IGd0T3B0aW9ucy5sYXp5TG9hZCA9PT0gdHJ1ZSkgPyBndERhdGE6KGd0RGF0YSB8IGd0RmlsdGVyOmd0SW5mby5maWx0ZXI6Z3RJbmZvOnJlZnJlc2hGaWx0ZXI6Z3REYXRhLmxlbmd0aCB8IGd0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtczpndEluZm86Z3RTZXR0aW5nczpndEZpZWxkczpndERhdGEubGVuZ3RoKTpjb2x1bW4ub2JqZWN0S2V5OnJlZnJlc2hUb3RhbHNcIj48L3NwYW4+XG4gICAgICA8L3RkPlxuICAgIDwvdHI+XG4gICAgPC90Zm9vdD5cbiAgPC9uZy10ZW1wbGF0ZT5cbiAgPHRib2R5ICpuZ0lmPVwiZ3REYXRhICYmIGd0SW5mb1wiPlxuICA8bmctdGVtcGxhdGUgY2xhc3M9XCJ0YWJsZS1yb3dzXCIgbmdGb3IgbGV0LXJvdyBsZXQtbGFzdD1cImxhc3RcIiBbbmdGb3JUcmFja0J5XT1cInRyYWNrQnlGblwiXG4gICAgICAgICAgICAgICBbbmdGb3JPZl09XCJndE9wdGlvbnMubGF6eUxvYWQgJiYgZ3RJbmZvID8gKGd0RGF0YVtndEluZm8ucGFnZUN1cnJlbnQtMV0pIDogKGd0RGF0YSB8IGd0RmlsdGVyOmd0SW5mby5maWx0ZXI6Z3RJbmZvOnJlZnJlc2hGaWx0ZXI6Z3REYXRhLmxlbmd0aCB8IGd0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtczpndEluZm86Z3RTZXR0aW5nczpndEZpZWxkczpndERhdGEubGVuZ3RoIHwgZ3RPcmRlckJ5OnNvcnRPcmRlcjpndEZpZWxkczpyZWZyZXNoU29ydGluZzpndERhdGEubGVuZ3RoIHwgZ3RDaHVuazpndEluZm86Z3RJbmZvLnJlY29yZExlbmd0aDpndEluZm8ucGFnZUN1cnJlbnQ6cmVmcmVzaFBhZ2VBcnJheTpndERhdGEubGVuZ3RoOmd0RXZlbnQ6ZGF0YSB8IGd0Um93Q2xhc3M6Z3RGaWVsZHMpXCI+XG4gICAgPHRyIFtuZ0NsYXNzXT1cInsncm93LXNlbGVjdGVkJzptZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNTZWxlY3RlZCwgJ3Jvdy1vcGVuJzptZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNPcGVuLCAncm93LWxvYWRpbmcnOmxvYWRpbmcsICdyb3ctZXhwYW5kYWJsZSc6Z3RSb3dDb21wb25lbnR9XCJcbiAgICAgICAgY2xhc3M9XCJ7e3Jvdy4kJGd0Um93Q2xhc3N9fVwiXG4gICAgICAgIChjbGljayk9XCJndE9wdGlvbnMucm93U2VsZWN0aW9uID8gdG9nZ2xlU2VsZWN0KHJvdyk6cm93Q2xpY2socm93LCAkZXZlbnQpXCI+XG4gICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiByb3cgfCBndFJlbmRlcjpndFNldHRpbmdzOmd0RmllbGRzOnJlZnJlc2hQaXBlOmxvYWRpbmc6Z3RPcHRpb25zLmhpZ2hsaWdodFNlYXJjaDpndEluZm8uc2VhcmNoVGVybXM7dHJhY2tCeTp0cmFja0J5Q29sdW1uRm5cIlxuICAgICAgICAgIG5nQ2xhc3M9XCJ7e2NvbHVtbi5vYmplY3RLZXkgKyctY29sdW1uJyB8IGRhc2hDYXNlfX0ge3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY2xhc3NOYW1lcyd9fSB7eyhndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpID8gJ2d0LWlubGluZS1lZGl0JzonJ319IHt7Y29sdW1uLmVkaXRlZCA/ICdndC1lZGl0ZWQnOicnfX0ge3sgZ3RGaWVsZHMgfCBndENvbHVtbkNsYXNzOmNvbHVtbjpyb3cgfX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ3Qtcm93LWxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZ3RPcHRpb25zLnN0YWNrXCI+e3soZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgPyAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgOiAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnKX19PC9zcGFuPlxuICAgICAgICA8Z3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5ICpuZ0lmPVwiY29sdW1uLmNvbHVtbkNvbXBvbmVudCAmJiBjb2x1bW4uY29sdW1uQ29tcG9uZW50LnR5cGUgIT09ICdjaGVja2JveCdcIiBjbGFzcz1cImd0LXJvdy1jb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50LnR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbmplY3Rvcl09XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50LmluamVjdG9yXCIgW3Jvd109XCJyb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCIgKHJlZHJhd0V2ZW50KT1cInJlZHJhdygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VhcmNoVGVybXNdPVwiZ3RJbmZvLnNlYXJjaFRlcm1zXCIgIChzZWFyY2hFdmVudCk9XCJyZWRyYXcoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNvbHVtbi5jbGljayA/IGNvbHVtbi5jbGljayhyb3csY29sdW1uLCRldmVudCk6Jyc7Y29sdW1uLmV4cGFuZCA/IHRvZ2dsZUNvbGxhcHNlKHJvdywgY29sdW1uLmV4cGFuZCk6JydcIj48L2d0LWN1c3RvbS1jb21wb25lbnQtZmFjdG9yeT5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhY29sdW1uLmNvbHVtbkNvbXBvbmVudCAmJiAoIShndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpIHx8ICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc09ic2VydmFibGUpICYmICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSB8IGFzeW5jKSB8fCAoISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc09ic2VydmFibGUpICYmICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSB8IGd0SXNFZGl0YWJsZTpyb3c6cmVmcmVzaFBpcGUpKSlcIlxuICAgICAgICAgICAgICBjbGFzcz1cImd0LXJvdy1jb250ZW50XCIgW2lubmVySFRNTF09XCJjb2x1bW4ucmVuZGVyVmFsdWVcIlxuICAgICAgICAgICAgICAoY2xpY2spPVwiY29sdW1uLmNsaWNrID8gY29sdW1uLmNsaWNrKHJvdyxjb2x1bW4sJGV2ZW50KTonJztjb2x1bW4uZXhwYW5kID8gdG9nZ2xlQ29sbGFwc2Uocm93LCBjb2x1bW4uZXhwYW5kKTonJ1wiPjwvc3Bhbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgW25nSWZdPVwiIWNvbHVtbi5jb2x1bW5Db21wb25lbnQgJiYgKCgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc09ic2VydmFibGUpICYmICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgYXN5bmMpIHx8ICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc0VkaXRhYmxlOnJvdzpyZWZyZXNoUGlwZSkpXCI+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIihbdHJ1ZSwnZW1haWwnLCdudW1iZXInLCdwYXNzd29yZCcsICd0ZXh0J10uaW5kZXhPZigoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlKSAhPT0gLTEpIHx8ICEoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlXCI+XG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJpbmxpbmUtZWRpdFwiIFthdHRyLnR5cGVdPVwiIShndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgPyAndGV4dCcgOiAhKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgfCBndElzT2JzZXJ2YWJsZSkgPyAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlOihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgfCBhc3luY1wiIFsobmdNb2RlbCldPVwiY29sdW1uLnJlbmRlclZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAoa2V5dXApPVwiZ3RVcGRhdGVDb2x1bW4oJGV2ZW50LHJvdywgY29sdW1uKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJndC1pbmxpbmUtZWRpdC1ub3RpY2VcIj57e2d0VGV4dHMuaW5saW5lRWRpdEVkaXRlZH19PC9zcGFuPlxuICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgPGd0LWRyb3Bkb3duXG4gICAgICAgICAgICAqbmdJZj1cIigoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSkgJiYgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUpLmxlbmd0aCA+IDApIHx8ICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlIHwgZ3RJc09ic2VydmFibGUpXCJcbiAgICAgICAgICAgIFtvcHRpb25zXT1cIiEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSB8IGd0SXNPYnNlcnZhYmxlKSA/IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgOiAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlIHwgYXN5bmNcIlxuICAgICAgICAgICAgW2lkXT1cIidfJyArIHJvdy4kJGd0Um93SWQgKyAnXycgKyBjb2x1bW4ub2JqZWN0S2V5XCJcbiAgICAgICAgICAgIFsoc2VsZWN0ZWQpXT1cImNvbHVtbi5yZW5kZXJWYWx1ZVwiIChzZWxlY3RlZENoYW5nZSk9XCJndERyb3Bkb3duU2VsZWN0KHJvdywgY29sdW1uKVwiPkFkZFxuICAgICAgICAgICAgaW5saW5lIGVkaXRpbmcgbW9kdWxlXG4gICAgICAgICAgPC9ndC1kcm9wZG93bj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSkgXCI+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICBbbmdJZl09XCJbdHJ1ZSwnZW1haWwnLCdudW1iZXInLCdwYXNzd29yZCddLmluZGV4T2YoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKSAhPT0gLTFcIj5cbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlubGluZS1lZGl0XCIgW2F0dHIudHlwZV09XCIoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKSA9PT0gdHJ1ZSA/ICd0ZXh0JzooZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKVwiIFsobmdNb2RlbCldPVwiY29sdW1uLnJlbmRlclZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAoa2V5dXApPVwiZ3RVcGRhdGVDb2x1bW4oJGV2ZW50LHJvdywgY29sdW1uKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJndC1pbmxpbmUtZWRpdC1ub3RpY2VcIj57e2d0VGV4dHMuaW5saW5lRWRpdEVkaXRlZH19PC9zcGFuPlxuICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgPGd0LWRyb3Bkb3duXG4gICAgICAgICAgICAqbmdJZj1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpICYmIFt0cnVlLCdlbWFpbCcsJ251bWJlcicsJ3Bhc3N3b3JkJ10uaW5kZXhPZihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpID09PSAtMVwiXG4gICAgICAgICAgICBbb3B0aW9uc109XCJndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCdcIlxuICAgICAgICAgICAgW2lkXT1cIidfJyArIHJvdy4kJGd0Um93SWQgKyAnXycgKyBjb2x1bW4ub2JqZWN0S2V5XCJcbiAgICAgICAgICAgIFsoc2VsZWN0ZWQpXT1cImNvbHVtbi5yZW5kZXJWYWx1ZVwiIChzZWxlY3RlZENoYW5nZSk9XCJndERyb3Bkb3duU2VsZWN0KHJvdywgY29sdW1uKVwiPkFkZFxuICAgICAgICAgICAgaW5saW5lIGVkaXRpbmcgbW9kdWxlXG4gICAgICAgICAgPC9ndC1kcm9wZG93bj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPGd0LWNoZWNrYm94ICpuZ0lmPVwiY29sdW1uLmNvbHVtbkNvbXBvbmVudCAmJiBjb2x1bW4uY29sdW1uQ29tcG9uZW50LnR5cGUgPT09ICdjaGVja2JveCdcIiBbY2hlY2tlZF09XCJtZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNTZWxlY3RlZFwiIChjaGFuZ2VkKT1cInRvZ2dsZVNlbGVjdChyb3cpXCI+PC9ndC1jaGVja2JveD5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgICA8dHIgY2xhc3M9XCJyb3ctZXhwYW5kZWRcIiAqbmdJZj1cIm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdPy5pc09wZW5cIj5cbiAgICAgIDx0ZCBbYXR0ci5jb2xzcGFuXT1cIihndEZpZWxkcyB8IGd0VmlzaWJsZTpndFNldHRpbmdzOnJlZnJlc2hQaXBlKS5sZW5ndGhcIj5cbiAgICAgICAgPGd0LWV4cGFuZGluZy1yb3cgW3Jvd109XCJyb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJleHBhbmRlZFJvdy5jb21wb25lbnQgPyBleHBhbmRlZFJvdy5jb21wb25lbnQ6Z3RSb3dDb21wb25lbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uV2lkdGhdPVwiY29sdW1uV2lkdGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RGaWVsZHNdPVwiZ3RGaWVsZHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RPcHRpb25zXT1cImd0T3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndEV2ZW50XT1cImd0RXZlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RJbmZvXT1cImd0SW5mb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndFNldHRpbmdzXT1cImd0U2V0dGluZ3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZGF0YV09XCJleHBhbmRlZFJvdy5kYXRhID8gZXhwYW5kZWRSb3cuZGF0YTpyb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVkcmF3RXZlbnQpPVwicmVkcmF3KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAodG9nZ2xlUm93RXZlbnQpPVwidG9nZ2xlQ29sbGFwc2UoJGV2ZW50KVwiPjwvZ3QtZXhwYW5kaW5nLXJvdz5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgICA8dHIgKm5nSWY9XCJndE9wdGlvbnMucmVwb3J0Q29sdW1uV2lkdGggJiYgbGFzdFwiPlxuICAgICAgPHRkIHN0eWxlPVwicGFkZGluZzogMDsgYm9yZGVyOm5vbmU7XCJcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZVwiIGd0Q29sdW1uV2lkdGhcbiAgICAgICAgICBbb2JqZWN0S2V5XT1cImNvbHVtbi5vYmplY3RLZXlcIiBbd2lkdGhzXT1cImNvbHVtbldpZHRoXCI+PC90ZD5cbiAgICA8L3RyPlxuICA8L25nLXRlbXBsYXRlPlxuICA8dHIgKm5nSWY9XCJndEluZm8ucGFnZVRvdGFsID09PSAwICYmIChndEluZm8uc2VhcmNoVGVybXMgfHwgZ3RJbmZvLmZpbHRlcikgJiYgIWxvYWRpbmdcIj5cbiAgICA8dGQgY2xhc3M9XCJndC1uby1tYXRjaGluZy1yZXN1bHRzXCIgW2F0dHIuY29sc3Bhbl09XCIoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5ncykubGVuZ3RoXCI+XG4gICAgICB7e2d0VGV4dHMubm9NYXRjaGluZ0RhdGF9fVxuICAgIDwvdGQ+XG4gIDwvdHI+XG4gIDx0ciAqbmdJZj1cImd0SW5mby5wYWdlVG90YWwgPT09IDAgJiYgIShndEluZm8uc2VhcmNoVGVybXMgfHwgZ3RJbmZvLmZpbHRlcikgJiYgIWxvYWRpbmdcIj5cbiAgICA8dGQgY2xhc3M9XCJndC1uby1yZXN1bHRzXCIgW2F0dHIuY29sc3Bhbl09XCIoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5ncykubGVuZ3RoXCI+e3tndFRleHRzLm5vRGF0YX19XG4gICAgPC90ZD5cbiAgPC90cj5cbiAgPHRyICpuZ0lmPVwiZ3RJbmZvLnBhZ2VUb3RhbCA9PT0gMCAmJiBsb2FkaW5nXCI+XG4gICAgPHRkIGNsYXNzPVwiZ3QtbG9hZGluZy1kYXRhXCIgW2F0dHIuY29sc3Bhbl09XCIoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5ncykubGVuZ3RoXCI+e3tndFRleHRzLmxvYWRpbmd9fTwvdGQ+XG4gIDwvdHI+XG4gIDwvdGJvZHk+XG48L3RhYmxlPlxuPHRhYmxlIGNsYXNzPVwidGFibGVcIiBuZ0NsYXNzPVwie3tndENsYXNzZXN9fSB7e2d0T3B0aW9ucy5zdGFjayA/ICd0YWJsZS1zdGFja2VkJzonJ319XCJcbiAgICAgICAqbmdJZj1cImd0RmllbGRzICYmIGd0U2V0dGluZ3MgJiYgKGd0RmllbGRzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3M6cmVmcmVzaFBpcGUpLmxlbmd0aCA9PT0gMFwiPlxuICA8dGhlYWQ+XG4gIDx0cj5cbiAgICA8dGggY2xhc3M9XCJndC1uby12aXNpYmxlLWNvbHVtbnNcIj57e2d0VGV4dHMubm9WaXNpYmxlQ29sdW1uc0hlYWRpbmd9fTwvdGg+XG4gIDwvdHI+XG4gIDwvdGhlYWQ+XG4gIDx0Ym9keT5cbiAgPHRyPlxuICAgIDx0ZCBjbGFzcz1cImd0LW5vLXZpc2libGUtY29sdW1uc1wiPnt7Z3RUZXh0cy5ub1Zpc2libGVDb2x1bW5zfX08L3RkPlxuICA8L3RyPlxuICA8L3Rib2R5PlxuPC90YWJsZT5cbjx0YWJsZSBjbGFzcz1cInRhYmxlXCIgbmdDbGFzcz1cInt7Z3RDbGFzc2VzfX0ge3tndE9wdGlvbnMuc3RhY2sgPyAndGFibGUtc3RhY2tlZCc6Jyd9fVwiXG4gICAgICAgKm5nSWY9XCIhZ3RGaWVsZHMgfHwgIWd0U2V0dGluZ3NcIj5cbiAgPHRoZWFkPlxuICA8dHI+XG4gICAgPHRoIGNsYXNzPVwiZ3QtbG9hZGluZy1jb25maWdcIj4mbmJzcDs8L3RoPlxuICA8L3RyPlxuICA8L3RoZWFkPlxuICA8dGJvZHk+XG4gIDx0cj5cbiAgICA8dGQgY2xhc3M9XCJndC1sb2FkaW5nLWNvbmZpZ1wiPiZuYnNwOzwvdGQ+XG4gIDwvdHI+XG4gIDwvdGJvZHk+XG48L3RhYmxlPlxuYFxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljVGFibGVDb21wb25lbnQ8UiBleHRlbmRzIEd0Um93LCBDIGV4dGVuZHMgR3RFeHBhbmRlZFJvdzxSPj5cblx0aW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblx0Z2V0IGd0Um93Q29tcG9uZW50KCk6IFR5cGU8Qz4ge1xuXHRcdHJldHVybiB0aGlzLl9ndFJvd0NvbXBvbmVudDtcblx0fVxuXG5cdGdldCBoYXNFZGl0cygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5lZGl0ZWRSb3dzKS5sZW5ndGggPiAwO1xuXHR9XG5cblx0Z2V0IGd0T3B0aW9ucygpOiBHdE9wdGlvbnMge1xuXHRcdHJldHVybiB0aGlzLl9ndE9wdGlvbnM7XG5cdH1cblxuXHRnZXQgZ3RUb3RhbHMoKTogYW55IHtcblx0XHRyZXR1cm4gdGhpcy5fZ3RUb3RhbHM7XG5cdH1cblxuXHRnZXQgZ3RGaWVsZHMoKTogR3RDb25maWdGaWVsZDxSLCBhbnk+W10ge1xuXHRcdHJldHVybiB0aGlzLl9ndEZpZWxkcztcblx0fVxuXG5cdGdldCBndFNldHRpbmdzKCk6IEd0Q29uZmlnU2V0dGluZ1tdIHtcblx0XHRyZXR1cm4gdGhpcy5fZ3RTZXR0aW5ncztcblx0fVxuXG5cdGdldCBndERhdGEoKTogQXJyYXk8YW55PiB7XG5cdFx0cmV0dXJuIHRoaXMuX2d0RGF0YTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBndE9wdGlvbnModmFsdWU6IEd0T3B0aW9ucykge1xuXHRcdHRoaXMuX2d0T3B0aW9ucyA9IHZhbHVlO1xuXG5cdFx0Ly8gaWYgbnVtYmVyIG9mIHJvd3MgaXMgcGFzc2VkIGFuZCBpZiBudW1iZXIgb2Ygcm93cyBkaWZmZXJzIGZyb20gY3VycmVudCByZWNvcmQgbGVuZ3RoLi4uXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzICYmXG5cdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGggIT09IHRoaXMuZ3RPcHRpb25zLm51bWJlck9mUm93c1xuXHRcdCkge1xuXHRcdFx0Ly8gLi4udXBkYXRlIHJlY29yZCBsZW5ndGggYW5kIHJlZHJhdyB0YWJsZVxuXHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoID0gdGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzO1xuXHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHR9XG5cblx0XHQvLyAuLi5leHRlbmQgZ3RPcHRpb25zIGRlZmF1bHQgdmFsdWVzIHdpdGggdmFsdWVzIHBhc3NlZCBpbnRvIGNvbXBvbmVudFxuXHRcdHRoaXMuX2d0T3B0aW9ucyA9IDxHdE9wdGlvbnM+dGhpcy5leHRlbmQoXG5cdFx0XHR0aGlzLmd0RGVmYXVsdE9wdGlvbnMsXG5cdFx0XHR0aGlzLl9ndE9wdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGd0VG90YWxzKHZhbHVlOiBhbnkpIHtcblx0XHR0aGlzLl9ndFRvdGFscyA9IHZhbHVlO1xuXHR9XG5cdEBJbnB1dCgpXG5cdHNldCBndEZpZWxkcyh2YWx1ZTogR3RDb25maWdGaWVsZDxSLCBhbnk+W10pIHtcblx0XHR0aGlzLl9ndEZpZWxkcyA9IHZhbHVlO1xuXHRcdGNvbnN0IENPTFVNTlNfV0lUSF9DTEFTU19OQU1FUyA9IHRoaXMuX2d0RmllbGRzXG5cdFx0XHQubWFwKGNvbHVtbiA9PiBjb2x1bW4pXG5cdFx0XHQuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uY2xhc3NOYW1lcyk7XG5cdFx0Ly8gVE9ETzogcmVtb3ZlIGRlcHJlY2F0ZWQgd2FybmluZyB3aGVuIHNldHRpbmcgaGFzIGJlZW4gcmVtb3ZlZFxuXHRcdGlmIChDT0xVTU5TX1dJVEhfQ0xBU1NfTkFNRVMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHQnRmllbGQgc2V0dGluZyBcImNsYXNzTmFtZXNcIiBoYXZlIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBmb3IgXCJjb2x1bW5DbGFzc1wiIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZSwgcGxlYXNlIHVwZGF0ZSBmaWVsZCBzZXR0aW5ncyBmb3IgY29sdW1uIHdpdGggb2JqZWN0IGtleTogJyArXG5cdFx0XHRcdFx0Q09MVU1OU19XSVRIX0NMQVNTX05BTUVTWzBdLm9iamVjdEtleVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0QElucHV0KClcblx0c2V0IGd0U2V0dGluZ3ModmFsdWU6IEd0Q29uZmlnU2V0dGluZ1tdKSB7XG5cdFx0dGhpcy5fZ3RTZXR0aW5ncyA9IHZhbHVlO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGN1cnJlbnQgc2V0dGluZ3Ncblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdC8vIHNldCBzb3J0IGVuYWJsZWQvZGlzYWJsZWQgc2V0dGluZ1xuXHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0RW5hYmxlZCA9XG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydEVuYWJsZWQgIT09IGZhbHNlXG5cdFx0XHRcdFx0PyAodGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0RW5hYmxlZCA9ICEoXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQuaW5kZXhPZignZGlzYWJsZScpICE9PSAtMVxuXHRcdFx0XHRcdCAgKSlcblx0XHRcdFx0XHQ6IGZhbHNlO1xuXG5cdFx0XHQvLyBjaGVjayBpZiBzb3J0aW5nIGlzIHVuZGVmaW5lZC4uLlxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIC4uLmlzIHNvLCBzZXQgc29ydGluZyBwcm9wZXJ0eSB0byBlbmFibGVcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2VuYWJsZSc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGlmIGNvbHVtbiBvcmRlciBpcyB1bmRlZmluZWQuLi5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIHRoaXMuX2d0U2V0dGluZ3NbaV0uY29sdW1uT3JkZXIgPT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uZW5hYmxlZCAhPT0gZmFsc2Vcblx0XHRcdCkge1xuXHRcdFx0XHQvLyAuLi5pcyBzbywgc2V0IHNvcnRpbmcgcHJvcGVydHkgdG8gZW5hYmxlXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uY29sdW1uT3JkZXIgPSB0aGlzLl9ndFNldHRpbmdzW2kgLSAxXVxuXHRcdFx0XHRcdD8gdGhpcy5fZ3RTZXR0aW5nc1tpIC0gMV0uY29sdW1uT3JkZXIgKyAxXG5cdFx0XHRcdFx0OiAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpZiBjb2x1bW4gbG9jayBzZXR0aW5ncyBhcmUgdW5kZWZpbmVkLi4uXG5cdFx0XHRpZiAodHlwZW9mIHRoaXMuX2d0U2V0dGluZ3NbaV0ubG9ja1NldHRpbmdzID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHQvLyAuLi5pZiBzbywgc2V0IGxvY2sgc2V0dGluZ3MgdG8gZmFsc2UgdW5sZXNzIGZpZWxkIGlzIGRpc2FibGVkIChlbmFibGUgPT09IGZhbHNlKVxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLmxvY2tTZXR0aW5ncyA9XG5cdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5lbmFibGVkID09PSBmYWxzZSB8fCBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5yZXN0cnVjdHVyZVNvcnRpbmcoKTtcblx0fVxuXHRASW5wdXQoKVxuXHRzZXQgZ3REYXRhKGluaXRpYWxEYXRhOiBBcnJheTxhbnk+KSB7XG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuX2d0T3B0aW9ucy5tdXRhdGVEYXRhXG5cdFx0XHQ/IFsuLi5pbml0aWFsRGF0YV1cblx0XHRcdDogdGhpcy5jbG9uZURlZXAoaW5pdGlhbERhdGEpO1xuXHRcdGlmICh0aGlzLmd0T3B0aW9ucy5sYXp5TG9hZCAmJiB0aGlzLmd0SW5mbykge1xuXHRcdFx0dGhpcy5ndE1ldGFQaXBlLnRyYW5zZm9ybShcblx0XHRcdFx0ZGF0YSxcblx0XHRcdFx0dGhpcy5ndE9wdGlvbnMucm93SW5kZXgsXG5cdFx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMSxcblx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHQpO1xuXHRcdFx0aWYgKHRoaXMubGF6eUFsbFNlbGVjdGVkKSB7XG5cdFx0XHRcdGNvbnN0IFVOSVFVRV9ST1dTID0gdGhpcy5zZWxlY3RlZFJvd3MubWFwKHJvdyA9PiByb3cuJCRndFJvd0lkKTtcblx0XHRcdFx0ZGF0YS5tYXAocm93ID0+IHtcblx0XHRcdFx0XHRpZiAoVU5JUVVFX1JPV1MuaW5kZXhPZihyb3cuJCRndFJvd0lkKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLnB1c2gocm93KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLnNlbGVjdGVkUm93cywgJ2lzU2VsZWN0ZWQnLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ndE1ldGFQaXBlLnRyYW5zZm9ybShkYXRhLCB0aGlzLmd0T3B0aW9ucy5yb3dJbmRleCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmd0T3B0aW9ucy5yb3dTZWxlY3Rpb25Jbml0aWFsU3RhdGUpIHtcblx0XHRcdGRhdGEubWFwKHJvdyA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGVkID1cblx0XHRcdFx0XHR0eXBlb2YgdGhpcy5ndE9wdGlvbnMucm93U2VsZWN0aW9uSW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IHRoaXMuZ3RPcHRpb25zLnJvd1NlbGVjdGlvbkluaXRpYWxTdGF0ZShyb3cpXG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ3RPcHRpb25zLnJvd1NlbGVjdGlvbkluaXRpYWxTdGF0ZTtcblx0XHRcdFx0aWYgKHNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSA9IHsgaXNTZWxlY3RlZDogdHJ1ZSB9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cy5wdXNoKHJvdyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoXG5cdFx0XHR0aGlzLmd0T3B0aW9ucy5yb3dFeHBhbmRJbml0aWFsU3RhdGUgJiZcblx0XHRcdHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxDb21wb25lbnRcblx0XHQpIHtcblx0XHRcdGRhdGEubWFwKHJvdyA9PiB7XG5cdFx0XHRcdGNvbnN0IGV4cGFuZGVkID1cblx0XHRcdFx0XHR0eXBlb2YgdGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxTdGF0ZShyb3cpXG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxTdGF0ZTtcblx0XHRcdFx0dGhpcy5leHBhbmRlZFJvdyA9IHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxDb21wb25lbnQ7XG5cblx0XHRcdFx0aWYgKGV4cGFuZGVkKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSA9IHsgaXNPcGVuOiB0cnVlIH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0uaXNPcGVuID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLl9ndERhdGEgPSBkYXRhO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGd0Um93Q29tcG9uZW50KHZhbHVlOiBUeXBlPEM+KSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0J0d0Um93Q29tcG9uZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHN1cHBvcnQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGphbG1lcnMvYW5ndWxhci1nZW5lcmljLXRhYmxlL2lzc3Vlcy8zNCdcblx0XHQpO1xuXHRcdHRoaXMuX2d0Um93Q29tcG9uZW50ID0gdmFsdWU7XG5cdH1cblxuXHRwdWJsaWMgY29sdW1uV2lkdGg6IE9iamVjdCA9IHt9O1xuXHRwdWJsaWMgY29uZmlnT2JqZWN0OiBHdENvbmZpZzxSPjtcblx0cHVibGljIHNvcnRPcmRlcjogQXJyYXk8YW55PiA9IFtdO1xuXHRwdWJsaWMgbWV0YUluZm86IHsgW2d0Um93SWQ6IHN0cmluZ106IEd0Um93TWV0YSB9ID0ge307XG5cdHB1YmxpYyBzZWxlY3RlZFJvd3M6IEFycmF5PEd0Um93PiA9IFtdO1xuXHRwdWJsaWMgb3BlblJvd3M6IEFycmF5PEd0Um93PiA9IFtdO1xuXHRwcml2YXRlIF9ndFNldHRpbmdzOiBHdENvbmZpZ1NldHRpbmdbXSA9IFtdO1xuXHRwcml2YXRlIF9ndEZpZWxkczogR3RDb25maWdGaWVsZDxSLCBhbnk+W10gPSBbXTtcblx0cHJpdmF0ZSBfZ3REYXRhOiBBcnJheTxhbnk+O1xuXHRwcml2YXRlIF9ndFRvdGFsczogYW55O1xuXHRwcml2YXRlIF9ndFJvd0NvbXBvbmVudDogVHlwZTxDPjtcblx0cHVibGljIGV4cGFuZGVkUm93OiB7XG5cdFx0Y29tcG9uZW50OiBUeXBlPEM+O1xuXHRcdGRhdGE/OiBBcnJheTxhbnk+O1xuXHR9O1xuXHRwdWJsaWMgZ3REZWZhdWx0VGV4dHM6IEd0VGV4dHMgPSB7XG5cdFx0bG9hZGluZzogJ0xvYWRpbmcuLi4nLFxuXHRcdG5vRGF0YTogJ05vIGRhdGEnLFxuXHRcdG5vTWF0Y2hpbmdEYXRhOiAnTm8gZGF0YSBtYXRjaGluZyByZXN1bHRzIGZvdW5kJyxcblx0XHRub1Zpc2libGVDb2x1bW5zSGVhZGluZzogJ05vIHZpc2libGUgY29sdW1ucycsXG5cdFx0bm9WaXNpYmxlQ29sdW1uczogJ1BsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIGNvbHVtbiB0byBiZSB2aXNpYmxlLicsXG5cdFx0dGFibGVJbmZvOlxuXHRcdFx0J1Nob3dpbmcgI3JlY29yZEZyb20gdG8gI3JlY29yZFRvIG9mICNyZWNvcmRzQWZ0ZXJTZWFyY2ggZW50cmllcy4nLFxuXHRcdHRhYmxlSW5mb0FmdGVyU2VhcmNoOlxuXHRcdFx0J1Nob3dpbmcgICNyZWNvcmRGcm9tIHRvICNyZWNvcmRUbyBvZiAjcmVjb3Jkc0FmdGVyU2VhcmNoIGVudHJpZXMgKGZpbHRlcmVkIGZyb20gYSB0b3RhbCBvZiAjcmVjb3Jkc0FsbCBlbnRyaWVzKS4nLFxuXHRcdGNzdkRvd25sb2FkOiAnZG93bmxvYWQnLFxuXHRcdHNvcnRMYWJlbDogJ1NvcnQ6Jyxcblx0XHRwYWdpbmF0ZU5leHQ6ICdOZXh0IHBhZ2UnLFxuXHRcdHBhZ2luYXRlUHJldmlvdXM6ICdQcmV2aW91cyBwYWdlJyxcblx0XHRpbmxpbmVFZGl0RWRpdGVkOiAnUHJlc3MgZW50ZXIgdG8gc2F2ZSdcblx0fTtcblx0QElucHV0KCkgZ3RUZXh0czogR3RUZXh0cyA9IHRoaXMuZ3REZWZhdWx0VGV4dHM7XG5cdEBJbnB1dCgpIGd0Q2xhc3Nlczogc3RyaW5nO1xuXHRAT3V0cHV0KCkgZ3RFdmVudDogRXZlbnRFbWl0dGVyPEd0RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRwdWJsaWMgZ3REZWZhdWx0T3B0aW9uczogR3RPcHRpb25zID0ge1xuXHRcdGNzdkRlbGltaXRlcjogJzsnLFxuXHRcdHN0YWNrOiBmYWxzZSxcblx0XHRsYXp5TG9hZDogZmFsc2UsXG5cdFx0Y2FjaGU6IGZhbHNlLFxuXHRcdGRlYm91bmNlVGltZTogMjAwLFxuXHRcdGhpZ2hsaWdodFNlYXJjaDogZmFsc2UsXG5cdFx0cm93U2VsZWN0aW9uOiBmYWxzZSxcblx0XHRyb3dTZWxlY3Rpb25BbGxvd011bHRpcGxlOiB0cnVlLFxuXHRcdHJvd0V4cGFuZEFsbG93TXVsdGlwbGU6IHRydWUsXG5cdFx0bnVtYmVyT2ZSb3dzOiAxMCxcblx0XHRyZXBvcnRDb2x1bW5XaWR0aDogZmFsc2UsXG5cdFx0YWxsb3dVbnNvcnRlZDogdHJ1ZSxcblx0XHRtdXRhdGVEYXRhOiB0cnVlXG5cdH07XG5cdHByaXZhdGUgX2d0T3B0aW9uczogR3RPcHRpb25zID0gdGhpcy5ndERlZmF1bHRPcHRpb25zO1xuXHRwdWJsaWMgc3RvcmU6IEFycmF5PGFueT4gPSBbXTtcblx0cHVibGljIGxvYWRpbmcgPSB0cnVlO1xuXHRwcml2YXRlIGRlYm91bmNlVGltZXI6IHZvaWQgPSBudWxsO1xuXHRwdWJsaWMgbG9hZGluZ1Byb3BlcnR5OiBzdHJpbmc7XG5cdHB1YmxpYyBsYXp5QWxsU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRASW5wdXQoKVxuXHRndEluZm86IEd0SW5mb3JtYXRpb24gPSB7XG5cdFx0cGFnZUN1cnJlbnQ6IDEsXG5cdFx0cGFnZVRvdGFsOiAwLFxuXHRcdHJlY29yZEZyb206IDAsXG5cdFx0cmVjb3JkVG86IDAsXG5cdFx0cmVjb3JkTGVuZ3RoOiB0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3MsXG5cdFx0cmVjb3Jkc0FsbDogMCxcblx0XHRyZWNvcmRzQWZ0ZXJGaWx0ZXI6IDAsXG5cdFx0cmVjb3Jkc0FmdGVyU2VhcmNoOiAwXG5cdH07XG5cblx0cHVibGljIHJlZnJlc2hQaXBlID0gZmFsc2U7XG5cdHB1YmxpYyByZWZyZXNoVG90YWxzID0gZmFsc2U7XG5cdHB1YmxpYyByZWZyZXNoU29ydGluZyA9IGZhbHNlO1xuXHRwdWJsaWMgcmVmcmVzaEZpbHRlciA9IGZhbHNlO1xuXHRwdWJsaWMgcmVmcmVzaFBhZ2VBcnJheSA9IGZhbHNlO1xuXHRwcml2YXRlIGdsb2JhbElubGluZUVkaXRMaXN0ZW5lcjogRnVuY3Rpb247XG5cdHB1YmxpYyBlZGl0ZWRSb3dzOiB7XG5cdFx0W2tleTogc3RyaW5nXToge1xuXHRcdFx0Y2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBHdFJlbmRlckZpZWxkPEd0Um93LCBhbnk+IH07XG5cdFx0XHRyb3c6IEd0Um93O1xuXHRcdH07XG5cdH0gPSB7fTtcblxuXHRwdWJsaWMgZGF0YTogeyBleHBvcnREYXRhOiBBcnJheTxhbnk+IH0gPSB7IGV4cG9ydERhdGE6IFtdIH07IC8vIFN0b3JlIGZpbHRlcmVkIGRhdGEgZm9yIGV4cG9ydFxuXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBndE1ldGFQaXBlOiBHdE1ldGFQaXBlKSB7XG5cdFx0dGhpcy5ndEV2ZW50LnN1YnNjcmliZSgoJGV2ZW50OiBHdEV2ZW50KSA9PiB7XG5cdFx0XHRpZiAoJGV2ZW50Lm5hbWUgPT09ICdndC1pbmZvJykge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVJlY29yZFJhbmdlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGV2ZW50Lm5hbWUgPT09ICdndC1yb3ctdXBkYXRlZCcpIHtcblx0XHRcdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTb3J0IHRhYmxlIGJ5IG9iamVjdCBrZXkuXG5cdCAqIEBwYXJhbSBvYmplY3RLZXkgLSBuYW1lIG9mIGtleSB0byBzb3J0IG9uLlxuXHQgKiBAcGFyYW0gZXZlbnQgLSBzdWNoIGFzIGtleSBwcmVzcyBkdXJpbmcgc29ydGluZy5cblx0ICovXG5cdHB1YmxpYyBndFNvcnQgPSBmdW5jdGlvbihvYmplY3RLZXk6IHN0cmluZywgZXZlbnQ6IGFueSkge1xuXHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbCgpOyAvLyBjYW5jZWwgaW5saW5lIGVkaXRpbmdcblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBjdXJyZW50IHNldHRpbmdzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXkgPT09IG9iamVjdEtleSkge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBzb3J0aW5nIGlzIGRpc2FibGVkLi4uXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgJiZcblx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQuaW5kZXhPZignZGlzYWJsZScpICE9PSAtMVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyAuLi5pZiBzbywgZXhpdCBmdW5jdGlvbiB3aXRob3V0IGFwcGx5aW5nIGFueSBzb3J0aW5nXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdC8qIGNoZWNrIGlmIHNvcnRpbmcgaXMgdW5kZWZpbmVkLi4uICovIHR5cGVvZiB0aGlzLl9ndFNldHRpbmdzW2ldXG5cdFx0XHRcdFx0XHQuc29ydCA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gLi4uaXMgc28sIHNldCBzb3J0aW5nIHByb3BlcnR5IHRvIGVuYWJsZVxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9ICdlbmFibGUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgbGVuZ3RoXG5cdFx0Y29uc3QgY3RybEtleSA9IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleTtcblx0XHRjb25zdCBzb3J0ID0gdGhpcy5zb3J0T3JkZXIuc2xpY2UoMCk7XG5cblx0XHRsZXQgbWF0Y2ggPSAtMTtcblx0XHRsZXQgbWF0Y2hEZXNjID0gLTE7XG5cdFx0bGV0IHBvcyA9IC0xO1xuXG5cdFx0Ly8gY2hlY2sgaWYgcHJvcGVydHkgYWxyZWFkeSBleGl0c1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc29ydC5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaGl0ID0gc29ydFtpXS5pbmRleE9mKG9iamVjdEtleSk7XG5cdFx0XHRpZiAoaGl0ICE9PSAtMSkge1xuXHRcdFx0XHRtYXRjaCA9IHRoaXMuc29ydE9yZGVyLmluZGV4T2Yob2JqZWN0S2V5KTtcblx0XHRcdFx0bWF0Y2hEZXNjID1cblx0XHRcdFx0XHRtYXRjaCA9PT0gLTEgPyB0aGlzLnNvcnRPcmRlci5pbmRleE9mKCctJyArIG9iamVjdEtleSkgOiBtYXRjaDtcblx0XHRcdFx0cG9zID0gTWF0aC5tYXgobWF0Y2gsIG1hdGNoRGVzYyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgY3RybCBrZXkgb3IgbWV0YSBrZXkgaXMgcHJlc3MgdG9nZXRoZXIgd2l0aCBzb3J0Li4uXG5cdFx0aWYgKGN0cmxLZXkpIHtcblx0XHRcdGlmICh0aGlzLnNvcnRPcmRlclt0aGlzLnNvcnRPcmRlci5sZW5ndGggLSAxXSA9PT0gJyQkZ3RJbml0aWFsUm93SW5kZXgnKSB7XG5cdFx0XHRcdHRoaXMuc29ydE9yZGVyLnBvcCgpO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChwb3MpIHtcblx0XHRcdFx0Ly8gLi4uYW5kIHByb3BlcnR5IGlzIG5vdCBzb3J0ZWQgYmVmb3JlLi4uXG5cdFx0XHRcdGNhc2UgLTE6XG5cdFx0XHRcdFx0Ly8gLi4uYWRkIHByb3BlcnR5IHRvIHNvcnRpbmdcblx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlci5wdXNoKG9iamVjdEtleSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Ly8gLi4uYW5kIHByb3BlcnR5IGlzIHNvcnRlZCBiZWZvcmUuLi5cblx0XHRcdFx0XHRpZiAobWF0Y2ggIT09IC0xKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgZnJvbSBhc2MgdG8gZGVzYyBpZiBzb3J0ZWQgYXNjXG5cdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlcltwb3NdID0gJy0nICsgb2JqZWN0S2V5O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5zb3J0T3JkZXIubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0Ly8gLi4ucmVtb3ZlIHNvcnRpbmcgaWYgc29ydGVkIGRlc2Ncblx0XHRcdFx0XHRcdGlmIChjdHJsS2V5KSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyW3Bvc10gPSBvYmplY3RLZXk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlci5zcGxpY2UocG9zLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuc29ydE9yZGVyLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uc2V0IHNvcnRpbmcgdG8gYXNjIGlmIG9ubHkgc29ydGVkIHByb3BlcnR5XG5cdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlcltwb3NdID0gb2JqZWN0S2V5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogaWYgY3RybCBrZXkgb3IgbWV0YSBrZXkgaXMgbm90IHByZXNzIHRvZ2V0aGVyIHdpdGggc29ydC4uLiAqL1xuXHRcdFx0c3dpdGNoIChwb3MpIHtcblx0XHRcdFx0Ly8gLi4uYW5kIHByb3BlcnR5IGlzIG5vdCBzb3J0ZWQgYmVmb3JlLi4uXG5cdFx0XHRcdGNhc2UgLTE6XG5cdFx0XHRcdFx0Ly8gLi4uc29ydCBieSBwcm9wZXJ0eVxuXHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyID0gW29iamVjdEtleV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Ly8gLi4uY2hhbmdlIGZyb20gZGVzYyB0byBhc2MgYW5kIHZpc2UgdmVyc2Fcblx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlciA9XG5cdFx0XHRcdFx0XHRtYXRjaCAhPT0gLTFcblx0XHRcdFx0XHRcdFx0PyBbJy0nICsgb2JqZWN0S2V5XVxuXHRcdFx0XHRcdFx0XHQ6IGN0cmxLZXkgfHwgIXRoaXMuZ3RPcHRpb25zLmFsbG93VW5zb3J0ZWRcblx0XHRcdFx0XHRcdFx0XHQ/IFtvYmplY3RLZXldXG5cdFx0XHRcdFx0XHRcdFx0OiBbXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgc2V0dGluZ3Mgb2JqZWN0IHdpdGggbmV3IHNvcnRpbmcgaW5mb3JtYXRpb25cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSA9PT0gb2JqZWN0S2V5KSB7XG5cdFx0XHRcdHN3aXRjaCAodGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0KSB7XG5cdFx0XHRcdFx0Ly8gaWYgc29ydGVkIGFzYy4uLlxuXHRcdFx0XHRcdGNhc2UgJ2FzYyc6XG5cdFx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgdG8gZGVzY1xuXHRcdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2Rlc2MnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gaWYgc29ydGVkIGRlc2MuLi5cblx0XHRcdFx0XHRjYXNlICdkZXNjJzpcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSB0byBhc2MgaWYgaXQncyB0aGUgb25seSBzb3J0ZWQgcHJvcGVydHkgb3RoZXJ3aXNlIHJlbW92ZSBzb3J0aW5nXG5cdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPVxuXHRcdFx0XHRcdFx0XHQodGhpcy5zb3J0T3JkZXIubGVuZ3RoID09PSAxICYmIHNvcnQubGVuZ3RoIDwgMikgfHxcblx0XHRcdFx0XHRcdFx0Y3RybEtleSB8fFxuXHRcdFx0XHRcdFx0XHQhdGhpcy5ndE9wdGlvbnMuYWxsb3dVbnNvcnRlZFxuXHRcdFx0XHRcdFx0XHRcdD8gJ2FzYydcblx0XHRcdFx0XHRcdFx0XHQ6ICdlbmFibGUnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gaWYgc29ydGluZyBlbmFibGVkLi4uXG5cdFx0XHRcdFx0Y2FzZSAnZW5hYmxlJzpcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSB0byBhc2Ncblx0XHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9ICdhc2MnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0T3JkZXIgPVxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9PT0gJ2VuYWJsZSdcblx0XHRcdFx0XHRcdD8gdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxXG5cdFx0XHRcdFx0XHQ6IHRoaXMuc29ydE9yZGVyLmluZGV4T2Yob2JqZWN0S2V5KSA9PT0gLTFcblx0XHRcdFx0XHRcdFx0PyB0aGlzLnNvcnRPcmRlci5pbmRleE9mKCctJyArIG9iamVjdEtleSlcblx0XHRcdFx0XHRcdFx0OiB0aGlzLnNvcnRPcmRlci5pbmRleE9mKG9iamVjdEtleSk7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgJiZcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0LmluZGV4T2YoJ2Rpc2FibGUnKSA9PT0gLTEgJiZcblx0XHRcdFx0dGhpcy5zb3J0T3JkZXIuaW5kZXhPZih0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSkgPT09IC0xICYmXG5cdFx0XHRcdHRoaXMuc29ydE9yZGVyLmluZGV4T2YoJy0nICsgdGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXkpID09PSAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9ICdlbmFibGUnO1xuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnRPcmRlciA9IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoIC0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZWZyZXNoIHNvcnRpbmcgcGlwZVxuXHRcdHRoaXMucmVmcmVzaFNvcnRpbmcgPSAhdGhpcy5yZWZyZXNoU29ydGluZztcblx0XHR0aGlzLnJlZnJlc2hQYWdlQXJyYXkgPSAhdGhpcy5yZWZyZXNoUGFnZUFycmF5O1xuXG5cdFx0Ly8gc29ydCBieSBpbml0aWFsIHNvcnQgb3JkZXIgYXMgbGFzdCByZXNvcnRcblx0XHR0aGlzLnNvcnRPcmRlci5wdXNoKCckJGd0SW5pdGlhbFJvd0luZGV4Jyk7XG5cblx0XHQvLyBlbWl0IHNvcnQgZXZlbnRcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3Qtc29ydGluZy1hcHBsaWVkJyxcblx0XHRcdHZhbHVlOiB0aGlzLnNvcnRPcmRlclxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgbnVtYmVyIG9mIHJvd3MgdG8gYmUgZGlzcGxheWVkLlxuXHQgKiBAcGFyYW0gcm93TGVuZ3RoIC0gdG90YWwgbnVtYmVyIG9mIHJvd3MuXG5cdCAqIEBwYXJhbSByZXNldCAtIHNob3VsZCBwYWdlIGJlIHJlc2V0IHRvIGZpcnN0IHBhZ2UuXG5cdCAqL1xuXHRwdWJsaWMgY2hhbmdlUm93TGVuZ3RoID0gZnVuY3Rpb24ocm93TGVuZ3RoOiBhbnksIHJlc2V0PzogYm9vbGVhbikge1xuXHRcdGxldCBsZW5ndGhWYWx1ZSA9IGlzTmFOKHBhcnNlSW50KHJvd0xlbmd0aCwgMTApKVxuXHRcdFx0PyAwXG5cdFx0XHQ6IHBhcnNlSW50KHJvd0xlbmd0aCwgMTApO1xuXHRcdGxldCBuZXdQb3NpdGlvbiA9IDE7XG5cblx0XHRpZiAoIWxlbmd0aFZhbHVlICYmIHRoaXMuZ3REYXRhKSB7XG5cdFx0XHRsZW5ndGhWYWx1ZSA9IHRoaXMuZ3REYXRhLmxlbmd0aDtcblx0XHR9XG5cblx0XHQvLyBpZiByZXNldCBpcyBub3QgdHJ1ZSBhbmQgd2UncmUgbm90IGxhenkgbG9hZGluZyBkYXRhLi4uXG5cdFx0aWYgKHJlc2V0ICE9PSB0cnVlICYmIHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCAhPT0gdHJ1ZSkge1xuXHRcdFx0Ly8gLi4uZ2V0IGN1cnJlbnQgcG9zaXRpb24gaW4gcmVjb3JkIHNldFxuXHRcdFx0Y29uc3QgY3VycmVudFJlY29yZCA9XG5cdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCAqICh0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDEpO1xuXHRcdFx0Y29uc3QgY3VycmVudFBvc2l0aW9uID1cblx0XHRcdFx0dGhpcy5fZ3REYXRhLmluZGV4T2YodGhpcy5fZ3REYXRhW2N1cnJlbnRSZWNvcmRdKSArIDE7XG5cblx0XHRcdC8vIC4uLmdldCBuZXcgcG9zaXRpb25cblx0XHRcdG5ld1Bvc2l0aW9uID0gTWF0aC5jZWlsKGN1cnJlbnRQb3NpdGlvbiAvIGxlbmd0aFZhbHVlKTtcblx0XHR9XG5cblx0XHQvLyBjaGFuZ2Ugcm93IGxlbmd0aFxuXHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCA9IGxlbmd0aFZhbHVlO1xuXG5cdFx0Ly8gZ28gdG8gbmV3IHBvc2l0aW9uXG5cdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgPSBuZXdQb3NpdGlvbjtcblxuXHRcdC8vIGlmIGxhenkgbG9hZGluZyBkYXRhLi4uXG5cdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCkge1xuXHRcdFx0Ly8gLi4ucmVwbGFjZSBkYXRhIHdpdGggcGxhY2UgaG9sZGVycyBmb3IgbmV3IGRhdGFcblx0XHRcdHRoaXMuX2d0RGF0YVswXSA9IHRoaXMubG9hZGluZ0NvbnRlbnQobGVuZ3RoVmFsdWUpO1xuXG5cdFx0XHQvLyAuLi5lbXB0eSBjdXJyZW50IHN0b3JlXG5cdFx0XHR0aGlzLnN0b3JlID0gW107XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcy51cGRhdGVSZWNvcmRSYW5nZSgpO1xuXG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LXJvdy1sZW5ndGgtY2hhbmdlZCcsXG5cdFx0XHR2YWx1ZTogbGVuZ3RoVmFsdWVcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogRm9yY2UgYSByZWRyYXcgb2YgdGFibGUgcm93cy5cblx0ICogQXMgdGhlIHRhYmxlIHVzZXMgcHVyZSBwaXBlcywgd2UgbmVlZCB0byBmb3JjZSBhIHJlZHJhdyBpZiBhbiBvYmplY3QgaW4gdGhlIGFycmF5IGlzIGNoYW5nZWQgdG8gc2VlIHRoZSBjaGFuZ2VzLlxuXHQgKi9cblx0cHVibGljIHJlZHJhdyA9IGZ1bmN0aW9uKCRldmVudD86IGFueSkge1xuXHRcdHRoaXMucmVmcmVzaFNvcnRpbmcgPSAhdGhpcy5yZWZyZXNoU29ydGluZztcblx0XHR0aGlzLnJlZnJlc2hQYWdlQXJyYXkgPSAhdGhpcy5yZWZyZXNoUGFnZUFycmF5O1xuXHRcdHRoaXMucmVmcmVzaFBpcGUgPSAhdGhpcy5yZWZyZXNoUGlwZTtcblx0fTtcblxuXHQvKiogVXBkYXRlIHJlY29yZCByYW5nZS4gKi9cblx0cHJpdmF0ZSB1cGRhdGVSZWNvcmRSYW5nZSgpIHtcblx0XHR0aGlzLmd0SW5mby5yZWNvcmRGcm9tID1cblx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaCA9PT0gMFxuXHRcdFx0XHQ/IDBcblx0XHRcdFx0OiAodGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxKSAqIHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCArIDE7XG5cdFx0dGhpcy5ndEluZm8ucmVjb3JkVG8gPVxuXHRcdFx0dGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoIDxcblx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ICogdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHRcdD8gdGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoXG5cdFx0XHRcdDogdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgKiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGg7XG5cdH1cblxuXHQvKiogVXBkYXRlIHRvdGFscy4gKi9cblx0cHJpdmF0ZSB1cGRhdGVUb3RhbHMoKSB7XG5cdFx0dGhpcy5yZWZyZXNoVG90YWxzID0gIXRoaXMucmVmcmVzaFRvdGFscztcblx0fVxuXG5cdC8qKiBHbyB0byBuZXh0IHBhZ2UuICovXG5cdHB1YmxpYyBuZXh0UGFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnN0IHBhZ2UgPVxuXHRcdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgPT09IHRoaXMuZ3RJbmZvLnBhZ2VUb3RhbFxuXHRcdFx0XHQ/IHRoaXMuZ3RJbmZvLnBhZ2VUb3RhbFxuXHRcdFx0XHQ6IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ICsgMTtcblx0XHR0aGlzLmdvVG9QYWdlKHBhZ2UpO1xuXHR9O1xuXG5cdC8qKiBHbyB0byBwcmV2aW91cyBwYWdlLiAqL1xuXHRwdWJsaWMgcHJldmlvdXNQYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3QgcGFnZSA9XG5cdFx0XHR0aGlzLmd0SW5mby5wYWdlQ3VycmVudCA9PT0gMSA/IDEgOiB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDE7XG5cdFx0dGhpcy5nb1RvUGFnZShwYWdlKTtcblx0fTtcblxuXHQvKiogUmVxdWVzdCBtb3JlIGRhdGEgKHVzZWQgd2hlbiBsYXp5IGxvYWRpbmcpICovXG5cdHByaXZhdGUgZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIC4uLmVtaXQgZXZlbnQgcmVxdWVzdGluZyBmb3IgbW9yZSBkYXRhXG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LXBhZ2UtY2hhbmdlZC1sYXp5Jyxcblx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdHBhZ2VDdXJyZW50OiB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCxcblx0XHRcdFx0cmVjb3JkTGVuZ3RoOiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR28gdG8gc3BlY2lmaWMgcGFnZS5cblx0ICogQHBhcmFtIHBhZ2UgLSBwYWdlIG51bWJlci5cblx0ICovXG5cdHB1YmxpYyBnb1RvUGFnZSA9IGZ1bmN0aW9uKHBhZ2U6IG51bWJlcikge1xuXHRcdGNvbnN0IHByZXZpb3VzUGFnZSA9IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50O1xuXHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ID0gcGFnZTtcblx0XHR0aGlzLmlubGluZUVkaXRDYW5jZWwoKTsgLy8gY2FuY2VsIGlubGluZSBlZGl0XG5cblx0XHQvLyBpZiBsYXp5IGxvYWRpbmcgYW5kIGlmIHBhZ2UgY29udGFpbnMgbm8gcmVjb3Jkcy4uLlxuXHRcdGlmICh0aGlzLl9ndE9wdGlvbnMubGF6eUxvYWQpIHtcblx0XHRcdC8vIC4uLmlmIGRhdGEgZm9yIGN1cnJlbnQgcGFnZSBjb250YWlucyBubyBlbnRyaWVzLi4uXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMuX2d0T3B0aW9ucy5jYWNoZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV0ubGVuZ3RoID09PSAwXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gLi4uY3JlYXRlIHRlbXBvcmFyeSBjb250ZW50IHdoaWxlIHdhaXRpbmcgZm9yIGRhdGFcblx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV0gPSB0aGlzLmxvYWRpbmdDb250ZW50KFxuXHRcdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxuXHRcdFx0XHQpO1xuXHRcdFx0XHR0aGlzLmxvYWRpbmcgPSB0cnVlOyAvLyBsb2FkaW5nIHRydWVcblx0XHRcdH1cblx0XHRcdC8vIC4uLmlmIGZpcnN0IGVudHJ5IGluIGN1cnJlbnQgcGFnZSBlcXVhbHMgb3VyIGxvYWRpbmcgcGxhY2Vob2xkZXIuLi5cblx0XHRcdGlmIChcblx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV1bMF1bdGhpcy5sb2FkaW5nUHJvcGVydHldID09PVxuXHRcdFx0XHR0aGlzLmd0VGV4dHMubG9hZGluZ1xuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIC4uLmdldCBkYXRhXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpO1xuXHRcdFx0XHR0aGlzLmRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmdldERhdGEoKTtcblx0XHRcdFx0fSwgdGhpcy5fZ3RPcHRpb25zLmRlYm91bmNlVGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcy51cGRhdGVSZWNvcmRSYW5nZSgpO1xuXG5cdFx0Ly8gLi4uZW1pdCBwYWdlIGNoYW5nZSBldmVudFxuXHRcdGlmIChwcmV2aW91c1BhZ2UgIT09IHBhZ2UpIHtcblx0XHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcblx0XHRcdFx0bmFtZTogJ2d0LXBhZ2UtY2hhbmdlZCcsXG5cdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0cGFnZUN1cnJlbnQ6IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50LFxuXHRcdFx0XHRcdHBhZ2VQcmV2aW91czogcHJldmlvdXNQYWdlLFxuXHRcdFx0XHRcdHJlY29yZExlbmd0aDogdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IG1ldGEgZGF0YSBmb3Igcm93LlxuXHQgKi9cblx0cHVibGljIGdldFJvd1N0YXRlKHJvdzogUik6IEd0Um93TWV0YSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID09PSAndW5kZWZpbmVkJ1xuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF07XG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kIGFsbCByb3dzLlxuXHQgKiBAcGFyYW0gZXhwYW5kZWRSb3cgLSBjb21wb25lbnQgdG8gcmVuZGVyIHdoZW4gcm93cyBhcmUgZXhwYW5kZWQuXG5cdCAqL1xuXHRwdWJsaWMgZXhwYW5kQWxsUm93cyhleHBhbmRlZFJvdzogeyBjb21wb25lbnQ6IFR5cGU8Qz47IGRhdGE/OiBhbnkgfSk6IHZvaWQge1xuXHRcdHRoaXMuZXhwYW5kZWRSb3cgPSBleHBhbmRlZFJvdztcblx0XHR0aGlzLl90b2dnbGVBbGxSb3dQcm9wZXJ0eSgnaXNPcGVuJywgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29sbGFwc2UgYWxsIHJvd3MuXG5cdCAqL1xuXHRwdWJsaWMgY29sbGFwc2VBbGxSb3dzKCk6IHZvaWQge1xuXHRcdHRoaXMuX3RvZ2dsZUFsbFJvd1Byb3BlcnR5KCdpc09wZW4nLCBmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0IGFsbCByb3dzLlxuXHQgKi9cblx0cHVibGljIHNlbGVjdEFsbFJvd3MoKTogdm9pZCB7XG5cdFx0dGhpcy5fdG9nZ2xlQWxsUm93UHJvcGVydHkoJ2lzU2VsZWN0ZWQnLCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXNlbGVjdCBhbGwgcm93cy5cblx0ICovXG5cdHB1YmxpYyBkZXNlbGVjdEFsbFJvd3MoKTogdm9pZCB7XG5cdFx0dGhpcy5fdG9nZ2xlQWxsUm93UHJvcGVydHkoJ2lzU2VsZWN0ZWQnLCBmYWxzZSk7XG5cdH1cblx0LyoqXG5cdCAqIFRvZ2dsZSBhbGwgcm93cy5cblx0ICovXG5cdHB1YmxpYyB0b2dnbGVBbGxSb3dzKCk6IHZvaWQge1xuXHRcdGlmICh0aGlzLl9ndE9wdGlvbnMubGF6eUxvYWQpIHtcblx0XHRcdGlmICghdGhpcy5sYXp5QWxsU2VsZWN0ZWQgfHwgdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0QWxsUm93cygpO1xuXHRcdFx0XHR0aGlzLmxhenlBbGxTZWxlY3RlZCA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRlc2VsZWN0QWxsUm93cygpO1xuXHRcdFx0XHR0aGlzLmxhenlBbGxTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoICE9PSB0aGlzLmd0RGF0YS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5zZWxlY3RBbGxSb3dzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRlc2VsZWN0QWxsUm93cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgcm93IGNvbGxhcHNlZCBzdGF0ZSBpZS4gZXhwYW5kZWQvb3BlbiBvciBjb2xsYXBzZWQvY2xvc2VkLlxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdCB0aGF0IHNob3VsZCBiZSBleHBhbmRlZC9jb2xsYXBzZWQuXG5cdCAqIEBwYXJhbSBleHBhbmRlZFJvdyAtIGNvbXBvbmVudCB0byByZW5kZXIgd2hlbiByb3cgaXMgZXhwYW5kZWQuXG5cdCAqL1xuXHRwdWJsaWMgdG9nZ2xlQ29sbGFwc2UoXG5cdFx0cm93OiBHdFJvdyxcblx0XHRleHBhbmRlZFJvdz86IHsgY29tcG9uZW50OiBUeXBlPEM+OyBkYXRhPzogYW55IH1cblx0KSB7XG5cdFx0aWYgKGV4cGFuZGVkUm93KSB7XG5cdFx0XHR0aGlzLmV4cGFuZGVkUm93ID0gZXhwYW5kZWRSb3c7XG5cdFx0fVxuXHRcdHRoaXMuX3RvZ2dsZVJvd1Byb3BlcnR5KHJvdywgJ2lzT3BlbicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZSByb3cgc2VsZWN0ZWQgc3RhdGUgaWUuIHNlbGVjdGVkIG9yIG5vdC5cblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQvZGVzZWxlY3RlZC5cblx0ICovXG5cdHB1YmxpYyB0b2dnbGVTZWxlY3Qocm93OiBHdFJvdykge1xuXHRcdHRoaXMuX3RvZ2dsZVJvd1Byb3BlcnR5KHJvdywgJ2lzU2VsZWN0ZWQnKTtcblx0fVxuXG5cdHB1YmxpYyByb3dDbGljayhyb3c6IEd0Um93LCAkZXZlbnQ6IE1vdXNlRXZlbnQpIHtcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3Qtcm93LWNsaWNrZWQnLFxuXHRcdFx0dmFsdWU6IHsgcm93OiByb3csIGV2ZW50OiAkZXZlbnQgfVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSByb3cgZGF0YS5cblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QgdGhhdCBoYXMgYmVlbiBlZGl0ZWQuXG5cdCAqIEBwYXJhbSBvbGRWYWx1ZSAtIHJvdyBvYmplY3QgYmVmb3JlIGVkaXQuXG5cdCAqL1xuXHRwdWJsaWMgdXBkYXRlUm93KHJvdzogR3RSb3csIG9sZFZhbHVlOiBHdFJvdykge1xuXHRcdHRoaXMuX3RvZ2dsZVJvd1Byb3BlcnR5KHJvdywgJ2lzVXBkYXRlZCcsIG9sZFZhbHVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiByZW1vdmVzIGEgcm93IGZyb20gdGhlIHRhYmxlXG5cdCAqIEBwYXJhbSByb3cgLSB0aGUgcm93IG9iamVjdCB0byByZW1vdmVcblx0ICovXG5cdHB1YmxpYyByZW1vdmVSb3cocm93OiBHdFJvdykge1xuXHRcdGlmICh0aGlzLmlzUm93U2VsZWN0ZWQocm93KSkge1xuXHRcdFx0dGhpcy50b2dnbGVTZWxlY3Qocm93KTtcblx0XHR9XG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLl9ndERhdGEuaW5kZXhPZihyb3cpO1xuXHRcdHRoaXMuX2d0RGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIGNoZWNrIGlmIGEgcm93IGlzIHNlbGVjdGVkXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0XG5cdCAqL1xuXHRwdWJsaWMgaXNSb3dTZWxlY3RlZChyb3c6IEd0Um93KTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gJiYgdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXS5pc1NlbGVjdGVkXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgbWV0YSBpbmZvIGZvciBhbGwgcm93cywgaWUuIGlzU2VsZWN0ZWQsIGlzT3Blbi5cblx0ICogQHBhcmFtIGFycmF5IC0gYXJyYXkgdGhhdCBob2xkcyByb3dzIHRoYXQgbmVlZCB0byBiZSB1cGRhdGVkLlxuXHQgKiBAcGFyYW0gcHJvcGVydHkgLSBuYW1lIG9mIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIGNoYW5nZWQvdG9nZ2xlZC5cblx0ICogQHBhcmFtIGFjdGl2ZSAtIHNob3VsZCByb3dzIGJlIGV4cGFuZGVkL29wZW4sIHNlbGVjdGVkLlxuXHQgKiBAcGFyYW0gZXhjZXB0aW9uIC0gdXBkYXRlIGFsbCByb3dzIGV4Y2VwdCB0aGlzIG9uZS5cblx0ICovXG5cdHByaXZhdGUgX3VwZGF0ZU1ldGFJbmZvKFxuXHRcdGFycmF5OiBBcnJheTxHdFJvdz4sXG5cdFx0cHJvcGVydHk6IHN0cmluZyxcblx0XHRhY3RpdmU6IGJvb2xlYW4sXG5cdFx0ZXhjZXB0aW9uPzogR3RSb3dcblx0KSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKCF0aGlzLm1ldGFJbmZvW2FycmF5W2ldLiQkZ3RSb3dJZF0pIHtcblx0XHRcdFx0dGhpcy5tZXRhSW5mb1thcnJheVtpXS4kJGd0Um93SWRdID0ge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhjZXB0aW9uICYmIGFycmF5W2ldLiQkZ3RSb3dJZCA9PT0gZXhjZXB0aW9uLiQkZ3RSb3dJZCkge1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5tZXRhSW5mb1thcnJheVtpXS4kJGd0Um93SWRdW3Byb3BlcnR5XSA9IGFjdGl2ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHVzaCBzZWxlY3RlZC9leHBhbmRlZCBsYXp5IGxvYWRlZCByb3dzIHRvIGFycmF5IHdpdGggbWV0YSBkYXRhLlxuXHQgKiBAcGFyYW0gdGFyZ2V0IC0gYXJyYXkgdG8gd2hpY2ggcm93cyBzaG91bGQgYmUgYWRkZWQuXG5cdCAqIEBwYXJhbSBzb3VyY2UgLSBhcnJheSB0aGF0IGhvbGRzIHJvd3MgdGhhdCBzaG91bGQgYmUgYWRkZWQuXG5cdCAqIEByZXR1cm5zIGFycmF5IHdpdGggYWRkZWQgcm93cy5cblx0ICovXG5cdHByaXZhdGUgX3B1c2hMYXp5Um93cyhcblx0XHR0YXJnZXQ6IEFycmF5PEd0Um93Pixcblx0XHRzb3VyY2U6IEFycmF5PEd0Um93PlxuXHQpOiBBcnJheTxHdFJvdz4ge1xuXHRcdGNvbnN0IFVOSVFVRV9ST1dTID0gdGFyZ2V0Lm1hcChyb3cgPT4gcm93LiQkZ3RSb3dJZCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdC8vIG9ubHkgYWRkIGlmIG5vdCBhbHJlYWR5IGluIGxpc3Rcblx0XHRcdGlmIChVTklRVUVfUk9XUy5pbmRleE9mKHNvdXJjZVtpXS4kJGd0Um93SWQpID09PSAtMSkge1xuXHRcdFx0XHR0YXJnZXQucHVzaChzb3VyY2VbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZSBtZXRhIGluZm8gZm9yIGFsbCByb3dzLCBpZS4gaXNTZWxlY3RlZCwgaXNPcGVuLlxuXHQgKiBAcGFyYW0gcHJvcGVydHkgLSBuYW1lIG9mIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIGNoYW5nZWQvdG9nZ2xlZC5cblx0ICogQHBhcmFtIGFjdGl2ZSAtIHNob3VsZCByb3dzIGJlIGV4cGFuZGVkL29wZW4sIHNlbGVjdGVkLlxuXHQgKi9cblx0cHJpdmF0ZSBfdG9nZ2xlQWxsUm93UHJvcGVydHkocHJvcGVydHk6IHN0cmluZywgYWN0aXZlOiBib29sZWFuKSB7XG5cdFx0bGV0IGV2ZW50TmFtZTogc3RyaW5nO1xuXHRcdGxldCBldmVudFZhbHVlOiBhbnk7XG5cdFx0c3dpdGNoIChwcm9wZXJ0eSkge1xuXHRcdFx0Y2FzZSAnaXNPcGVuJzpcblx0XHRcdFx0Ly8gY2hlY2sgaWYgbXVsdGlwbGUgZXhwYW5kZWQgcm93cyBhcmUgYWxsb3dlZC4uLlxuXHRcdFx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLnJvd0V4cGFuZEFsbG93TXVsdGlwbGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly8gLi4uaWYgbm90LCBleGl0IGZ1bmN0aW9uXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdFx0XHQnZmVhdHVyZSBkaXNhYmxlZDogZW5hYmxlIGJ5IHNldHRpbmcgXCJyb3dFeHBhbmRBbGxvd011bHRpcGxlID0gdHJ1ZVwiJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhY3RpdmUpIHtcblx0XHRcdFx0XHRldmVudE5hbWUgPSAnZXhwYW5kLWFsbCc7XG5cdFx0XHRcdFx0dGhpcy5vcGVuUm93cyA9IHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZFxuXHRcdFx0XHRcdFx0PyB0aGlzLl9wdXNoTGF6eVJvd3MoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5vcGVuUm93cyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9ndERhdGFbdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxXS5zbGljZSgpXG5cdFx0XHRcdFx0XHQgIClcblx0XHRcdFx0XHRcdDogdGhpcy5fZ3REYXRhLnNsaWNlKCk7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5vcGVuUm93cywgcHJvcGVydHksIGFjdGl2ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2NvbGxhcHNlLWFsbCc7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5vcGVuUm93cywgcHJvcGVydHksIGFjdGl2ZSk7XG5cdFx0XHRcdFx0dGhpcy5vcGVuUm93cyA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2ZW50VmFsdWUgPSB7XG5cdFx0XHRcdFx0ZXhwYW5kZWRSb3dzOiB0aGlzLm9wZW5Sb3dzLFxuXHRcdFx0XHRcdGNoYW5nZWRSb3c6ICdhbGwnXG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaXNTZWxlY3RlZCc6XG5cdFx0XHRcdC8vIGNoZWNrIGlmIG11bHRpIHJvdyBzZWxlY3Rpb24gaXMgYWxsb3dlZC4uLlxuXHRcdFx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLnJvd1NlbGVjdGlvbkFsbG93TXVsdGlwbGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly8gLi4uaWYgbm90LCBleGl0IGZ1bmN0aW9uXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdFx0XHQnZmVhdHVyZSBkaXNhYmxlZDogZW5hYmxlIGJ5IHNldHRpbmcgXCJyb3dTZWxlY3Rpb25BbGxvd011bHRpcGxlID0gdHJ1ZVwiJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhY3RpdmUpIHtcblx0XHRcdFx0XHRldmVudE5hbWUgPSAnc2VsZWN0LWFsbCc7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3MgPSB0aGlzLl9ndE9wdGlvbnMubGF6eUxvYWRcblx0XHRcdFx0XHRcdD8gdGhpcy5fcHVzaExhenlSb3dzKFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2d0RGF0YVt0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDFdLnNsaWNlKClcblx0XHRcdFx0XHRcdCAgKVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9ndERhdGEuc2xpY2UoKTtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLnNlbGVjdGVkUm93cywgcHJvcGVydHksIGFjdGl2ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2Rlc2VsZWN0LWFsbCc7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5zZWxlY3RlZFJvd3MsIHByb3BlcnR5LCBhY3RpdmUpO1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXZlbnRWYWx1ZSA9IHtcblx0XHRcdFx0XHRzZWxlY3RlZFJvd3M6IHRoaXMuc2VsZWN0ZWRSb3dzLFxuXHRcdFx0XHRcdGNoYW5nZWRSb3c6ICdhbGwnXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcblx0XHRcdG5hbWU6ICdndC1yb3ctJyArIGV2ZW50TmFtZSxcblx0XHRcdHZhbHVlOiBldmVudFZhbHVlXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlIG1ldGEgaW5mbyBmb3Igcm93LCBpZS4gaXNTZWxlY3RlZCwgaXNPcGVuLlxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdC5cblx0ICogQHBhcmFtIHByb3BlcnR5IC0gbmFtZSBvZiBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBjaGFuZ2VkL3RvZ2dsZWQuXG5cdCAqIEBwYXJhbSBwcm9wZXJ0eVZhbHVlcyAtIG9wdGlvbmFsIHByb3BlcnR5IHZhbHVlcyB0aGF0IGNhbiBiZSBwYXNzZWQuXG5cdCAqL1xuXHRwcml2YXRlIF90b2dnbGVSb3dQcm9wZXJ0eShcblx0XHRyb3c6IEd0Um93LFxuXHRcdHByb3BlcnR5OiBzdHJpbmcsXG5cdFx0cHJvcGVydHlWYWx1ZXM/OiBhbnlcblx0KSB7XG5cdFx0bGV0IGV2ZW50TmFtZTogc3RyaW5nO1xuXHRcdGxldCBldmVudFZhbHVlOiBhbnk7XG5cdFx0Ly8gbWFrZSBzdXJlIGd0Um93SWQgZXhpc3RzIG9uIHJvdyBvYmplY3Rcblx0XHRpZiAodHlwZW9mIHJvdy4kJGd0Um93SWQgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHQvLyBjaGVjayBpZiBtZXRhIGluZm8gZXhpc3RzIGZvciByb3dcblx0XHRcdGlmICghdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSkge1xuXHRcdFx0XHQvLyBpZiBub3QsIGFkZCBvYmplY3QgdG8gc3RvcmUgbWV0YSBpbmZvXG5cdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPSB7fTtcblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoIChwcm9wZXJ0eSkge1xuXHRcdFx0XHRjYXNlICdpc09wZW4nOlxuXHRcdFx0XHRcdGNvbnN0IG9wZW5lZCA9IHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgbXVsdGlwbGUgZXhwYW5kZWQgcm93cyBhcmUgYWxsb3dlZC4uLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9ndE9wdGlvbnMucm93RXhwYW5kQWxsb3dNdWx0aXBsZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdC8vIC4uLmlmIG5vdCwgY29sbGFwc2UgYWxsIHJvd3MgZXhjZXB0IGN1cnJlbnQgcm93XG5cdFx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLm9wZW5Sb3dzLCBwcm9wZXJ0eSwgZmFsc2UsIHJvdyk7XG5cdFx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgcm93IGlzIGV4cGFuZGVkXG5cdFx0XHRcdFx0aWYgKCFvcGVuZWQpIHtcblx0XHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdleHBhbmQnO1xuXHRcdFx0XHRcdFx0Ly8gYWRkIHJvdyB0byBleHBhbmRlZCByb3dzXG5cdFx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzLnB1c2gocm93KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2NvbGxhcHNlJztcblx0XHRcdFx0XHRcdC8vIGxvb3AgdGhyb3VnaCBleHBhbmRlZCByb3dzLi4uXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3BlblJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Ly8gaWYgZXhwYW5kZWQgcm93IGVxdWFscyBwYXNzZWQgcm93Li4uXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLm9wZW5Sb3dzW2ldLiQkZ3RSb3dJZCA9PT0gcm93LiQkZ3RSb3dJZCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLnJlbW92ZSByb3cgZnJvbSBleHBhbmRlZCByb3dzLi4uXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5vcGVuUm93cy5zcGxpY2UoaSwgMSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZXhpdCBsb29wXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXZlbnRWYWx1ZSA9IHtcblx0XHRcdFx0XHRcdGV4cGFuZGVkUm93czogdGhpcy5vcGVuUm93cyxcblx0XHRcdFx0XHRcdGNoYW5nZWRSb3c6IHJvd1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2lzU2VsZWN0ZWQnOlxuXHRcdFx0XHRcdGNvbnN0IHNlbGVjdGVkID0gdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV07XG5cblx0XHRcdFx0XHQvLyBjaGVjayBpZiBtdWx0aSByb3cgc2VsZWN0aW9uIGlzIGFsbG93ZWQuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLnJvd1NlbGVjdGlvbkFsbG93TXVsdGlwbGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIGRlc2VsZWN0IGFsbCByb3dzIGV4Y2VwdCBjdXJyZW50IHJvd1xuXHRcdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5zZWxlY3RlZFJvd3MsIHByb3BlcnR5LCBmYWxzZSwgcm93KTtcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgcm93IGlzIHNlbGVjdGVkXG5cdFx0XHRcdFx0aWYgKCFzZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0ZXZlbnROYW1lID0gJ3NlbGVjdCc7XG5cdFx0XHRcdFx0XHQvLyBhZGQgcm93IHRvIHNlbGVjdGVkIHJvd3Ncblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLnB1c2gocm93KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZ3RPcHRpb25zLmxhenlMb2FkICYmIHRoaXMubGF6eUFsbFNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubGF6eUFsbFNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRldmVudE5hbWUgPSAnZGVzZWxlY3QnO1xuXHRcdFx0XHRcdFx0Ly8gbG9vcCB0aHJvdWdoIHNlbGVjdGVkIHJvd3MuLi5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWxlY3RlZFJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0Ly8gaWYgc2VsZWN0ZWQgcm93IGVxdWFscyBwYXNzZWQgcm93Li4uXG5cdFx0XHRcdFx0XHRcdGlmICh0aGlzLnNlbGVjdGVkUm93c1tpXS4kJGd0Um93SWQgPT09IHJvdy4kJGd0Um93SWQpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5yZW1vdmUgcm93IGZyb20gc2VsZWN0ZWQgcm93cy4uLlxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLnNwbGljZShpLCAxKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBleGl0IGxvb3Bcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRldmVudFZhbHVlID0ge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRSb3dzOiB0aGlzLnNlbGVjdGVkUm93cyxcblx0XHRcdFx0XHRcdGNoYW5nZWRSb3c6IHJvd1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaXNVcGRhdGVkJzpcblx0XHRcdFx0XHRldmVudE5hbWUgPSAndXBkYXRlZCc7XG5cdFx0XHRcdFx0Y29uc3Qgb2xkVmFsdWUgPSBwcm9wZXJ0eVZhbHVlcztcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBlZGl0IG9iamVjdCBleGlzdHMgZm9yIHJvd1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XSA9IHtcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZTogb2xkVmFsdWUsXG5cdFx0XHRcdFx0XHRcdG9sZFZhbHVlOiBvbGRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0bmV3VmFsdWU6IHJvd1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV0ub2xkVmFsdWUgPSBvbGRWYWx1ZTtcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldLm5ld1ZhbHVlID0gcm93O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRldmVudFZhbHVlID0gdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHRcdFx0XHR0aGlzLmlubGluZUVkaXRDYW5jZWwocm93KTtcblx0XHRcdFx0XHQvLyB0aGlzLmd0RGF0YSA9IFsuLi50aGlzLmd0RGF0YS5tYXAoKHIpID0+IHsgcmV0dXJuey4uLnJ9OyB9KV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRcdG5hbWU6ICdndC1yb3ctJyArIGV2ZW50TmFtZSxcblx0XHRcdFx0dmFsdWU6IGV2ZW50VmFsdWVcblx0XHRcdH0pO1xuXHRcdFx0aWYgKHByb3BlcnR5ICE9PSAnaXNVcGRhdGVkJykge1xuXHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XSA9ICF0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW1xuXHRcdFx0XHRcdHByb3BlcnR5XG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBjb2x1bW4uXG5cdCAqIEBwYXJhbSAkZXZlbnQgLSBrZXkgdXAgZXZlbnQuXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0LlxuXHQgKiBAcGFyYW0gY29sdW1uIC0gY29sdW1uIG9iamVjdC5cblx0ICovXG5cdHB1YmxpYyBndFVwZGF0ZUNvbHVtbihcblx0XHQkZXZlbnQ6IEtleWJvYXJkRXZlbnQsXG5cdFx0cm93OiBHdFJvdyxcblx0XHRjb2x1bW46IEd0UmVuZGVyRmllbGQ8YW55LCBhbnk+XG5cdCkge1xuXHRcdHRoaXMuX2VkaXRSb3cocm93LCBjb2x1bW4pO1xuXHR9XG5cblx0LyoqXG5cdCAqIERyb3Bkb3duIHNlbGVjdC5cblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QuXG5cdCAqIEBwYXJhbSBjb2x1bW4gLSBjb2x1bW4gb2JqZWN0LlxuXHQgKi9cblx0cHVibGljIGd0RHJvcGRvd25TZWxlY3Qocm93OiBHdFJvdywgY29sdW1uOiBHdFJlbmRlckZpZWxkPGFueSwgYW55Pikge1xuXHRcdGNvbnN0IG9sZFZhbHVlID0geyAuLi5yb3cgfTtcblx0XHRyb3dbY29sdW1uLm9iamVjdEtleV0gPSBjb2x1bW4ucmVuZGVyVmFsdWU7XG5cdFx0dGhpcy51cGRhdGVSb3cocm93LCBvbGRWYWx1ZSk7XG5cdH1cblxuXHRwcml2YXRlIF9lZGl0Um93KHJvdzogR3RSb3csIGNvbHVtbjogR3RSZW5kZXJGaWVsZDxhbnksIGFueT4pIHtcblx0XHRjb25zdCBPQkpFQ1RfS0VZID0gY29sdW1uLm9iamVjdEtleTsgLy8gZGVjbGFyZSBvYmplY3Qga2V5IHdoaWNoIGNvbnRhaW5zIGNoYW5nZXNcblxuXHRcdC8vIGNoZWNrIGlmIGNlbGwgaGFzIGNoYW5nZWQgdmFsdWVcblx0XHRjb2x1bW4uZWRpdGVkID0gcm93W2NvbHVtbi5vYmplY3RLZXldICE9PSBjb2x1bW4ucmVuZGVyVmFsdWU7XG5cdFx0Ly8gY2hlY2sgaWYgcm93IGNvbnRhaW5zIGNoYW5nZXMuLi5cblx0XHRpZiAoIXRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXSkge1xuXHRcdFx0Ly8gaWYgbm90LCBjcmVhdGUgYW4gb2JqZWN0IGZvciB0aGUgY2hhbmdlZCByb3dcblx0XHRcdHRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXSA9IHtcblx0XHRcdFx0Y2hhbmdlczoge30sIC8vIGNyZWF0ZSBwbGFjZWhvbGRlciBmb3IgY2hhbmdlc1xuXHRcdFx0XHRyb3c6IHJvdyAvLyBzdG9yZSByZWZlcmVuY2UgdG8gdGhlIHJvdyB0aGF0IHNob3VsZCBiZSB1cGRhdGVkXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIHN0b3JlIGNoYW5nZWQgY29sdW1uIHVuZGVyIGNoYW5nZXMgaWYgaXQgaGFzIGJlZW4gZWRpdGVkXG5cdFx0aWYgKGNvbHVtbi5lZGl0ZWQpIHtcblx0XHRcdHRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXS5jaGFuZ2VzW09CSkVDVF9LRVldID0gY29sdW1uO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBkZWxldGUgY2hhbmdlIG9iamVjdCBpZiBjb2x1bW4gaXMgdW5jaGFuZ2VkXG5cdFx0XHRkZWxldGUgdGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdLmNoYW5nZXNbT0JKRUNUX0tFWV07XG5cdFx0XHQvLyBjaGVjayBob3cgbWFueSBjb2x1bW5zIGhhdmUgYmVlbiBjaGFuZ2VkXG5cdFx0XHRjb25zdCBDSEFOR0VEX0NPTFVNTlMgPSBPYmplY3Qua2V5cyhcblx0XHRcdFx0dGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdLmNoYW5nZXNcblx0XHRcdCkubGVuZ3RoO1xuXHRcdFx0aWYgKENIQU5HRURfQ09MVU1OUyA9PT0gMCkge1xuXHRcdFx0XHQvLyBkZWxldGUgcm93IGZyb20gZWRpdGVkIHJvd3MgaWYgbm8gY29sdW1ucyBoYXZlIGJlZW4gZWRpdGVkXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGlmIG5vIGxpc3RlbmVyIGlzIHByZXNlbnQuLi5cblx0XHRpZiAoIXRoaXMuZ2xvYmFsSW5saW5lRWRpdExpc3RlbmVyKSB7XG5cdFx0XHQvLyAuLi5saXN0ZW4gZm9yIHVwZGF0ZSBldmVudFxuXHRcdFx0dGhpcy5fbGlzdGVuRm9yS2V5ZG93bkV2ZW50KCk7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQgKiBMaXN0ZW4gZm9yIGtleSBkb3duIGV2ZW50IC0gbGlzdGVuIGZvciBrZXkgZG93biBldmVudCBkdXJpbmcgaW5saW5lIGVkaXQuXG5cdCAqL1xuXHRwcml2YXRlIF9saXN0ZW5Gb3JLZXlkb3duRXZlbnQoKSB7XG5cdFx0Ly8gYWRkIGdsb2JhbCBsaXN0ZW5lciBmb3Iga2V5IGRvd24gZXZlbnRzXG5cdFx0dGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbihcblx0XHRcdCdkb2N1bWVudCcsXG5cdFx0XHQna2V5ZG93bicsXG5cdFx0XHQkZXZlbnQgPT4ge1xuXHRcdFx0XHRzd2l0Y2ggKCRldmVudC5rZXkpIHtcblx0XHRcdFx0XHRjYXNlICdFbnRlcic6IC8vIHVwZGF0ZSBkYXRhIG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5pbmxpbmVFZGl0VXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdFc2NhcGUnOiAvLyBjYW5jZWxcblx0XHRcdFx0XHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cdC8qKlxuXHQgKiBJbmxpbmUgZWRpdCB1cGRhdGUgLSBhY2NlcHQgY2hhbmdlcyBhbmQgdXBkYXRlIHJvdyB2YWx1ZXMuXG5cdCAqL1xuXHRwdWJsaWMgaW5saW5lRWRpdFVwZGF0ZSgpIHtcblx0XHQvLyBsb29wIHRocm91Z2ggcm93cyB0aGF0IGhhdmUgYmVlbiBlZGl0ZWRcblx0XHRPYmplY3Qua2V5cyh0aGlzLmVkaXRlZFJvd3MpLm1hcChrZXkgPT4ge1xuXHRcdFx0Y29uc3QgUk9XID0gdGhpcy5lZGl0ZWRSb3dzW2tleV0ucm93OyAvLyByb3cgdG8gdXBkYXRlXG5cdFx0XHRjb25zdCBDSEFOR0VTID0gdGhpcy5lZGl0ZWRSb3dzW2tleV0uY2hhbmdlczsgLy8gY2hhbmdlcyB0byB0aGUgcm93XG5cblx0XHRcdC8vIGxvb3AgdGhyb3VnaCBjaGFuZ2VzIGluIHJvd1xuXHRcdFx0T2JqZWN0LmtleXMoQ0hBTkdFUykubWFwKG9iamVjdEtleSA9PiB7XG5cdFx0XHRcdGNvbnN0IG9sZFZhbHVlID0geyAuLi5ST1cgfTtcblx0XHRcdFx0Uk9XW29iamVjdEtleV0gPSBDSEFOR0VTW29iamVjdEtleV0ucmVuZGVyVmFsdWU7IC8vIHVwZGF0ZSBkYXRhIHZhbHVlXG5cdFx0XHRcdHRoaXMudXBkYXRlUm93KFJPVywgb2xkVmFsdWUpOyAvLyB1cGRhdGUgbWV0YSBpbmZvIGZvciByb3cgYW5kIHNlbmQgZXZlbnRcblx0XHRcdFx0Q0hBTkdFU1tvYmplY3RLZXldLmVkaXRlZCA9IGZhbHNlOyAvLyBkaXNhYmxlIGVkaXQgbW9kZVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Ly8gY2xlYXIgcm93cyBtYXJrZWQgYXMgZWRpdGVkIGFzIHRoZSByb3dzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0dGhpcy5lZGl0ZWRSb3dzID0ge307XG5cdFx0Ly8gcmVtb3ZlIGxpc3RlbmVyXG5cdFx0dGhpcy5fc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpO1xuXHR9XG5cdC8qKlxuXHQgKiBJbmxpbmUgZWRpdCBjYW5jZWwgLSBjYW5jZWwgYW5kIHJlc2V0IGlubGluZSBlZGl0cy5cblx0ICovXG5cdHB1YmxpYyBpbmxpbmVFZGl0Q2FuY2VsKHJvdz86IEd0Um93KSB7XG5cdFx0aWYgKHJvdykge1xuXHRcdFx0ZGVsZXRlIHRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXTtcblx0XHRcdC8vIHJlbW92ZSBsaXN0ZW5lclxuXHRcdFx0dGhpcy5fc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGxvb3AgdGhyb3VnaCByb3dzIHRoYXQgaGF2ZSBiZWVuIGVkaXRlZFxuXHRcdE9iamVjdC5rZXlzKHRoaXMuZWRpdGVkUm93cykubWFwKGtleSA9PiB7XG5cdFx0XHRjb25zdCBST1cgPSB0aGlzLmVkaXRlZFJvd3Nba2V5XS5yb3c7IC8vIHJvdyB0byB1cGRhdGVcblx0XHRcdGNvbnN0IENIQU5HRVMgPSB0aGlzLmVkaXRlZFJvd3Nba2V5XS5jaGFuZ2VzOyAvLyBjaGFuZ2VzIHRvIHRoZSByb3dcblxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGNoYW5nZXMgaW4gcm93XG5cdFx0XHRPYmplY3Qua2V5cyhDSEFOR0VTKS5tYXAob2JqZWN0S2V5ID0+IHtcblx0XHRcdFx0Q0hBTkdFU1tvYmplY3RLZXldLnJlbmRlclZhbHVlID0gUk9XW29iamVjdEtleV07IC8vIHJlc2V0IHJlbmRlcmVkIHZhbHVlXG5cdFx0XHRcdENIQU5HRVNbb2JqZWN0S2V5XS5lZGl0ZWQgPSBmYWxzZTsgLy8gZGlzYWJsZSBlZGl0IG1vZGVcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdC8vIGNsZWFyIHJvd3MgbWFya2VkIGFzIGVkaXRlZCBhcyB0aGUgcm93cyBoYXZlIGJlZW4gdXBkYXRlZFxuXHRcdHRoaXMuZWRpdGVkUm93cyA9IHt9O1xuXHRcdC8vIHJlbW92ZSBsaXN0ZW5lclxuXHRcdHRoaXMuX3N0b3BMaXN0ZW5pbmdGb3JLZXlkb3duRXZlbnQoKTtcblx0fVxuXHQvKipcblx0ICogU3RvcCBsaXN0ZW5pbmcgZm9yIGtleSBkb3duIGV2ZW50IC0gc3RvcCBsaXN0ZW5pbmcgZm9yIGtleSBkb3duIGV2ZW50cyBwYXNzZWQgZHVyaW5nIGlubGluZSBlZGl0LlxuXHQgKi9cblx0cHJpdmF0ZSBfc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpIHtcblx0XHRpZiAodGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuZ2xvYmFsSW5saW5lRWRpdExpc3RlbmVyKCk7XG5cdFx0XHR0aGlzLmdsb2JhbElubGluZUVkaXRMaXN0ZW5lciA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGx5IGZpbHRlcihzKS5cblx0ICogQHBhcmFtIGZpbHRlciAtIG9iamVjdCBjb250YWluaW5nIGtleSB2YWx1ZSBwYWlycywgd2hlcmUgdmFsdWUgc2hvdWxkIGJlIGFycmF5IG9mIHZhbHVlcy5cblx0ICovXG5cdHB1YmxpYyBndEFwcGx5RmlsdGVyKGZpbHRlcjogT2JqZWN0KSB7XG5cdFx0dGhpcy5ndEluZm8uZmlsdGVyID0gZmlsdGVyO1xuXHRcdC8vIGdvIHRvIGZpcnN0IHBhZ2Vcblx0XHR0aGlzLmdvVG9QYWdlKDEpO1xuXHRcdHRoaXMudXBkYXRlVG90YWxzKCk7XG5cdH1cblxuXHQvKiogQ2xlYXIvcmVtb3ZlIGFwcGxpZWQgZmlsdGVyKHMpLiAqL1xuXHRwdWJsaWMgZ3RDbGVhckZpbHRlcigpIHtcblx0XHR0aGlzLmd0SW5mby5maWx0ZXIgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xuXHRcdC8vIHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2hcblx0ICogQHBhcmFtIHZhbHVlIC0gc3RyaW5nIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgd29yZHNcblx0ICovXG5cdHB1YmxpYyBndFNlYXJjaCh2YWx1ZTogc3RyaW5nKSB7XG5cdFx0dGhpcy5ndEluZm8uc2VhcmNoVGVybXMgPSB2YWx1ZTtcblx0XHQvLyBhbHdheXMgZ28gdG8gZmlyc3QgcGFnZSB3aGVuIHNlYXJjaGluZ1xuXHRcdHRoaXMuZ29Ub1BhZ2UoMSk7XG5cdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgcm93c1xuXHQgKiBAcGFyYW0gcm93cyAtIHJvd3MgdG8gYWRkXG5cdCAqIEByZXR1cm5zIG5ldyBkYXRhIGFycmF5LlxuXHQgKi9cblx0cHVibGljIGd0QWRkKHJvd3M6IEFycmF5PFI+KTogUmVhZG9ubHlBcnJheTxSPiB7XG5cdFx0dGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGEsIC4uLnJvd3NdO1xuXHRcdHJldHVybiBbLi4udGhpcy5ndERhdGFdO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZSByb3dcblx0ICogQHBhcmFtIG9iamVjdEtleSAtIG9iamVjdCBrZXkgeW91IHdhbnQgdG8gZmluZCBtYXRjaCB3aXRoXG5cdCAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSBkZWxldGVkXG5cdCAqIEBwYXJhbSBtYXRjaCAtIGFsbDogZGVsZXRlIGFsbCBtYXRjaGVzLCBmaXJzdDogZGVsZXRlIGZpcnN0IG1hdGNoIChkZWZhdWx0KVxuXHQgKiBAcmV0dXJucyBuZXcgZGF0YSBhcnJheS5cblx0ICovXG5cdHB1YmxpYyBndERlbGV0ZShcblx0XHRvYmplY3RLZXk6IHN0cmluZyxcblx0XHR2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLFxuXHRcdG1hdGNoOiAnZmlyc3QnIHwgJ2FsbCcgPSAnZmlyc3QnXG5cdCk6IFJlYWRvbmx5QXJyYXk8Uj4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJ2ZpcnN0Jykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmd0RGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGhpcy5ndERhdGFbaV1bb2JqZWN0S2V5XSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5pc1Jvd1NlbGVjdGVkKHRoaXMuZ3REYXRhW2ldKSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b2dnbGVTZWxlY3QodGhpcy5ndERhdGFbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmd0RGF0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0dGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGFdO1xuXHRcdFx0XHRcdGlmIChtYXRjaCA9PT0gJ2ZpcnN0Jykge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAobGV0IGkgPSB0aGlzLmd0RGF0YS5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHRoaXMuZ3REYXRhW2kgLSAxXVtvYmplY3RLZXldID09PSB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLmlzUm93U2VsZWN0ZWQodGhpcy5ndERhdGFbaSAtIDFdKSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b2dnbGVTZWxlY3QodGhpcy5ndERhdGFbaSAtIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5ndERhdGEuc3BsaWNlKGkgLSAxLCAxKTtcblx0XHRcdFx0XHR0aGlzLmd0RGF0YSA9IFsuLi50aGlzLmd0RGF0YV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFsuLi50aGlzLmd0RGF0YV07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIHN0b3JlIHRvIGhvbGQgcHJldmlvdXNseSBsb2FkZWQgcmVjb3Jkcy5cblx0ICogQHBhcmFtIHJlY29yZHMgLSB0b3RhbCBudW1iZXIgb2YgcmVjb3JkcyBpbiBzdG9yZS5cblx0ICogQHBhcmFtIHBlclBhZ2UgLSBob3cgbWFueSByZWNvcmRzIHRvIHNob3cgcGVyIHBhZ2UuXG5cdCAqIEByZXR1cm5zIGEgbmVzdGVkIGFycmF5IHRvIGhvbGQgcmVjb3JkcyBwZXIgcGFnZS5cblx0ICovXG5cdHByaXZhdGUgY3JlYXRlU3RvcmUocmVjb3JkczogbnVtYmVyLCBwZXJQYWdlOiBudW1iZXIpOiBBcnJheTxBcnJheTxhbnk+PiB7XG5cdFx0Y29uc3Qgc3RvcmVzID0gTWF0aC5jZWlsKHJlY29yZHMgLyBwZXJQYWdlKTtcblx0XHRjb25zdCBzdG9yZTogQXJyYXk8QXJyYXk8YW55Pj4gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlczsgaSsrKSB7XG5cdFx0XHRzdG9yZVtpXSA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RvcmU7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIHBsYWNlaG9sZGVycyBmb3Igcm93cyB3aGlsZSBsb2FkaW5nIGRhdGEgZnJvbSBiYWNrLWVuZC5cblx0ICogQHBhcmFtIHBlclBhZ2UgLSBob3cgbWFueSByZWNvcmRzIHRvIHNob3cgcGVyIHBhZ2UuXG5cdCAqIEByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgZW1wdHkgcmVjb3JkcyB0byBiZSBwcmVzZW50ZWQgd2hpbGUgZmV0Y2hpbmcgcmVhbCBkYXRhLlxuXHQgKi9cblx0cHJpdmF0ZSBsb2FkaW5nQ29udGVudChwZXJQYWdlOiBudW1iZXIpIHtcblx0XHQvLyBjcmVhdGUgcm93IG9iamVjdFxuXHRcdGNvbnN0IHJvd09iamVjdDogT2JqZWN0ID0ge1xuXHRcdFx0JCRsb2FkaW5nOiB0cnVlXG5cdFx0fTtcblx0XHRsZXQgb3JkZXIgPSAwO1xuXG5cdFx0Ly8gc29ydCBzZXR0aW5ncyBieSBjb2x1bW4gb3JkZXJcblx0XHR0aGlzLl9ndFNldHRpbmdzLnNvcnQodGhpcy5nZXRDb2x1bW5PcmRlcik7XG5cblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIHNldHRpbmdzIG9iamVjdHMuLi5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHNldHRpbmcgPSB0aGlzLl9ndFNldHRpbmdzW2ldO1xuXG5cdFx0XHQvLyAuLi5pZiBjb2x1bW4gaXMgdmlzaWJsZSBhbmQgZW5hYmxlZC4uLlxuXHRcdFx0aWYgKHNldHRpbmcudmlzaWJsZSAhPT0gZmFsc2UgJiYgc2V0dGluZy5lbmFibGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHQvLyAuLi5pZiBmaXJzdCBjb2x1bW4sIHNldCB2YWx1ZSB0byBsb2FkaW5nIHRleHQgb3RoZXJ3aXNlIGxlYXZlIGl0IGVtcHR5XG5cdFx0XHRcdGlmIChvcmRlciA9PT0gMCkge1xuXHRcdFx0XHRcdHJvd09iamVjdFtzZXR0aW5nLm9iamVjdEtleV0gPSB0aGlzLmd0VGV4dHMubG9hZGluZztcblx0XHRcdFx0XHR0aGlzLmxvYWRpbmdQcm9wZXJ0eSA9IHNldHRpbmcub2JqZWN0S2V5O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJvd09iamVjdFtzZXR0aW5nLm9iamVjdEtleV0gPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmRlcisrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cm93T2JqZWN0W3NldHRpbmcub2JqZWN0S2V5XSA9ICcnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBjb250ZW50IHBsYWNlaG9sZGVyXG5cdFx0Y29uc3QgY29udGVudFBsYWNlaG9sZGVyOiBBcnJheTxhbnk+ID0gW107XG5cblx0XHQvLyBjcmVhdGUgZXF1YWwgbnVtYmVyIG9mIHJvd3MgYXMgcm93cyBwZXIgcGFnZVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGVyUGFnZTsgaSsrKSB7XG5cdFx0XHQvLyAuLi5hZGQgdGVtcG9yYXJ5IHJvdyBvYmplY3Rcblx0XHRcdGNvbnRlbnRQbGFjZWhvbGRlci5wdXNoKHJvd09iamVjdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjb250ZW50UGxhY2Vob2xkZXI7XG5cdH1cblxuXHQvLyBUT0RPOiBtb3ZlIHRvIGhlbHBlciBmdW5jdGlvbnNcblx0LyoqIFNvcnQgYnkgc29ydCBvcmRlciAqL1xuXHRwcml2YXRlIGdldFNvcnRPcmRlciA9IGZ1bmN0aW9uKGE6IEd0Q29uZmlnU2V0dGluZywgYjogR3RDb25maWdTZXR0aW5nKSB7XG5cdFx0aWYgKGEuc29ydE9yZGVyIDwgYi5zb3J0T3JkZXIpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0aWYgKGEuc29ydE9yZGVyID4gYi5zb3J0T3JkZXIgfHwgdHlwZW9mIGEuc29ydE9yZGVyID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdC8vIFRPRE86IG1vdmUgdG8gaGVscGVyIGZ1bmN0aW9uc1xuXHQvKiogU29ydCBieSBjb2x1bW4gb3JkZXIgKi9cblx0cHJpdmF0ZSBnZXRDb2x1bW5PcmRlciA9IGZ1bmN0aW9uKGE6IEd0Q29uZmlnU2V0dGluZywgYjogR3RDb25maWdTZXR0aW5nKSB7XG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHRpZiAoYS5jb2x1bW5PcmRlciA8IGIuY29sdW1uT3JkZXIpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPiBiLmNvbHVtbk9yZGVyKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cblx0Ly8gVE9ETzogbW92ZSB0byBoZWxwZXIgZnVuY3Rpb25zXG5cdC8qKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgZGF0YSAqL1xuXHRwcml2YXRlIGNsb25lRGVlcCA9IGZ1bmN0aW9uKG86IGFueSkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcblx0fTtcblxuXHQvKiogRXhwb3J0IGRhdGEgYXMgQ1NWXG5cdCAqIEBwYXJhbSBmaWxlTmFtZSAtIG9wdGlvbmFsIGZpbGUgbmFtZSAob3ZlcnJpZGVzIGRlZmF1bHQgZmlsZSBuYW1lKS5cblx0ICogQHBhcmFtIHVzZUJPTSAtIHVzZSBCT00gKGJ5dGUgb3JkZXIgbWFya2VyKS5cblx0ICovXG5cdHB1YmxpYyBleHBvcnRDU1YoZmlsZU5hbWU/OiBzdHJpbmcsIHVzZUJPTTogYm9vbGVhbiA9IGZhbHNlKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YS5leHBvcnREYXRhO1xuXHRcdGxldCBjc3YgPSAnJztcblx0XHRjb25zdCBCT00gPSAnXFx1RkVGRic7XG5cblx0XHQvLyBjc3YgZXhwb3J0IGhlYWRlcnNcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9ndFNldHRpbmdzW2ldLmV4cG9ydCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Y3N2ICs9IHRoaXMuZ2V0UHJvcGVydHkodGhpcy5fZ3RGaWVsZHMsIHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5KVxuXHRcdFx0XHRcdC5uYW1lO1xuXG5cdFx0XHRcdGlmIChpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0Y3N2ICs9IHRoaXMuX2d0T3B0aW9ucy5jc3ZEZWxpbWl0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjc3YgZXhwb3J0IGJvZHlcblx0XHRkYXRhLmZvckVhY2gocm93ID0+IHtcblx0XHRcdGNzdiArPSAnXFxuJztcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGhpcy5fZ3RTZXR0aW5nc1tpXS5leHBvcnQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0IGZpZWxkIHNldHRpbmdzXG5cdFx0XHRcdFx0Y29uc3QgZmllbGRTZXR0aW5nID0gdGhpcy5nZXRQcm9wZXJ0eShcblx0XHRcdFx0XHRcdHRoaXMuX2d0RmllbGRzLFxuXHRcdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXlcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IGV4cG9ydCB2YWx1ZSwgaWYgZXhwb3J0IGZ1bmN0aW9uIGlzIGRlZmluZWQgdXNlIGl0IG90aGVyd2lzZSBjaGVjayBmb3IgdmFsdWUgZnVuY3Rpb24gYW5kIGFzIGEgbGFzdCByZXNvcnQgZXhwb3J0IHJhdyBkYXRhXG5cdFx0XHRcdFx0bGV0IGV4cG9ydFZhbHVlOiBzdHJpbmcgPVxuXHRcdFx0XHRcdFx0ZmllbGRTZXR0aW5nLmV4cG9ydCAmJiB0eXBlb2YgZmllbGRTZXR0aW5nLmV4cG9ydCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0XHQ/IGZpZWxkU2V0dGluZy5leHBvcnQocm93KVxuXHRcdFx0XHRcdFx0XHQ6IGZpZWxkU2V0dGluZy52YWx1ZSAmJiB0eXBlb2YgZmllbGRTZXR0aW5nLnZhbHVlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHRcdFx0PyBmaWVsZFNldHRpbmcudmFsdWUocm93KVxuXHRcdFx0XHRcdFx0XHRcdDogcm93W3RoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5XTtcblxuXHRcdFx0XHRcdC8vIGVzY2FwZSBleHBvcnQgdmFsdWUgdXNpbmcgZG91YmxlIHF1b3RlcyAoXCIpIGlmIGV4cG9ydCB2YWx1ZSBjb250YWlucyBkZWxpbWl0ZXJcblx0XHRcdFx0XHRleHBvcnRWYWx1ZSA9XG5cdFx0XHRcdFx0XHR0eXBlb2YgZXhwb3J0VmFsdWUgPT09ICdzdHJpbmcnICYmXG5cdFx0XHRcdFx0XHRleHBvcnRWYWx1ZS5pbmRleE9mKHRoaXMuX2d0T3B0aW9ucy5jc3ZEZWxpbWl0ZXIpICE9PSAtMVxuXHRcdFx0XHRcdFx0XHQ/ICdcIicgKyBleHBvcnRWYWx1ZSArICdcIidcblx0XHRcdFx0XHRcdFx0OiBleHBvcnRWYWx1ZTtcblxuXHRcdFx0XHRcdGNzdiArPSBleHBvcnRWYWx1ZTtcblx0XHRcdFx0XHRpZiAoaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0Y3N2ICs9IHRoaXMuX2d0T3B0aW9ucy5jc3ZEZWxpbWl0ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjb25zdCBibG9iID0gbmV3IEJsb2IoWyh1c2VCT00gPyBCT00gOiAnJykgKyBjc3ZdLCB7XG5cdFx0XHR0eXBlOiAndGV4dC9jc3Y7Y2hhcnNldD11dGYtOCdcblx0XHR9KTtcblxuXHRcdGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcblx0XHRcdG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKFxuXHRcdFx0XHRibG9iLFxuXHRcdFx0XHRmaWxlTmFtZSA/IGZpbGVOYW1lICsgJy5jc3YnIDogdGhpcy5ndFRleHRzLmNzdkRvd25sb2FkICsgJy5jc3YnXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdFx0bGluay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcblx0XHRcdGlmIChsaW5rLmRvd25sb2FkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bGluay5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0J2hyZWYnLFxuXHRcdFx0XHRcdCdkYXRhOnRleHQvY3N2O2NoYXJzZXQ9dXRmLTgsJyArXG5cdFx0XHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoKHVzZUJPTSA/IEJPTSA6ICcnKSArIGNzdilcblx0XHRcdFx0KTsgLy8gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG5cdFx0XHRcdGxpbmsuc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdCdkb3dubG9hZCcsXG5cdFx0XHRcdFx0ZmlsZU5hbWUgPyBmaWxlTmFtZSArICcuY3N2JyA6IHRoaXMuZ3RUZXh0cy5jc3ZEb3dubG9hZCArICcuY3N2J1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuXHRcdFx0XHRsaW5rLmNsaWNrKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjc3YgPSAnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgKyAodXNlQk9NID8gQk9NIDogJycpICsgY3N2O1xuXHRcdFx0XHR3aW5kb3cub3BlbihlbmNvZGVVUklDb21wb25lbnQoY3N2KSk7XG5cdFx0XHR9XG5cdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuXHRcdH1cblxuXHRcdC8vIGVtaXQgZXhwb3J0IGV2ZW50XG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LWV4cG9ydGVkLWNzdicsXG5cdFx0XHR2YWx1ZTogZmlsZU5hbWUgPyBmaWxlTmFtZSA6IHRoaXMuZ3RUZXh0cy5jc3ZEb3dubG9hZCArICcuY3N2J1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqIFJldHVybiBwcm9wZXJ0eSAqL1xuXHRwcml2YXRlIGdldFByb3BlcnR5ID0gZnVuY3Rpb24oYXJyYXk6IEFycmF5PGFueT4sIGtleTogc3RyaW5nKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycmF5W2ldLm9iamVjdEtleSA9PT0ga2V5KSB7XG5cdFx0XHRcdHJldHVybiBhcnJheVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cHJpdmF0ZSByZXN0cnVjdHVyZVNvcnRpbmcgPSBmdW5jdGlvbigpIHtcblx0XHQvKiogQ2hlY2sgYW5kIHN0b3JlIHNvcnQgb3JkZXIgdXBvbiBpbml0aWFsaXphdGlvbi5cblx0XHQgKiAgVGhpcyBpcyBkb25lIGJ5IGNoZWNraW5nIHNvcnQgcHJvcGVydGllcyBpbiB0aGUgc2V0dGluZ3MgYXJyYXkgb2YgdGhlIHRhYmxlLCBpZiBubyBzb3J0aW5nIGlzIGRlZmluZWRcblx0XHQgKiAgd2UnbGwgc29ydCB0aGUgZGF0YSBieSB0aGUgZmlyc3QgdmlzaWJsZSBhbmQgZW5hYmxlZCBjb2x1bW4gaW4gdGhlIHRhYmxlKGFzY2VuZGluZykuIFBsZWFzZSBub3RlIHRoYXQgYWN0dWFsbHlcblx0XHQgKiAgc29ydGluZyBoYXZlIHRvIGJlIGRvbmUgc2VydmVyIHNpZGUgd2hlbiBsYXp5IGxvYWRpbmcgZGF0YSBmb3Igb2J2aW91cyByZWFzb25zLiAgKi9cblx0XHQvLyBjcmVhdGUgc29ydGluZyBhcnJheVxuXHRcdGNvbnN0IHNvcnRpbmcgPSBbXTtcblx0XHRpZiAodGhpcy5fZ3RTZXR0aW5ncykge1xuXHRcdFx0Ly8gLi4uc29ydCBzZXR0aW5ncyBieSBzb3J0IG9yZGVyXG5cdFx0XHR0aGlzLl9ndFNldHRpbmdzLnNvcnQodGhpcy5nZXRTb3J0T3JkZXIpO1xuXG5cdFx0XHQvLyAuLi5sb29wIHRocm91Z2ggc2V0dGluZ3Ncblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzZXR0aW5nID0gdGhpcy5fZ3RTZXR0aW5nc1tpXTtcblxuXHRcdFx0XHQvLyAuLi5pZiBzb3J0ZWQgYXNjZW5kaW5nLi4uXG5cdFx0XHRcdGlmIChzZXR0aW5nLnNvcnQgPT09ICdhc2MnKSB7XG5cdFx0XHRcdFx0Ly8gLi4uIGFkZCB0byBzb3J0aW5nXG5cdFx0XHRcdFx0c29ydGluZy5wdXNoKHNldHRpbmcub2JqZWN0S2V5KTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZXR0aW5nLnNvcnQgPT09ICdkZXNjJykge1xuXHRcdFx0XHRcdC8qIC4uLmVsc2UgaWYgc29ydGVkIGRlc2NlbmRpbmcuLi4gKi8gLy8gLi4uIGFkZCB0byBzb3J0aW5nXG5cdFx0XHRcdFx0c29ydGluZy5wdXNoKCctJyArIHNldHRpbmcub2JqZWN0S2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gLi4uaWYgbm8gc29ydGluZyBhcHBsaWVkLi4uXG5cdFx0XHRpZiAoc29ydGluZy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0c29ydGluZy5wdXNoKCckJGd0Um93SWQnKTtcblx0XHRcdFx0LyovLyAuLi5zb3J0IHNldHRpbmdzIGJ5IGNvbHVtbiBvcmRlclxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzLnNvcnQodGhpcy5nZXRDb2x1bW5PcmRlcik7XG5cblx0XHRcdFx0Ly8gLi4ubG9vcCB0aHJvdWdoIHNldHRpbmdzXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHNldHRpbmcgPSB0aGlzLl9ndFNldHRpbmdzW2ldO1xuXG5cdFx0XHRcdFx0Ly8gLi4uaWYgY29sdW1uIGlzIGVuYWJsZWQgYW5kIHZpc2libGUuLi5cblx0XHRcdFx0XHRpZiAoc2V0dGluZy5lbmFibGVkICE9PSBmYWxzZSAmJiBzZXR0aW5nLnZpc2libGUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5hZGQgZmlyc3QgbWF0Y2ggYW5kIGV4aXQgZnVuY3Rpb25cblx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyID0gW3RoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5XTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0qL1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLnNvcnRPcmRlci5sZW5ndGggPT09IDApIHtcblx0XHRcdHRoaXMuc29ydE9yZGVyID0gc29ydGluZztcblx0XHR9XG5cdH07XG5cblx0bmdPbkluaXQoKSB7XG5cdFx0Ly8gaWYgbnVtYmVyIG9mIHJvdyB0byBkaXNwbGF5IGZyb20gc3RhcnQgaXMgc2V0IHRvIG51bGwgb3IgMC4uLlxuXHRcdGlmICghdGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzKSB7XG5cdFx0XHQvLyAuLi5jaGFuZ2Ugcm93IGxlbmd0aFxuXHRcdFx0dGhpcy5jaGFuZ2VSb3dMZW5ndGgodGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzKTtcblx0XHR9XG5cdFx0dGhpcy5yZXN0cnVjdHVyZVNvcnRpbmcoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiAgRXh0ZW5kIG9iamVjdCBmdW5jdGlvbi5cblx0ICovXG5cdHByaXZhdGUgZXh0ZW5kID0gZnVuY3Rpb24oYTogT2JqZWN0LCBiOiBPYmplY3QpIHtcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBiKSB7XG5cdFx0XHRpZiAoYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdGFba2V5XSA9IGJba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGE7XG5cdH07XG5cblx0bmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuXHRcdC8vIGlmIGd0IHRleHRzIGhhdmUgY2hhbmdlZC4uLlxuXHRcdGlmIChjaGFuZ2VzWydndFRleHRzJ10pIHtcblx0XHRcdC8vIC4uLmV4dGVuZCBndE9wdGlvbnMgZGVmYXVsdCB2YWx1ZXMgd2l0aCB2YWx1ZXMgcGFzc2VkIGludG8gY29tcG9uZW50XG5cdFx0XHR0aGlzLmd0VGV4dHMgPSA8R3RUZXh0cz50aGlzLmV4dGVuZCh0aGlzLmd0RGVmYXVsdFRleHRzLCB0aGlzLmd0VGV4dHMpO1xuXHRcdH1cblxuXHRcdC8vIGlmIGxhenkgbG9hZGluZyBkYXRhIGFuZCBwYWdpbmcgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlLi4uXG5cdFx0aWYgKHRoaXMuZ3RPcHRpb25zLmxhenlMb2FkICYmIHRoaXMuZ3RJbmZvKSB7XG5cdFx0XHQvLyAuLi5jYWxjdWxhdGUgdG90YWwgbnVtYmVyIG9mIHBhZ2VzXG5cdFx0XHR0aGlzLmd0SW5mby5wYWdlVG90YWwgPSBNYXRoLmNlaWwoXG5cdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaCAvIHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gLi4uZGVjbGFyZSBzdG9yZSBwb3NpdGlvblxuXHRcdFx0Y29uc3Qgc3RvcmVQb3NpdGlvbiA9IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMTtcblxuXHRcdFx0Ly8gLi4uYW5kIGlmIHN0b3JlIGlzIGVtcHR5IG9yIHBhZ2UgbGVuZ3RoIGhhcyBjaGFuZ2VkLi4uXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMuc3RvcmUubGVuZ3RoID09PSAwIHx8XG5cdFx0XHRcdHRoaXMuc3RvcmVbMF0ubGVuZ3RoICE9PSB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdCkge1xuXHRcdFx0XHQvLyAuLi5jcmVhdGUgc3RvcmVcblx0XHRcdFx0dGhpcy5zdG9yZSA9IHRoaXMuY3JlYXRlU3RvcmUoXG5cdFx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoLFxuXHRcdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAuLi5zdG9yZSByZXRyaWV2ZWQgZGF0YSBpbiBzdG9yZSBhdCBzdG9yZSBwb3NpdGlvblxuXHRcdFx0dGhpcy5zdG9yZVtzdG9yZVBvc2l0aW9uXSA9IHRoaXMuZ3REYXRhO1xuXHRcdFx0dGhpcy5ndEluZm8udmlzaWJsZVJlY29yZHMgPSBbLi4udGhpcy5ndERhdGFdOyAvLyBhZGQgdmlzaWJsZSByb3dzXG5cblx0XHRcdC8vIHJlcGxhY2UgZGF0YSB3aXRoIHN0b3JlXG5cdFx0XHR0aGlzLl9ndERhdGEgPSB0aGlzLnN0b3JlO1xuXHRcdFx0dGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cdFx0XHR0aGlzLnVwZGF0ZVJlY29yZFJhbmdlKCk7XG5cdFx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRcdG5hbWU6ICdndC1pbmZvJyxcblx0XHRcdFx0dmFsdWU6IHRoaXMuZ3RJbmZvXG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dGhpcy5fZ3REYXRhICYmXG5cdFx0XHR0aGlzLl9ndERhdGEubGVuZ3RoID49IDAgJiZcblx0XHRcdGNoYW5nZXNbJ2d0RGF0YSddICYmXG5cdFx0XHRjaGFuZ2VzWydndERhdGEnXS5wcmV2aW91c1ZhbHVlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10gJiZcblx0XHRcdGNoYW5nZXNbJ2d0RGF0YSddLmZpcnN0Q2hhbmdlICYmXG5cdFx0XHR0aGlzLl9ndERhdGEgJiZcblx0XHRcdHRoaXMuX2d0RGF0YS5sZW5ndGggPiAwXG5cdFx0KSB7XG5cdFx0XHR0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHR0cmFja0J5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogR3RSb3cpIHtcblx0XHRyZXR1cm4gaXRlbS4kJGd0Um93SWQ7XG5cdH1cblxuXHR0cmFja0J5Q29sdW1uRm4oaW5kZXg6IG51bWJlciwgaXRlbTogR3RDb25maWdGaWVsZDxhbnksIGFueT4pIHtcblx0XHRyZXR1cm4gaXRlbS5vYmplY3RLZXk7XG5cdH1cblxuXHRuZ09uRGVzdHJveSgpIHtcblx0XHQvLyByZW1vdmUgbGlzdGVuZXJcblx0XHR0aGlzLl9zdG9wTGlzdGVuaW5nRm9yS2V5ZG93bkV2ZW50KCk7XG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0Q2hhbmdlRGV0ZWN0b3JSZWYsXG5cdEFmdGVyVmlld0NoZWNrZWQsXG5cdElucHV0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR2VuZXJpY1RhYmxlQ29tcG9uZW50IH0gZnJvbSAnLi9nZW5lcmljLXRhYmxlLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogJ2d0LXRhYmxlLWluZm8nLFxuXHR0ZW1wbGF0ZTogYDxzcGFuICpuZ0lmPVwiZ2VuZXJpY1RhYmxlLmd0SW5mb1wiPnt7KGN1c3RvbVRleHQ/IGN1c3RvbVRleHQ6Z2VuZXJpY1RhYmxlLmd0VGV4dHMpIHwgZ3RUYWJsZUluZm86XG5cdFx0Z2VuZXJpY1RhYmxlLmd0SW5mbzpcblx0XHRnZW5lcmljVGFibGUuZ3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaDpcblx0XHRnZW5lcmljVGFibGUuZ3RJbmZvLnJlY29yZEZyb206XG5cdFx0Z2VuZXJpY1RhYmxlLmd0SW5mby5yZWNvcmRUbzpcblx0XHRnZW5lcmljVGFibGUuZ3RJbmZvLnJlY29yZHNBbGw6XG5cdFx0Z2VuZXJpY1RhYmxlLmd0VGV4dHMubG9hZGluZzpcblx0XHRnZW5lcmljVGFibGUuZ3RUZXh0cy50YWJsZUluZm9BZnRlclNlYXJjaH19PC9zcGFuPmBcbn0pXG5leHBvcnQgY2xhc3MgR3RUYWJsZUluZm9Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkIHtcblx0QElucHV0KCkgZ2VuZXJpY1RhYmxlOiBHZW5lcmljVGFibGVDb21wb25lbnQ8YW55LCBhbnk+O1xuXHRASW5wdXQoKSBjdXN0b21UZXh0OiBzdHJpbmc7XG5cblx0Y29uc3RydWN0b3IocHJpdmF0ZSBfY2hhbmdlRGV0ZWN0aW9uUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuXHRuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG5cdFx0dGhpcy5fY2hhbmdlRGV0ZWN0aW9uUmVmLmRldGVjdENoYW5nZXMoKTtcblx0fVxufVxuaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3RJbmZvcm1hdGlvbiB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtaW5mb3JtYXRpb24nO1xuaW1wb3J0IHsgR3RUZXh0cyB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtdGV4dHMnO1xuXG5AUGlwZSh7XG5cdG5hbWU6ICdndFRhYmxlSW5mbydcbn0pXG5leHBvcnQgY2xhc3MgVGFibGVJbmZvUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHR0cmFuc2Zvcm0oXG5cdFx0dGV4dHM6IEd0VGV4dHMgfCBzdHJpbmcsXG5cdFx0a2V5czogR3RJbmZvcm1hdGlvbixcblx0XHRyZWNvcmRzQWZ0ZXJTZWFyY2g6IG51bWJlcixcblx0XHRyZWNvcmRGcm9tOiBudW1iZXIsXG5cdFx0cmVjb3JkVG86IG51bWJlcixcblx0XHRyZWNvcmRzQWxsOiBudW1iZXIsXG5cdFx0bG9hZGluZzogc3RyaW5nLFxuXHRcdHRhYmxlSW5mb0FmdGVyU2VhcmNoOiBzdHJpbmdcblx0KTogc3RyaW5nIHtcblx0XHRsZXQgdGV4dCA9IHR5cGVvZiB0ZXh0cyA9PT0gJ29iamVjdCcgPyB0ZXh0cy50YWJsZUluZm8gOiAnJztcblx0XHRpZiAoa2V5cy5yZWNvcmRzQWZ0ZXJTZWFyY2ggIT09IGtleXMucmVjb3Jkc0FsbCkge1xuXHRcdFx0dGV4dCA9IHR5cGVvZiB0ZXh0cyA9PT0gJ29iamVjdCcgPyB0ZXh0cy50YWJsZUluZm9BZnRlclNlYXJjaCA6ICcnO1xuXHRcdH1cblx0XHRmb3IgKGNvbnN0IGtleSBpbiBrZXlzKSB7XG5cdFx0XHRpZiAoa2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdGNvbnN0IHNlYXJjaFN0cmluZyA9IG5ldyBSZWdFeHAoJyMnICsga2V5LCAnZycpO1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKHNlYXJjaFN0cmluZywga2V5c1trZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRleHQ7XG5cdH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEdlbmVyaWNUYWJsZUNvbXBvbmVudCB9IGZyb20gJy4vZ2VuZXJpYy10YWJsZS5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdndC1wYWdpbmF0aW9uJyxcblx0dGVtcGxhdGU6IGA8bmF2IGNsYXNzPVwiZ3QtcGFnaW5hdGlvblwiIGFyaWEtbGFiZWw9XCJUYWJsZSBuYXZpZ2F0aW9uXCIgKm5nSWY9XCJnZW5lcmljVGFibGUgJiYgZ2VuZXJpY1RhYmxlLmd0SW5mbyAmJiByZWFkeSAmJiBnZW5lcmljVGFibGUuZ3REYXRhPy5sZW5ndGggPiAwXCIgW25nQ2xhc3NdPVwieyduby1kYXRhJzpnZW5lcmljVGFibGUuZ3RJbmZvLnBhZ2VUb3RhbCA9PT0gMH1cIj5cbiAgPHVsIGNsYXNzPVwicGFnaW5hdGlvblwiIFtuZ0NsYXNzXT1cImd0Q2xhc3Nlc1wiPlxuICAgIDxsaSBjbGFzcz1cInBhZ2UtaXRlbVwiIFtuZ0NsYXNzXT1cInsnZGlzYWJsZWQnIDogZ2VuZXJpY1RhYmxlLmd0SW5mby5wYWdlQ3VycmVudCA9PT0gMSB8fCBnZW5lcmljVGFibGUubG9hZGluZyB9XCI+PGEgY2xhc3M9XCJwYWdlLWxpbmtcIiBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApO1wiIChjbGljayk9XCJnZW5lcmljVGFibGUuZ3RJbmZvLnBhZ2VDdXJyZW50ID4gMSAmJiBnZW5lcmljVGFibGUucHJldmlvdXNQYWdlKClcIiBbYXR0ci5hcmlhLWxhYmVsXT1cImdlbmVyaWNUYWJsZS5ndFRleHRzLnBhZ2luYXRlUHJldmlvdXNcIj48c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mbGFxdW87PC9zcGFuPjxzcGFuIGNsYXNzPVwic3Itb25seVwiPnt7Z2VuZXJpY1RhYmxlLmd0VGV4dHMucGFnaW5hdGVQcmV2aW91c319PC9zcGFuPjwvYT48L2xpPlxuICAgIDxsaSBjbGFzcz1cInBhZ2UtaXRlbVwiIFtuZ0NsYXNzXT1cInsnZGlzYWJsZWQnIDogZ2VuZXJpY1RhYmxlLmxvYWRpbmcgJiYgZ2VuZXJpY1RhYmxlLmd0SW5mby5wYWdlQ3VycmVudCAhPT0gcGFnZSwgJ2FjdGl2ZScgOiBnZW5lcmljVGFibGUuZ3RJbmZvLnBhZ2VDdXJyZW50ID09PSBwYWdlIH1cIiAqbmdGb3I9XCJsZXQgcGFnZSBvZiBnZW5lcmljVGFibGUuZ3RJbmZvLnBhZ2VUb3RhbCB8IGd0UGFnaW5hdGlvblBpcGU6Z2VuZXJpY1RhYmxlLmd0SW5mby5wYWdlQ3VycmVudFwiPjxhIGNsYXNzPVwicGFnZS1saW5rXCIgW3RhYmluZGV4XT1cInBhZ2UgPT09IHRydWUgPyAtMTowXCIgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKTtcIiAoY2xpY2spPVwicGFnZSA9PT0gdHJ1ZSA/ICcnOmdlbmVyaWNUYWJsZS5nb1RvUGFnZShwYWdlKVwiPnt7cGFnZSA9PT0gdHJ1ZSA/ICcmaGVsbGlwOyc6cGFnZX19PC9hPjwvbGk+XG4gICAgPGxpIGNsYXNzPVwicGFnZS1pdGVtXCIgW25nQ2xhc3NdPVwieydkaXNhYmxlZCcgOiBnZW5lcmljVGFibGUuZ3RJbmZvLnBhZ2VDdXJyZW50ID09PSBnZW5lcmljVGFibGUuZ3RJbmZvLnBhZ2VUb3RhbCB8fCBnZW5lcmljVGFibGUubG9hZGluZyB9XCI+PGEgY2xhc3M9XCJwYWdlLWxpbmsgZ3QtbGlua1wiIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMCk7XCIgKGNsaWNrKT1cImdlbmVyaWNUYWJsZS5ndEluZm8ucGFnZUN1cnJlbnQgIT09IGdlbmVyaWNUYWJsZS5ndEluZm8ucGFnZVRvdGFsICYmIGdlbmVyaWNUYWJsZS5uZXh0UGFnZSgpXCIgW2F0dHIuYXJpYS1sYWJlbF09XCJnZW5lcmljVGFibGUuZ3RUZXh0cy5wYWdpbmF0ZU5leHRcIj48c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mcmFxdW87PC9zcGFuPjxzcGFuIGNsYXNzPVwic3Itb25seVwiPnt7Z2VuZXJpY1RhYmxlLmd0VGV4dHMucGFnaW5hdGVOZXh0fX08L3NwYW4+PC9hPjwvbGk+XG4gIDwvdWw+XG4gIDwvbmF2PlxuICAgIGAsXG5cdHN0eWxlczogWycuZ3QtbGluayB7Y3Vyc29yOiBwb2ludGVyO30nXVxufSlcbmV4cG9ydCBjbGFzcyBHdFBhZ2luYXRpb25Db21wb25lbnQge1xuXHRnZXQgZ2VuZXJpY1RhYmxlKCk6IEdlbmVyaWNUYWJsZUNvbXBvbmVudDxhbnksIGFueT4ge1xuXHRcdHJldHVybiB0aGlzLl9nZW5lcmljVGFibGU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgZ2VuZXJpY1RhYmxlKHZhbHVlOiBHZW5lcmljVGFibGVDb21wb25lbnQ8YW55LCBhbnk+KSB7XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHR2YWx1ZS5ndEV2ZW50LnN1YnNjcmliZSgocmVzOiBhbnkpID0+IHtcblx0XHRcdFx0aWYgKHJlcy5uYW1lID09PSAnZ3QtaW5mbycgJiYgcmVzLnZhbHVlLnBhZ2VUb3RhbCA+IDApIHtcblx0XHRcdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHRoaXMuX2dlbmVyaWNUYWJsZSA9IHZhbHVlO1xuXHR9XG5cblx0cHJpdmF0ZSBfZ2VuZXJpY1RhYmxlOiBHZW5lcmljVGFibGVDb21wb25lbnQ8YW55LCBhbnk+O1xuXHRASW5wdXQoKSBndENsYXNzZXM6IHN0cmluZztcblx0cHVibGljIHJlYWR5ID0gZmFsc2U7XG59XG5pbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0UGFnaW5hdGlvblBpcGUnXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2luYXRpb25QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdHRyYW5zZm9ybSh0b3RhbFBhZ2VzOiBudW1iZXIsIGN1cnJlbnRQYWdlOiBudW1iZXIpOiBBcnJheTxhbnk+IHtcblx0XHRpZiAodG90YWxQYWdlcyA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIFsxXTtcblx0XHR9XG5cdFx0Y29uc3QgcGFnaW5hdGlvbjogQXJyYXk8YW55PiA9IFtdOyAvLyBjcmVhdGUgbmV3IGVtcHR5IGFycmF5IGZvciBwYWdpbmF0aW9uXG5cdFx0Y29uc3Qgc2libGluZ3MgPSAyOyAvLyBzaWJsaW5nIGVsZW1lbnRzIGllLiBudW1iZXIgb2YgZWxlbWVudHMgb24gZWFjaCBzaWRlIG9mIGN1cnJlbnQgcGFnZVxuXHRcdGNvbnN0IHBhZ2luYXRpb25MZW5ndGggPVxuXHRcdFx0dG90YWxQYWdlcyA8IHNpYmxpbmdzICogMiArIDEgPyB0b3RhbFBhZ2VzIDogc2libGluZ3MgKiAyICsgMTsgLy8gbnVtYmVyIG9mIGVsZW1lbnRzIGluIHBhZ2luYXRpb24gYXJyYXlcblx0XHRjb25zdCBzdGFydCA9IGN1cnJlbnRQYWdlIDw9IHNpYmxpbmdzID8gMSA6IGN1cnJlbnRQYWdlIC0gc2libGluZ3M7IC8vIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciBhcnJheVxuXHRcdGNvbnN0IG1vZGlmaWVyID1cblx0XHRcdHRvdGFsUGFnZXMgLSAoY3VycmVudFBhZ2UgKyBzaWJsaW5ncykgPD0gMFxuXHRcdFx0XHQ/IHRvdGFsUGFnZXMgLSAoY3VycmVudFBhZ2UgKyBzaWJsaW5ncylcblx0XHRcdFx0OiAwOyAvLyBtb2RpZmllciBmb3IgcGFnaW5hdGlvbiB2YWx1ZXNcblx0XHRjb25zdCBtb2RpZmllZFBvc2l0aW9uID0gc3RhcnQgKyBtb2RpZmllciA8PSAwID8gMSA6IHN0YXJ0ICsgbW9kaWZpZXI7XG5cblx0XHQvLyBwdXNoIHBhZ2VzIHRvIHBhZ2luYXRpb24gYXJyYXlcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2luYXRpb25MZW5ndGg7IGkrKykge1xuXHRcdFx0cGFnaW5hdGlvbi5wdXNoKG1vZGlmaWVkUG9zaXRpb24gKyBpKTtcblx0XHR9XG5cblx0XHQvLyBpZiBmaXJzdCBwYWdlIGlzIG5vdCBpbmNsdWRlZCBpbiBwYWdpbmF0aW9uLi4uXG5cdFx0aWYgKHBhZ2luYXRpb24uaW5kZXhPZigxKSA9PT0gLTEpIHtcblx0XHRcdC8vIC4uLmNoZWNrIGlmIHNlY29uZCBwYWdlIGlzIGluIHBhZ2luYXRpb24uLi5cblx0XHRcdGlmIChwYWdpbmF0aW9uLmluZGV4T2YoMikgPT09IC0xKSB7XG5cdFx0XHRcdC8vIC4uLmlmIG5vdCBjaGVjayBpZiB0b3RhbCBudW1iZXIgb2YgcGFnZXMgZXF1YWxzIHNldmVuIGFuZCBudW1iZXIgb2Ygc2libGluZ3MgYXJlIHR3by4uLlxuXHRcdFx0XHRpZiAodG90YWxQYWdlcyA9PT0gNyAmJiBzaWJsaW5ncyA9PT0gMikge1xuXHRcdFx0XHRcdC8vIC4uLmFkZCBzZWNvbmQgcGFnZSBhbmQgZG9uJ3QgY29udmVydCBwYWdlIG51bWJlciB0byBlbGxpcHNpc1xuXHRcdFx0XHRcdHBhZ2luYXRpb24udW5zaGlmdCgyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIHVzZSB0aGlzIHBsYWNlaG9sZGVyIGZvciBlbGxpcHNpcyBpbnN0ZWFkIG9mIGFjdHVhbCBwYWdlIG51bWJlclxuXHRcdFx0XHRcdHBhZ2luYXRpb25bMF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyAuLi5hZGQgZmlyc3QgcGFnZSBhcyBmaXJzdCBhcnJheSBpdGVtXG5cdFx0XHRwYWdpbmF0aW9uLnVuc2hpZnQoMSk7XG5cdFx0fSBlbHNlIGlmICh0b3RhbFBhZ2VzID4gcGFnaW5hdGlvbkxlbmd0aCkge1xuXHRcdFx0Ly8gaWYgZmlyc3QgcGFnZSBpcyBpbmNsdWRlZCBhZGQgZXh0cmEgcGFnZSB0byBrZWVwIG51bWJlciBvZiBpdGVtcyBjb25zaXN0ZW50XG5cdFx0XHRwYWdpbmF0aW9uLnNwbGljZShwYWdpbmF0aW9uTGVuZ3RoLCAwLCBwYWdpbmF0aW9uTGVuZ3RoICsgMSk7XG5cdFx0fVxuXHRcdC8vIGNoZWNrIGlmIGxhc3QgcGFnZSBpcyBpbmNsdWRlZCBpbiBwYWdpbmF0aW9uLi4uXG5cdFx0aWYgKHBhZ2luYXRpb24uaW5kZXhPZih0b3RhbFBhZ2VzKSA9PT0gLTEpIHtcblx0XHRcdC8vIC4uLmlmIG5vdCwgcGFnZSBuZXh0IHRvIGxhc3Qgc2hvdWxkIGVpdGhlciBzaG93IGVsbGlwc2lzIG9yIGFjdHVhbCBwYWdlIG51bWJlciBmb3IgdGhlIHBhZ2Vcblx0XHRcdHBhZ2luYXRpb25bcGFnaW5hdGlvbi5sZW5ndGggLSAxXSA9XG5cdFx0XHRcdHBhZ2luYXRpb25bcGFnaW5hdGlvbi5sZW5ndGggLSAxXSA9PT0gdG90YWxQYWdlcyAtIDFcblx0XHRcdFx0XHQ/IHRvdGFsUGFnZXMgLSAxXG5cdFx0XHRcdFx0OiB0cnVlO1xuXG5cdFx0XHQvLyAuLi5hZGQgbGFzdCBwYWdlIHRvIHBhZ2luYXRpb25cblx0XHRcdHBhZ2luYXRpb24ucHVzaCh0b3RhbFBhZ2VzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFnaW5hdGlvbjtcblx0fVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEd0RXhwYW5kZWRSb3cgfSBmcm9tICcuL2d0LWV4cGFuZGluZy1yb3cuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiAnZ3QtZHJpbGxkb3duJyxcblx0dGVtcGxhdGU6IGBcbiAgICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlXCI+XG4gICAgICAgICAgPHRyICpuZ0Zvcj1cImxldCByb3cgb2YgZGF0YVwiIChjbGljayk9XCIkcm93Q2xpY2socm93LCAkZXZlbnQpXCI+XG4gICAgICAgICAgICAgIDwhLS08dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBndFNldHRpbmdzXCIgW3N0eWxlLndpZHRoXT1cImNvbHVtbldpZHRoW2NvbHVtbi5vYmplY3RLZXldXCI+e3tjb2x1bW4ub2JqZWN0S2V5fX08L3RkPi0tPlxuICAgICAgICAgICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiByb3cgfCBndFJlbmRlcjpndFNldHRpbmdzOmd0RmllbGRzOm51bGw6bnVsbDpndE9wdGlvbnMuaGlnaGxpZ2h0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtcztcIlxuICAgICAgICAgICAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy1jb2x1bW4nIHwgZGFzaENhc2V9fSB7e2d0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidjbGFzc05hbWVzJ319IHt7KGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykgPyAnZ3QtaW5saW5lLWVkaXQnOicnfX0ge3tjb2x1bW4uZWRpdGVkID8gJ2d0LWVkaXRlZCc6Jyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6cm93OmNvbHVtbiB9fVwiIFtzdHlsZS53aWR0aF09XCJjb2x1bW5XaWR0aFtjb2x1bW4ub2JqZWN0S2V5XVwiIFtzdHlsZS5tYXgtd2lkdGhdPVwiY29sdW1uV2lkdGhbY29sdW1uLm9iamVjdEtleV1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ3Qtcm93LWxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZ3RPcHRpb25zLnN0YWNrXCI+e3soZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgPyAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgOiAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnKX19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPGd0LWN1c3RvbS1jb21wb25lbnQtZmFjdG9yeSAqbmdJZj1cImNvbHVtbi5jb2x1bW5Db21wb25lbnRcIiBjbGFzcz1cImd0LXJvdy1jb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3R5cGVdPVwiY29sdW1uLmNvbHVtbkNvbXBvbmVudC50eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2luamVjdG9yXT1cImNvbHVtbi5jb2x1bW5Db21wb25lbnQuaW5qZWN0b3JcIiBbcm93XT1cInJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCIgKHJlZHJhd0V2ZW50KT1cIiRyZWRyYXcoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjb2x1bW4uY2xpY2sgPyBjb2x1bW4uY2xpY2socm93LGNvbHVtbiwkZXZlbnQpOicnO1wiPjwvZ3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5PlxuICAgICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCIhY29sdW1uLmNvbHVtbkNvbXBvbmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImd0LXJvdy1jb250ZW50XCIgW2lubmVySFRNTF09XCJjb2x1bW4ucmVuZGVyVmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNvbHVtbi5jbGljayA/IGNvbHVtbi5jbGljayhyb3csY29sdW1uLCRldmVudCk6JydcIj48L3NwYW4+XG4gICAgICAgICAgICAgIDwvdGQ+XG5cbiAgICAgICAgICA8L3RyPlxuICAgICAgPC90YWJsZT5cbiAgYCxcblx0c3R5bGVzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBHdERyaWxsZG93bkNvbXBvbmVudCBleHRlbmRzIEd0RXhwYW5kZWRSb3c8YW55PiBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKCk7XG5cdH1cblxuXHRuZ09uSW5pdCgpIHt9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIsIFNhZmVIdG1sIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0SGlnaGxpZ2h0J1xufSlcbmV4cG9ydCBjbGFzcyBHdEhpZ2hsaWdodFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3IocHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcikge31cblxuXHR0cmFuc2Zvcm0odGV4dDogc3RyaW5nLCBzZWFyY2hUZXJtOiBzdHJpbmcpOiBTYWZlSHRtbCB7XG5cdFx0Y29uc3QgaGF5c3RhY2tBbHdheXNTdHJpbmcgPSB0ZXh0ICsgJyc7XG5cdFx0bGV0IGhpZ2hsaWdodGVkVGV4dCA9IGhheXN0YWNrQWx3YXlzU3RyaW5nOyAvLyBmYWxsYmFja1xuXG5cdFx0bGV0IHNlYXJjaFBhdHRlcm47XG5cdFx0dHJ5IHtcblx0XHRcdHNlYXJjaFBhdHRlcm4gPSBuZXcgUmVnRXhwKFxuXHRcdFx0XHQnKCcgK1xuXHRcdFx0XHRzZWFyY2hUZXJtXG5cdFx0XHRcdFx0LnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHQubWF0Y2goL1wiLio/XCJ8W14gXSsvZykgLy8gZXh0cmFjdCB3b3Jkc1xuXHRcdFx0XHRcdC5tYXAoXG5cdFx0XHRcdFx0XHRuZWVkbGUgPT4gbmVlZGxlLnJlcGxhY2UoL1wiKC4qPylcIi8sICckMScpIC8vIHN0cmlwIGF3YXkgJ1wiJ1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHQuam9pbignfCcpICsgLy8gY29tYmluZSB3b3Jkc1xuXHRcdFx0XHRcdCcpJyxcblx0XHRcdFx0J2lnJ1xuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RIdG1sKGhpZ2hsaWdodGVkVGV4dCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29udGFpbnNUYWdQYXR0ZXJuID0gLyg8Lio/PikoLiopKDxcXC8uKj8+KS9naTtcblx0XHRjb25zdCBjb250YWluc1RhZ01hdGNoZXMgPSBjb250YWluc1RhZ1BhdHRlcm4uZXhlYyhoYXlzdGFja0Fsd2F5c1N0cmluZyk7XG5cblx0XHRpZiAoY29udGFpbnNUYWdNYXRjaGVzKSB7XG5cdFx0XHQvLyB0YWcgZXhpc3RzIGluIGhheXN0YWNrXG5cdFx0XHRoaWdobGlnaHRlZFRleHQgPVxuXHRcdFx0XHRjb250YWluc1RhZ01hdGNoZXNbMV0gK1xuXHRcdFx0XHRjb250YWluc1RhZ01hdGNoZXNbMl0ucmVwbGFjZShcblx0XHRcdFx0XHRzZWFyY2hQYXR0ZXJuLFxuXHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cImd0LWhpZ2hsaWdodC1zZWFyY2hcIj4kMTwvc3Bhbj4nXG5cdFx0XHRcdCkgK1xuXHRcdFx0XHRjb250YWluc1RhZ01hdGNoZXNbM107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZ2hsaWdodGVkVGV4dCA9IGhheXN0YWNrQWx3YXlzU3RyaW5nLnJlcGxhY2UoXG5cdFx0XHRcdHNlYXJjaFBhdHRlcm4sXG5cdFx0XHRcdCc8c3BhbiBjbGFzcz1cImd0LWhpZ2hsaWdodC1zZWFyY2hcIj4kMTwvc3Bhbj4nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0SHRtbChoaWdobGlnaHRlZFRleHQpO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHdENvbmZpZ1NldHRpbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LWNvbmZpZy1zZXR0aW5nJztcbmltcG9ydCB7IEd0Q29uZmlnRmllbGQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LWNvbmZpZy1maWVsZCc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IEd0Um93IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1yb3cnO1xuaW1wb3J0IHsgR3RSZW5kZXJGaWVsZCB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtcmVuZGVyLWZpZWxkJztcbmltcG9ydCB7IEd0SGlnaGxpZ2h0UGlwZSB9IGZyb20gJy4vZ3QtaGlnaGxpZ2h0LnBpcGUnO1xuXG5AUGlwZSh7XG5cdG5hbWU6ICdndFJlbmRlcidcbn0pXG5leHBvcnQgY2xhc3MgR3RSZW5kZXJQaXBlPFIgZXh0ZW5kcyBHdFJvdz4gaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3IoXG5cdFx0cHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcixcblx0XHRwcml2YXRlIGd0SGlnaGxpZ2h0UGlwZTogR3RIaWdobGlnaHRQaXBlXG5cdCkge31cblxuXHQvLyBUT0RPOiBtb3ZlIHRvIGhlbHBlciBmdW5jdGlvbnNcblx0LyoqIFNvcnQgYnkgY29sdW1uIG9yZGVyICovXG5cdHByaXZhdGUgZ2V0Q29sdW1uT3JkZXIgPSBmdW5jdGlvbihhOiBHdENvbmZpZ1NldHRpbmcsIGI6IEd0Q29uZmlnU2V0dGluZykge1xuXHRcdGlmIChhLmNvbHVtbk9yZGVyIDwgYi5jb2x1bW5PcmRlcikge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHRpZiAoYS5jb2x1bW5PcmRlciA+IGIuY29sdW1uT3JkZXIgfHwgdHlwZW9mIGEuY29sdW1uT3JkZXIgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cblx0LyoqIFNvcnQgYnkgbGVuZ3RoICovXG5cdHByaXZhdGUgZ2V0T3JkZXJCeUxlbmd0aCA9IGZ1bmN0aW9uKGE6IGFueSwgYjogYW55KSB7XG5cdFx0cmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG5cdH07XG5cblx0LyoqIFJldHVybiBwcm9wZXJ0eSAqL1xuXHRwcml2YXRlIGdldFByb3BlcnR5ID0gZnVuY3Rpb24oYXJyYXk6IEFycmF5PGFueT4sIGtleTogc3RyaW5nKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycmF5W2ldLm9iamVjdEtleSA9PT0ga2V5KSB7XG5cdFx0XHRcdHJldHVybiBhcnJheVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dHJhbnNmb3JtKFxuXHRcdHJvdzogYW55LFxuXHRcdHNldHRpbmdzOiBBcnJheTxHdENvbmZpZ1NldHRpbmc+LFxuXHRcdGZpZWxkczogQXJyYXk8R3RDb25maWdGaWVsZDxSLCBhbnk+Pixcblx0XHR1cGRhdGVkOiBib29sZWFuLFxuXHRcdGxvYWRpbmc6IGJvb2xlYW4sXG5cdFx0aGlnaGxpZ2h0OiBib29sZWFuID0gZmFsc2UsXG5cdFx0c2VhcmNoU3RyaW5nPzogc3RyaW5nXG5cdCk6IEFycmF5PEd0UmVuZGVyRmllbGQ8UiwgYW55Pj4ge1xuXHRcdC8vIGxldCBhcnIgPSBbe1widGVtcFwiOjEyMyxcIm5hbWVcIjpcImhhcHB5XCJ9LHtcInRlbXBcIjo0NTYsXCJuYW1lXCI6XCJkZmdkZmdcIn0se1widGVtcFwiOjc4OSxcIm5hbWVcIjpcImFzZGFzZFwifV07XG5cdFx0Ly8gY29uc29sZS5sb2coYXJyLGFyci5tYXAoZnVuY3Rpb24oaXRlbSl7cmV0dXJuIGl0ZW0udGVtcH0pKTtcblx0XHQvLyBjb25zb2xlLmxvZyhzZXR0aW5ncy5tYXAoJ29iamVjdEtleScpKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCdyZW5kZXInKTtcblx0XHRjb25zdCBjb2x1bW5zOiBBcnJheTxzdHJpbmc+ID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHNldHRpbmdzW2ldLnZpc2libGUgIT09IGZhbHNlICYmIHNldHRpbmdzW2ldLmVuYWJsZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdGNvbHVtbnMucHVzaChzZXR0aW5nc1tpXS5vYmplY3RLZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyghcm93W2ZpZWxkc1tpXS5vYmplY3RLZXldKTtcblx0XHRcdGlmIChcblx0XHRcdFx0ZmllbGRzW2ldLnZhbHVlICYmXG5cdFx0XHRcdHR5cGVvZiBmaWVsZHNbaV0udmFsdWUgPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0IXJvdy5oYXNPd25Qcm9wZXJ0eShmaWVsZHNbaV0ub2JqZWN0S2V5KVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJvd1tmaWVsZHNbaV0ub2JqZWN0S2V5XSA9IGxvYWRpbmcgPyAnJyA6IGZpZWxkc1tpXS52YWx1ZShyb3cpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhyb3cpO1xuXHRcdGNvbnN0IGtleXM6IEFycmF5PGFueT4gPSBbXTtcblx0XHRmb3IgKGNvbnN0IGtleSBpbiByb3cpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGtleSk7XG5cdFx0XHRpZiAoY29sdW1ucy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG5cdFx0XHRcdGxldCBmaWVsZFNldHRpbmc7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGZpZWxkc1tpXS5vYmplY3RLZXkgPT09IGtleSkge1xuXHRcdFx0XHRcdFx0ZmllbGRTZXR0aW5nID0gZmllbGRzW2ldO1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZmllbGRTZXR0aW5nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjb2x1bW5PYmplY3Q6IEd0UmVuZGVyRmllbGQ8UiwgYW55PiA9IHtcblx0XHRcdFx0XHRvYmplY3RLZXk6IGtleSxcblx0XHRcdFx0XHRzb3J0VmFsdWU6IHJvd1trZXldXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gYWRkIGNvbXBvbmVudCBpZiBkZWZpbmVkXG5cdFx0XHRcdGlmIChmaWVsZFNldHRpbmcuY29sdW1uQ29tcG9uZW50KSB7XG5cdFx0XHRcdFx0Y29sdW1uT2JqZWN0LmNvbHVtbkNvbXBvbmVudCA9IGZpZWxkU2V0dGluZy5jb2x1bW5Db21wb25lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobG9hZGluZykge1xuXHRcdFx0XHRcdGNvbHVtbk9iamVjdC5yZW5kZXJWYWx1ZSA9IHJvd1trZXldICE9PSBudWxsID8gcm93W2tleV0gOiAnJztcblx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRoaWdobGlnaHQgJiZcblx0XHRcdFx0XHRzZWFyY2hTdHJpbmcgJiZcblx0XHRcdFx0XHR0aGlzLmdldFByb3BlcnR5KHNldHRpbmdzLCBrZXkpLnNlYXJjaCAhPT0gZmFsc2Vcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29sdW1uT2JqZWN0LnJlbmRlclZhbHVlID1cblx0XHRcdFx0XHRcdGZpZWxkU2V0dGluZy5yZW5kZXIgJiYgdHlwZW9mIGZpZWxkU2V0dGluZy5yZW5kZXIgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdFx0PyB0aGlzLmd0SGlnaGxpZ2h0UGlwZS50cmFuc2Zvcm0oXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFNldHRpbmcucmVuZGVyKHJvdyksXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWFyY2hTdHJpbmdcblx0XHRcdFx0XHRcdFx0ICApXG5cdFx0XHRcdFx0XHRcdDogdGhpcy5ndEhpZ2hsaWdodFBpcGUudHJhbnNmb3JtKFxuXHRcdFx0XHRcdFx0XHRcdFx0cm93W2tleV0gIT09IG51bGwgPyByb3dba2V5XSA6ICcnLFxuXHRcdFx0XHRcdFx0XHRcdFx0c2VhcmNoU3RyaW5nXG5cdFx0XHRcdFx0XHRcdCAgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb2x1bW5PYmplY3QucmVuZGVyVmFsdWUgPVxuXHRcdFx0XHRcdFx0ZmllbGRTZXR0aW5nLnJlbmRlciAmJiB0eXBlb2YgZmllbGRTZXR0aW5nLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0XHQ/IHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RIdG1sKGZpZWxkU2V0dGluZy5yZW5kZXIocm93KSlcblx0XHRcdFx0XHRcdFx0OiByb3dba2V5XSAhPT0gbnVsbFxuXHRcdFx0XHRcdFx0XHRcdD8gcm93W2tleV1cblx0XHRcdFx0XHRcdFx0XHQ6ICcnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGZpZWxkU2V0dGluZy5jbGljayAmJiB0eXBlb2YgZmllbGRTZXR0aW5nLmNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29sdW1uT2JqZWN0LmNsaWNrID0gZmllbGRTZXR0aW5nLmNsaWNrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaWVsZFNldHRpbmcuZXhwYW5kKSB7XG5cdFx0XHRcdFx0Y29sdW1uT2JqZWN0LmV4cGFuZCA9IGZpZWxkU2V0dGluZy5leHBhbmQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRrZXlzLnB1c2goY29sdW1uT2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRrZXlzLnNvcnQoZnVuY3Rpb24oYTogYW55LCBiOiBhbnkpIHtcblx0XHRcdHJldHVybiBjb2x1bW5zLmluZGV4T2YoYS5vYmplY3RLZXkpIDwgY29sdW1ucy5pbmRleE9mKGIub2JqZWN0S2V5KVxuXHRcdFx0XHQ/IC0xXG5cdFx0XHRcdDogMTtcblx0XHR9KTtcblx0XHRyZXR1cm4ga2V5cztcblx0fVxufVxuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3RDb25maWdGaWVsZCB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtY29uZmlnLWZpZWxkJztcbmltcG9ydCB7IEd0Q29uZmlnU2V0dGluZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtY29uZmlnLXNldHRpbmcnO1xuaW1wb3J0IHsgR3RSb3cgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LXJvdyc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0VmlzaWJsZSdcbn0pXG5leHBvcnQgY2xhc3MgR3RWaXNpYmxlUGlwZTxSIGV4dGVuZHMgR3RSb3c+IGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdC8vIFRPRE86IG1vdmUgdG8gaGVscGVyIGZ1bmN0aW9uc1xuXHQvKiogU29ydCBieSBjb2x1bW4gb3JkZXIgKi9cblx0cHJpdmF0ZSBnZXRDb2x1bW5PcmRlciA9IGZ1bmN0aW9uKGE6IGFueSwgYjogYW55KSB7XG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPCBiLmNvbHVtbk9yZGVyKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGlmIChhLmNvbHVtbk9yZGVyID4gYi5jb2x1bW5PcmRlciB8fCB0eXBlb2YgYS5jb2x1bW5PcmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHR0cmFuc2Zvcm0oXG5cdFx0YXJyYXk6IEFycmF5PGFueT4sXG5cdFx0c2V0dGluZ3M6IEFycmF5PEd0Q29uZmlnU2V0dGluZz4sXG5cdFx0cmVmcmVzaFBpcGU/OiBib29sZWFuXG5cdCk6IEFycmF5PEd0Q29uZmlnRmllbGQ8UiwgYW55Pj4gfCBBcnJheTxHdENvbmZpZ1NldHRpbmc+IHtcblx0XHRjb25zdCB2aXNpYmxlQ29sdW1ucyA9IHNldHRpbmdzXG5cdFx0XHQuc29ydCh0aGlzLmdldENvbHVtbk9yZGVyKVxuXHRcdFx0Lm1hcCgoc2V0dGluZzogR3RDb25maWdTZXR0aW5nKSA9PiB7XG5cdFx0XHRcdGlmIChzZXR0aW5nLnZpc2libGUgIT09IGZhbHNlICYmIHNldHRpbmcuZW5hYmxlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gc2V0dGluZy5vYmplY3RLZXk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0cmV0dXJuIGFycmF5XG5cdFx0XHQuZmlsdGVyKChjb2x1bW46IGFueSkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gdmlzaWJsZUNvbHVtbnMuaW5kZXhPZihjb2x1bW4ub2JqZWN0S2V5KSAhPT0gLTE7XG5cdFx0XHR9KVxuXHRcdFx0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gdmlzaWJsZUNvbHVtbnMuaW5kZXhPZihhLm9iamVjdEtleSkgPFxuXHRcdFx0XHRcdHZpc2libGVDb2x1bW5zLmluZGV4T2YoYi5vYmplY3RLZXkpXG5cdFx0XHRcdFx0PyAtMVxuXHRcdFx0XHRcdDogMTtcblx0XHRcdH0pO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2Rhc2hDYXNlJ1xufSlcbmV4cG9ydCBjbGFzcyBEYXNoQ2FzZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblx0dHJhbnNmb3JtKHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cdH1cbn1cbiIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEd0Q29uZmlnRmllbGQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LWNvbmZpZy1maWVsZCc7XG5pbXBvcnQgeyBHdENvbmZpZ1NldHRpbmcgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LWNvbmZpZy1zZXR0aW5nJztcbmltcG9ydCB7IEd0Um93IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1yb3cnO1xuXG5AUGlwZSh7XG5cdG5hbWU6ICdndFByb3BlcnR5J1xufSlcbmV4cG9ydCBjbGFzcyBHdFByb3BlcnR5UGlwZTxSIGV4dGVuZHMgR3RSb3c+IGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdHRyYW5zZm9ybShcblx0XHRjb25maWc6IEd0Q29uZmlnRmllbGQ8UiwgYW55PltdIHwgR3RDb25maWdTZXR0aW5nW10sXG5cdFx0b2JqZWN0S2V5OiBzdHJpbmcsXG5cdFx0cHJvcGVydHk6IHN0cmluZyxcblx0XHRyZWZyZXNoPzogYm9vbGVhblxuXHQpOiBhbnkge1xuXHRcdGxldCBvdXRwdXQgPSBudWxsO1xuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvbmZpZy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoY29uZmlnW2ldLm9iamVjdEtleSA9PT0gb2JqZWN0S2V5KSB7XG5cdFx0XHRcdFx0b3V0cHV0ID0gY29uZmlnW2ldW3Byb3BlcnR5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0J2Nhbm5vdCByZWFkIHByb3BlcnR5OiBcIicgK1xuXHRcdFx0XHRcdHByb3BlcnR5ICtcblx0XHRcdFx0XHQnXCIgb24gbWlzc2luZyBrZXk6IFwiJyArXG5cdFx0XHRcdFx0b2JqZWN0S2V5ICtcblx0XHRcdFx0XHQnXCIgaW4gY29uZmlnLicsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEd0SW5mb3JtYXRpb24sIEd0RXZlbnQgfSBmcm9tICcuLic7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0Q2h1bmsnXG59KVxuZXhwb3J0IGNsYXNzIEd0Q2h1bmtQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdHRyYW5zZm9ybShcblx0XHRhcnJheTogYW55W10sXG5cdFx0Z3RJbmZvOiBHdEluZm9ybWF0aW9uLFxuXHRcdGNodW5rU2l6ZTogbnVtYmVyLFxuXHRcdHBhZ2U6IG51bWJlcixcblx0XHRyZWZyZXNoUGFnZUFycmF5OiBib29sZWFuLFxuXHRcdHJlZnJlc2hEYXRhOiBudW1iZXIsXG5cdFx0Z3RFdmVudDogRXZlbnRFbWl0dGVyPEd0RXZlbnQ+LFxuXHRcdGRhdGE6IHsgZXhwb3J0RGF0YTogQXJyYXk8YW55PiB9XG5cdCk6IGFueVtdIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0fVxuXHRcdGRhdGEuZXhwb3J0RGF0YSA9IGFycmF5OyAvLyBzdG9yZSBkYXRhIGZvciBleHBvcnRcblxuXHRcdGNvbnN0IFBBR0VTID0gW107XG5cdFx0Y29uc3QgRU5UUklFUyA9IGFycmF5Lmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgRU5UUklFUzsgaSArPSBjaHVua1NpemUpIHtcblx0XHRcdFBBR0VTLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuXHRcdH1cblx0XHRndEluZm8udmlzaWJsZVJlY29yZHMgPSAhUEFHRVNbcGFnZSAtIDFdID8gW10gOiBbLi4uUEFHRVNbcGFnZSAtIDFdXTsgLy8gYWRkIHZpc2libGUgcm93c1xuXHRcdGd0SW5mby5wYWdlVG90YWwgPSBQQUdFUy5sZW5ndGg7IC8vIGFkZCBudW1iZXIgb2YgcGFnZXNcblxuXHRcdHNldFRpbWVvdXQoXG5cdFx0XHQoKSA9PlxuXHRcdFx0XHRndEV2ZW50LmVtaXQoe1xuXHRcdFx0XHRcdG5hbWU6ICdndC1pbmZvJyxcblx0XHRcdFx0XHR2YWx1ZTogZ3RJbmZvXG5cdFx0XHRcdH0pLFxuXHRcdFx0MFxuXHRcdCk7XG5cdFx0cmV0dXJuIFBBR0VTW3BhZ2UgLSAxXTtcblx0fVxufVxuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSwgRXZlbnRFbWl0dGVyLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEd0SW5mb3JtYXRpb24gfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LWluZm9ybWF0aW9uJztcblxuQFBpcGUoe1xuXHRuYW1lOiAnZ3RGaWx0ZXInXG59KVxuZXhwb3J0IGNsYXNzIEd0RmlsdGVyUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHQvLyBAT3V0cHV0KCkgZmlsdGVySW5mbyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHR0cmFuc2Zvcm0oXG5cdFx0YWxsUm93czogYW55W10sXG5cdFx0ZmlsdGVyQnk6IE9iamVjdCxcblx0XHRndEluZm86IEd0SW5mb3JtYXRpb24sXG5cdFx0cmVmcmVzaEZpbHRlcjogYm9vbGVhbixcblx0XHRyZWZyZXNoRGF0YTogbnVtYmVyXG5cdCk6IGFueVtdIHtcblx0XHQvLyBjb25zb2xlLmxvZyhhbGxSb3dzLGZpbHRlckJ5KTtcblx0XHRndEluZm8ucmVjb3Jkc0FsbCA9IGFsbFJvd3MubGVuZ3RoO1xuXHRcdGlmICghQXJyYXkuaXNBcnJheShhbGxSb3dzKSB8fCAhZmlsdGVyQnkpIHtcblx0XHRcdC8vIGd0SW5mby5maWx0ZXJlZCA9IGZhbHNlO1xuXG5cdFx0XHRjb25zdCBsZW5ndGggPSBhbGxSb3dzID09PSBudWxsID8gMCA6IGFsbFJvd3MubGVuZ3RoO1xuXHRcdFx0Z3RJbmZvLnJlY29yZHNBZnRlckZpbHRlciA9IGxlbmd0aDtcblx0XHRcdHJldHVybiBhbGxSb3dzO1xuXHRcdH1cblxuXHRcdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYWxsUm93cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgcm93T2JqZWN0ID0gYWxsUm93c1tpXTtcblx0XHRcdGxldCBtYXRjaCA9IHRydWU7XG5cblx0XHRcdGZvciAoY29uc3QgcHJvcGVydHkgaW4gZmlsdGVyQnkpIHtcblx0XHRcdFx0aWYgKGZpbHRlckJ5Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKHByb3BlcnR5KTtcblx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhmaWx0ZXJbcHJvcGVydHldLmluZGV4T2Yob2JqW3Byb3BlcnR5XSkpO1xuXHRcdFx0XHRcdGlmIChmaWx0ZXJCeVtwcm9wZXJ0eV0uaW5kZXhPZihyb3dPYmplY3RbcHJvcGVydHldKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0b3V0cHV0LnB1c2gocm93T2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Z3RJbmZvLnJlY29yZHNBZnRlckZpbHRlciA9IG91dHB1dC5sZW5ndGg7IC8vIC5lbWl0KG91dHB1dC5sZW5ndGgpO1xuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cbn1cbiIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEd0Q29uZmlnRmllbGQgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LWNvbmZpZy1maWVsZCc7XG5pbXBvcnQgeyBHdFJvdyB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3Qtcm93JztcblxuQFBpcGUoe1xuXHRuYW1lOiAnZ3RPcmRlckJ5J1xufSlcbmV4cG9ydCBjbGFzcyBHdE9yZGVyQnlQaXBlPFIgZXh0ZW5kcyBHdFJvdz4gaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblx0c3RhdGljIF9vcmRlckJ5Q29tcGFyYXRvcihhOiBhbnksIGI6IGFueSk6IG51bWJlciB7XG5cdFx0Ly8gc29ydCBib29sZWFuIHZhbHVlcyBhcyBzdHJpbmdzXG5cdFx0aWYgKHR5cGVvZiBhID09PSAnYm9vbGVhbicpIHtcblx0XHRcdGEgPSBhLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgYiA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRiID0gYi50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdGlzTmFOKHBhcnNlRmxvYXQoYSkpIHx8XG5cdFx0XHQhaXNGaW5pdGUoYSkgfHxcblx0XHRcdChpc05hTihwYXJzZUZsb2F0KGIpKSB8fCAhaXNGaW5pdGUoYikpXG5cdFx0KSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGIgPT09IG51bGwgfHxcblx0XHRcdFx0KHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyAmJiAoYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSAhPT0gJ3VuZGVmaW5lZCcpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRhID09PSBudWxsIHx8XG5cdFx0XHRcdCh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgJiYgKGIgIT09IG51bGwgJiYgdHlwZW9mIGIgIT09ICd1bmRlZmluZWQnKSlcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlzbid0IGEgbnVtYmVyIHNvIGxvd2VyY2FzZSB0aGUgc3RyaW5nIHRvIHByb3Blcmx5IGNvbXBhcmVcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChhLnRvTG93ZXJDYXNlKCkgPCBiLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGEudG9Mb3dlckNhc2UoKSA+IGIudG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGFyc2Ugc3RyaW5ncyBhcyBudW1iZXJzIHRvIGNvbXBhcmUgcHJvcGVybHlcblx0XHRcdGlmIChwYXJzZUZsb2F0KGEpIDwgcGFyc2VGbG9hdChiKSkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGFyc2VGbG9hdChhKSA+IHBhcnNlRmxvYXQoYikpIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDA7IC8vIGVxdWFsIGVhY2ggb3RoZXJcblx0fVxuXG5cdC8qKiBSZXR1cm4gcHJvcGVydHkgKi9cblx0cHJpdmF0ZSBnZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKGFycmF5OiBBcnJheTxhbnk+LCBrZXk6IHN0cmluZykge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhcnJheVtpXS5vYmplY3RLZXkgPT09IGtleSkge1xuXHRcdFx0XHRyZXR1cm4gYXJyYXlbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKiBSZXR1cm4gc29ydCBmdW5jdGlvbiAqL1xuXHRwcml2YXRlIGdldFNvcnRGdW5jdGlvbihmaWVsZDogYW55KSB7XG5cdFx0aWYgKCFmaWVsZCkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2Vycm9yIHRyeWluZyB0byBzb3J0IHVuZGVmaW5lZCBmaWVsZCcpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGZpZWxkLnNvcnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBmaWVsZC5zb3J0O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGZpZWxkLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gZmllbGQudmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHR0cmFuc2Zvcm0oXG5cdFx0aW5wdXQ6IGFueSxcblx0XHRzb3J0QnlQcm9wZXJ0aWVzOiBBcnJheTxzdHJpbmc+LFxuXHRcdGZpZWxkczogR3RDb25maWdGaWVsZDxSLCBhbnk+W10sXG5cdFx0cmVmcmVzaFNvcnRpbmc6IGJvb2xlYW4sXG5cdFx0cmVmcmVzaERhdGE6IG51bWJlclxuXHQpOiBhbnkge1xuXHRcdGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBpbnB1dDtcblx0XHR9XG5cdFx0aWYgKFxuXHRcdFx0IUFycmF5LmlzQXJyYXkoc29ydEJ5UHJvcGVydGllcykgfHxcblx0XHRcdChBcnJheS5pc0FycmF5KHNvcnRCeVByb3BlcnRpZXMpICYmIHNvcnRCeVByb3BlcnRpZXMubGVuZ3RoID09PSAxKVxuXHRcdCkge1xuXHRcdFx0Y29uc3QgcHJvcGVydHlUb0NoZWNrOiBzdHJpbmcgPSBzb3J0QnlQcm9wZXJ0aWVzWzBdO1xuXHRcdFx0Y29uc3QgZGVzYyA9IHByb3BlcnR5VG9DaGVjay5zdWJzdHIoMCwgMSkgPT09ICctJztcblxuXHRcdFx0Ly8gYmFzaWMgYXJyYXlcblx0XHRcdGlmIChcblx0XHRcdFx0IXByb3BlcnR5VG9DaGVjayB8fFxuXHRcdFx0XHRwcm9wZXJ0eVRvQ2hlY2sgPT09ICctJyB8fFxuXHRcdFx0XHRwcm9wZXJ0eVRvQ2hlY2sgPT09ICcrJ1xuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiAhZGVzYyA/IGlucHV0LnNvcnQoKSA6IGlucHV0LnNvcnQoKS5yZXZlcnNlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBwcm9wZXJ0eTogc3RyaW5nID1cblx0XHRcdFx0XHRwcm9wZXJ0eVRvQ2hlY2suc3Vic3RyKDAsIDEpID09PSAnKycgfHxcblx0XHRcdFx0XHRwcm9wZXJ0eVRvQ2hlY2suc3Vic3RyKDAsIDEpID09PSAnLSdcblx0XHRcdFx0XHRcdD8gcHJvcGVydHlUb0NoZWNrLnN1YnN0cigxKVxuXHRcdFx0XHRcdFx0OiBwcm9wZXJ0eVRvQ2hlY2s7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgY3VzdG9tIHNvcnQgZnVuY3Rpb24gaXMgZGVmaW5lZFxuXHRcdFx0XHRjb25zdCBzb3J0RnVuY3Rpb246IGFueSA9IHRoaXMuZ2V0U29ydEZ1bmN0aW9uKFxuXHRcdFx0XHRcdHRoaXMuZ2V0UHJvcGVydHkoZmllbGRzLCBwcm9wZXJ0eSlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhwcm9wZXJ0eSk7XG5cdFx0XHRcdHJldHVybiBpbnB1dC5zb3J0KGZ1bmN0aW9uKGE6IGFueSwgYjogYW55KSB7XG5cdFx0XHRcdFx0Ly8gdXNlIGN1c3RvbSBzb3J0IGZ1bmN0aW9uIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0XHRcdFx0Y29uc3QgcHJvcGVydHlBID1cblx0XHRcdFx0XHRcdHNvcnRGdW5jdGlvbiA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0PyBwcm9wZXJ0eSA9PT0gJyQkZ3RSb3dJZCdcblx0XHRcdFx0XHRcdFx0XHQ/ICthLiQkZ3RSb3dJZC5zcGxpdCgnXycpWzBdXG5cdFx0XHRcdFx0XHRcdFx0OiBhW3Byb3BlcnR5XVxuXHRcdFx0XHRcdFx0XHQ6IHNvcnRGdW5jdGlvbihhKTtcblx0XHRcdFx0XHRjb25zdCBwcm9wZXJ0eUIgPVxuXHRcdFx0XHRcdFx0c29ydEZ1bmN0aW9uID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0XHQ/IHByb3BlcnR5ID09PSAnJCRndFJvd0lkJ1xuXHRcdFx0XHRcdFx0XHRcdD8gK2IuJCRndFJvd0lkLnNwbGl0KCdfJylbMF1cblx0XHRcdFx0XHRcdFx0XHQ6IGJbcHJvcGVydHldXG5cdFx0XHRcdFx0XHRcdDogc29ydEZ1bmN0aW9uKGIpO1xuXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCB2YWx1ZXMgYXJlIHVuZGVmaW5lZC4uLlxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHR5cGVvZiBwcm9wZXJ0eUEgPT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRcdFx0XHR0eXBlb2YgcHJvcGVydHlCID09PSAndW5kZWZpbmVkJ1xuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uc2tpcCBjb21wYXJpc29uXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAhZGVzY1xuXHRcdFx0XHRcdFx0PyBHdE9yZGVyQnlQaXBlLl9vcmRlckJ5Q29tcGFyYXRvcihwcm9wZXJ0eUEsIHByb3BlcnR5Qilcblx0XHRcdFx0XHRcdDogLUd0T3JkZXJCeVBpcGUuX29yZGVyQnlDb21wYXJhdG9yKHByb3BlcnR5QSwgcHJvcGVydHlCKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGxvb3Agb3ZlciBwcm9wZXJ0eSBvZiB0aGUgYXJyYXkgaW4gb3JkZXIgYW5kIHNvcnRcblx0XHRcdHJldHVybiBpbnB1dC5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4ge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZygnbXVsdGlwbGUnKTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0QnlQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGVzYyA9IHNvcnRCeVByb3BlcnRpZXNbaV0uc3Vic3RyKDAsIDEpID09PSAnLSc7XG5cdFx0XHRcdFx0Y29uc3QgcHJvcGVydHkgPVxuXHRcdFx0XHRcdFx0c29ydEJ5UHJvcGVydGllc1tpXS5zdWJzdHIoMCwgMSkgPT09ICcrJyB8fFxuXHRcdFx0XHRcdFx0c29ydEJ5UHJvcGVydGllc1tpXS5zdWJzdHIoMCwgMSkgPT09ICctJ1xuXHRcdFx0XHRcdFx0XHQ/IHNvcnRCeVByb3BlcnRpZXNbaV0uc3Vic3RyKDEpXG5cdFx0XHRcdFx0XHRcdDogc29ydEJ5UHJvcGVydGllc1tpXTtcblxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKHByb3BlcnR5KTtcblx0XHRcdFx0XHQvLyBjaGVjayBpZiBjdXN0b20gc29ydCBmdW5jdGlvbiBpcyBkZWZpbmVkXG5cdFx0XHRcdFx0Y29uc3Qgc29ydEZ1bmN0aW9uOiBhbnkgPSB0aGlzLmdldFNvcnRGdW5jdGlvbihcblx0XHRcdFx0XHRcdHRoaXMuZ2V0UHJvcGVydHkoZmllbGRzLCBwcm9wZXJ0eSlcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gdXNlIGN1c3RvbSBzb3J0IGZ1bmN0aW9uIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0XHRcdFx0Y29uc3QgcHJvcGVydHlBID1cblx0XHRcdFx0XHRcdHNvcnRGdW5jdGlvbiA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0PyBwcm9wZXJ0eSA9PT0gJyQkZ3RSb3dJZCdcblx0XHRcdFx0XHRcdFx0XHQ/ICthLiQkZ3RSb3dJZC5zcGxpdCgnXycpWzBdXG5cdFx0XHRcdFx0XHRcdFx0OiBhW3Byb3BlcnR5XVxuXHRcdFx0XHRcdFx0XHQ6IHNvcnRGdW5jdGlvbihhKTtcblx0XHRcdFx0XHRjb25zdCBwcm9wZXJ0eUIgPVxuXHRcdFx0XHRcdFx0c29ydEZ1bmN0aW9uID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0XHQ/IHByb3BlcnR5ID09PSAnJCRndFJvd0lkJ1xuXHRcdFx0XHRcdFx0XHRcdD8gK2IuJCRndFJvd0lkLnNwbGl0KCdfJylbMF1cblx0XHRcdFx0XHRcdFx0XHQ6IGJbcHJvcGVydHldXG5cdFx0XHRcdFx0XHRcdDogc29ydEZ1bmN0aW9uKGIpO1xuXG5cdFx0XHRcdFx0Y29uc3QgY29tcGFyaXNvbiA9ICFkZXNjXG5cdFx0XHRcdFx0XHQ/IEd0T3JkZXJCeVBpcGUuX29yZGVyQnlDb21wYXJhdG9yKHByb3BlcnR5QSwgcHJvcGVydHlCKVxuXHRcdFx0XHRcdFx0OiAtR3RPcmRlckJ5UGlwZS5fb3JkZXJCeUNvbXBhcmF0b3IocHJvcGVydHlBLCBwcm9wZXJ0eUIpO1xuXG5cdFx0XHRcdFx0Ly8gZG9uJ3QgcmV0dXJuIDAgeWV0IGluIGNhc2Ugb2YgbmVlZGluZyB0byBzb3J0IGJ5IG5leHQgcHJvcGVydHlcblx0XHRcdFx0XHRpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbXBhcmlzb247XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIDA7IC8vIGVxdWFsIGVhY2ggb3RoZXJcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3RDb25maWdGaWVsZCB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtY29uZmlnLWZpZWxkJztcbmltcG9ydCB7IEd0Um93IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1yb3cnO1xuaW1wb3J0IHsgR3RDb25maWdTZXR0aW5nIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1jb25maWctc2V0dGluZyc7XG5pbXBvcnQgeyBHdEluZm9ybWF0aW9uIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1pbmZvcm1hdGlvbic7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0U2VhcmNoJ1xufSlcbmV4cG9ydCBjbGFzcyBHdFNlYXJjaFBpcGU8UiBleHRlbmRzIEd0Um93PiBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHQvKiogUmV0dXJuIHByb3BlcnR5ICovXG5cdHByaXZhdGUgZ2V0UHJvcGVydHkgPSBmdW5jdGlvbihhcnJheTogQXJyYXk8YW55Piwga2V5OiBzdHJpbmcpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyYXlbaV0ub2JqZWN0S2V5ID09PSBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIGFycmF5W2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR0cmFuc2Zvcm0oXG5cdFx0YWxsUm93czogYW55LFxuXHRcdHNlYXJjaFRlcm1zOiBzdHJpbmcsXG5cdFx0Z3RJbmZvOiBHdEluZm9ybWF0aW9uLFxuXHRcdHNldHRpbmdzOiBBcnJheTxHdENvbmZpZ1NldHRpbmc+LFxuXHRcdGZpZWxkczogQXJyYXk8R3RDb25maWdGaWVsZDxSLCBhbnk+Pixcblx0XHRyZWZyZXNoRGF0YTogbnVtYmVyXG5cdCk6IGFueSB7XG5cdFx0Ly8gIGlmIG5vIHNlYXJjaCB0ZXJtcyBhcmUgZGVmaW5lZC4uLlxuXHRcdGlmICghc2VhcmNoVGVybXMgfHwgc2VhcmNoVGVybXMucmVwbGFjZSgvXCIvZywgJycpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Ly8gLi4ucmV0dXJuIGFsbCByb3dzXG5cdFx0XHRjb25zdCBsZW5ndGggPSBhbGxSb3dzID09PSBudWxsID8gMCA6IGFsbFJvd3MubGVuZ3RoO1xuXHRcdFx0Z3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaCA9IGxlbmd0aDtcblx0XHRcdHJldHVybiBhbGxSb3dzO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNlYXJjaEZ1bmN0aW9uOiBhbnkgPSB7fTtcblx0XHRjb25zdCBmaWVsZHNUZW1wOiBBcnJheTxhbnk+ID0gW107XG5cblx0XHRmb3IgKGxldCBrID0gMDsgayA8IGZpZWxkcy5sZW5ndGg7IGsrKykge1xuXHRcdFx0Y29uc3QgZmllbGQgPSBmaWVsZHNba107XG5cblx0XHRcdC8vIGNoZWNrIGlmIGZpZWxkIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBnbG9iYWwgc2VhcmNoXG5cdFx0XHRjb25zdCBpbmNsdWRlID1cblx0XHRcdFx0dGhpcy5nZXRQcm9wZXJ0eShzZXR0aW5ncywgZmllbGQub2JqZWN0S2V5KS5zZWFyY2ggPT09IGZhbHNlXG5cdFx0XHRcdFx0PyBmYWxzZVxuXHRcdFx0XHRcdDogdHJ1ZTtcblxuXHRcdFx0Ly8gaWYgaW5jbHVkZS4uLlxuXHRcdFx0aWYgKGluY2x1ZGUpIHtcblx0XHRcdFx0Ly8gLi4uYW5kIGlmIHNlYXJjaCBmdW5jdGlvbiBpcyBkZWZpbmVkLi4uXG5cdFx0XHRcdGlmICh0eXBlb2YgZmllbGQuc2VhcmNoID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Ly8gLi4uYWRkIGl0IGFzIHNlYXJjaCBmdW5jdGlvbiBmb3IgZmllbGRcblx0XHRcdFx0XHRzZWFyY2hGdW5jdGlvbltmaWVsZC5vYmplY3RLZXldID0gZmllbGQuc2VhcmNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIC4uLmlmIG5vIHNlYXJjaCBmdW5jdGlvbiBpcyBkZWZpbmVkIGJ1dCB2YWx1ZSBmdW5jdGlvbiBpcyBkZWZpbmVkLi4uXG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBmaWVsZC52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdC8vIC4uLmFkZCBpdCBhcyBzZWFyY2ggZnVuY3Rpb24gZm9yIGZpZWxkXG5cdFx0XHRcdFx0c2VhcmNoRnVuY3Rpb25bZmllbGQub2JqZWN0S2V5XSA9IGZpZWxkLnZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gLi4ucHVzaCBpdCB0byBvdXIgZmllbGRzIGFycmF5XG5cdFx0XHRcdGZpZWxkc1RlbXAucHVzaChmaWVsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmlsdGVyZWRSb3dzOiBBcnJheTxhbnk+ID0gW107XG5cdFx0c2VhcmNoVGVybXMgPSB0eXBlb2Ygc2VhcmNoVGVybXMgPT09ICd1bmRlZmluZWQnID8gJycgOiBzZWFyY2hUZXJtcztcblx0XHRjb25zdCBzZWFyY2hUZXJtc0FycmF5ID0gc2VhcmNoVGVybXMudG9Mb3dlckNhc2UoKS5tYXRjaCgvKFwiLipcInxbXlxcc10rKS9nKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYWxsUm93cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgcm93ID0gYWxsUm93c1tpXTtcblx0XHRcdGxldCBzdHJpbmcgPSAnJztcblxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBmaWVsZHNUZW1wLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IHNlcGFyYXRvciA9IGogPT09IDAgPyAnJyA6ICcgJiAnO1xuXHRcdFx0XHRzdHJpbmcgKz0gc2VhcmNoRnVuY3Rpb25bZmllbGRzVGVtcFtqXS5vYmplY3RLZXldXG5cdFx0XHRcdFx0PyBzZXBhcmF0b3IgKyBzZWFyY2hGdW5jdGlvbltmaWVsZHNUZW1wW2pdLm9iamVjdEtleV0ocm93LCBqKVxuXHRcdFx0XHRcdDogc2VwYXJhdG9yICsgcm93W2ZpZWxkc1RlbXBbal0ub2JqZWN0S2V5XTtcblx0XHRcdH1cblx0XHRcdHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0bGV0IG1hdGNoOiBCb29sZWFuID0gdHJ1ZTtcblxuXHRcdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBzZWFyY2hUZXJtc0FycmF5Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdGNvbnN0IHRlcm0gPSBzZWFyY2hUZXJtc0FycmF5W2tdLnJlcGxhY2UoL1wiL2csICcnKTtcblx0XHRcdFx0bWF0Y2ggPSBzdHJpbmcuaW5kZXhPZih0ZXJtKSAhPT0gLTE7XG5cblx0XHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0ZmlsdGVyZWRSb3dzLnB1c2gocm93KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Z3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaCA9IGZpbHRlcmVkUm93cy5sZW5ndGg7XG5cdFx0Ly8gZ3RJbmZvLnJlZnJlc2goZmlsdGVyZWRSb3dzLmxlbmd0aCxndCk7XG5cdFx0cmV0dXJuIGZpbHRlcmVkUm93cztcblx0fVxufVxuIiwiaW1wb3J0IHtcblx0Q29tcG9uZW50RmFjdG9yeSxcblx0Q29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuXHRDb21wb25lbnRSZWYsXG5cdERpcmVjdGl2ZSxcblx0RXZlbnRFbWl0dGVyLFxuXHRJbmplY3Rvcixcblx0SW5wdXQsXG5cdE9uSW5pdCxcblx0T3V0cHV0LFxuXHRUeXBlLFxuXHRWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcblx0c2VsZWN0b3I6ICdbZ3RDb21wb25lbnRBbmNob3JdJ1xufSlcbmV4cG9ydCBjbGFzcyBDb21wb25lbnRBbmNob3JEaXJlY3RpdmU8Qz4gaW1wbGVtZW50cyBPbkluaXQge1xuXHRASW5wdXQoKSBjdG9yOiBUeXBlPEM+O1xuXHRASW5wdXQoKSBpbmplY3RvcjogSW5qZWN0b3I7XG5cdEBPdXRwdXQoKSBpbnN0YW5jZTogRXZlbnRFbWl0dGVyPEM+ID0gbmV3IEV2ZW50RW1pdHRlcjxDPigpO1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG5cdFx0cHJpdmF0ZSB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmXG5cdCkge31cblxuXHRuZ09uSW5pdCgpOiB2b2lkIHtcblx0XHRjb25zdCBmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PFxuXHRcdFx0Q1xuXHRcdD4gPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSh0aGlzLmN0b3IpO1xuXHRcdGNvbnN0IGNvbXBvbmVudDogQ29tcG9uZW50UmVmPEM+ID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChcblx0XHRcdGZhY3RvcnksXG5cdFx0XHQwLFxuXHRcdFx0dGhpcy5pbmplY3RvclxuXHRcdCk7XG5cdFx0dGhpcy5pbnN0YW5jZS5lbWl0KGNvbXBvbmVudC5pbnN0YW5jZSk7XG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0RXZlbnRFbWl0dGVyLFxuXHRJbmplY3Rvcixcblx0SW5wdXQsXG5cdE9uSW5pdCxcblx0T3V0cHV0LFxuXHRUeXBlXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMvUmVwbGF5U3ViamVjdCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHdEN1c3RvbUNvbXBvbmVudDxSPiBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cdHJvdzogUjtcblx0Y29sdW1uOiBhbnk7XG5cdHJlZHJhd0V2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjx7IHJvdzogUjsgY29sdW1uOiBhbnkgfT4oKTtcblx0c2VhcmNoVGVybXM6IHN0cmluZztcblx0JHNlYXJjaFRlcm1zOiBSZXBsYXlTdWJqZWN0PHN0cmluZz4gPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcblxuXHRwcm90ZWN0ZWQgJHJlZHJhdygkZXZlbnQ/OiBhbnkpIHtcblx0XHR0aGlzLnJlZHJhd0V2ZW50LmVtaXQoeyByb3c6IHRoaXMucm93LCBjb2x1bW46IHRoaXMuY29sdW1uIH0pO1xuXHR9XG5cdG5nT25Jbml0KCkge1xuXHRcdHRoaXMuJHNlYXJjaFRlcm1zLnN1YnNjcmliZSh0ZXJtcyA9PiAodGhpcy5zZWFyY2hUZXJtcyA9IHRlcm1zKSk7XG5cdH1cbn1cblxuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiAnZ3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5Jyxcblx0dGVtcGxhdGU6IGA8ZGl2IGd0Q29tcG9uZW50QW5jaG9yIFtjdG9yXT1cInR5cGVcIlxuICAgICAgICAgICAgICAgICAgICBbaW5qZWN0b3JdPVwiaW5qZWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICAoaW5zdGFuY2UpPVwiaW5zdGFuY2UoJGV2ZW50KVwiPjwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgR3RDdXN0b21Db21wb25lbnRGYWN0b3J5PFIsIEMgZXh0ZW5kcyBHdEN1c3RvbUNvbXBvbmVudDxSPj4ge1xuXHRASW5wdXQoKVxuXHRzZXQgc2VhcmNoVGVybXModmFsdWU6IHN0cmluZykge1xuXHRcdHRoaXMuJHNlYXJjaFRlcm1zLm5leHQodmFsdWUpO1xuXHR9XG5cdEBJbnB1dCgpIHR5cGU6IFR5cGU8Qz47XG5cdEBJbnB1dCgpIGluamVjdG9yOiBJbmplY3Rvcjtcblx0QElucHV0KCkgcm93OiBSO1xuXHRASW5wdXQoKSBjb2x1bW46IGFueTtcblx0JHNlYXJjaFRlcm1zOiBSZXBsYXlTdWJqZWN0PHN0cmluZz4gPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcblx0QE91dHB1dCgpIHJlZHJhd0V2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjx7IHJvdzogUjsgY29sdW1uOiBhbnkgfT4oKTtcblxuXHRpbnN0YW5jZShpbnN0YW5jZTogQykge1xuXHRcdGluc3RhbmNlLnJvdyA9IHRoaXMucm93O1xuXHRcdGluc3RhbmNlLmNvbHVtbiA9IHRoaXMuY29sdW1uO1xuXHRcdGluc3RhbmNlLiRzZWFyY2hUZXJtcyA9IHRoaXMuJHNlYXJjaFRlcm1zO1xuXHRcdGluc3RhbmNlLnJlZHJhd0V2ZW50LnN1YnNjcmliZSh0aGlzLnJlZHJhd0V2ZW50KTtcblx0fVxufVxuIiwiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRFdmVudEVtaXR0ZXIsXG5cdElucHV0LFxuXHRPbkRlc3Ryb3ksXG5cdE9uSW5pdCxcblx0T3V0cHV0LFxuXHRSZW5kZXJlcjJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCAqIGFzIFRldGhlciBmcm9tICd0ZXRoZXInO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdndC1kcm9wZG93bicsXG5cdHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duIGd0LWRyb3Bkb3duXCIgW25nQ2xhc3NdPVwieydzaG93JzphY3RpdmV9XCIgW2F0dHIuaWRdPVwiaWRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJkcm9wZG93bi10b2dnbGVcIiAoY2xpY2spPVwidG9nZ2xlRHJvcGRvd24oKVwiIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiYWN0aXZlXCI+e3tzZWxlY3RlZH19PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiZ3QtZHJvcGRvd24tbWVudSBkcm9wZG93bi1tZW51XCIgKm5nSWY9XCJhY3RpdmVcIiBbbmdDbGFzc109XCJ7J3Nob3cnOmFjdGl2ZX1cIiBbYXR0ci5pZF09XCJpZCsnX21lbnUnXCI+XG4gICAgICAgIDxidXR0b24gKm5nRm9yPVwibGV0IG9wdGlvbiBvZiBvcHRpb25zO1wiIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiIChjbGljayk9XCJzZWxlY3Qob3B0aW9uKVwiIFtuZ0NsYXNzXT1cInsnYWN0aXZlJzpvcHRpb24gPT09IHNlbGVjdGVkfVwiPnt7b3B0aW9ufX08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuXHRzdHlsZXM6IFtcblx0XHRgXG4gICAgLmd0LWRyb3Bkb3duIC5kcm9wZG93bi10b2dnbGUge1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIH1cbiAgICAuZ3QtZHJvcGRvd24gLmRyb3Bkb3duLXRvZ2dsZTo6YWZ0ZXIge1xuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjRzIGVhc2UtaW4tb3V0O1xuICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG4gICAgLmd0LWRyb3Bkb3duIC5kcm9wZG93bi10b2dnbGU6aG92ZXI6OmFmdGVyIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuICBgXG5cdF1cbn0pXG5leHBvcnQgY2xhc3MgR3REcm9wZG93bkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblx0Z2V0IHNlbGVjdGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZDtcblx0fVxuXG5cdF9zZWxlY3RlZDogYW55O1xuXHRASW5wdXQoKVxuXHRzZXQgc2VsZWN0ZWQoc2VsZWN0aW9uKSB7XG5cdFx0dGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3Rpb247XG5cdH1cblx0QElucHV0KCkgb3B0aW9uczogQXJyYXk8YW55Pjtcblx0QElucHV0KCkgaWQ6IHN0cmluZztcblx0QE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHRhY3RpdmUgPSBmYWxzZTsgLy8gaXMgZHJvcGRvd24gYWN0aXZlIG9yIG5vdFxuXHRzdGF0ZTogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0KCk7IC8vIGN1cnJlbnQgc3RhdGUgb2YgZHJvcGRvd25cblx0dGV0aGVyOiBhbnk7XG5cdGNsaWNrTGlzdGVuZXI6IEZ1bmN0aW9uO1xuXHRrZXl1cExpc3RlbmVyOiBGdW5jdGlvbjtcblxuXHRjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cblx0c2VsZWN0KG9wdGlvbjogYW55KSB7XG5cdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0XHR0aGlzLnN0YXRlLm5leHQodGhpcy5hY3RpdmUpO1xuXHRcdGlmICh0aGlzLl9zZWxlY3RlZCAhPT0gb3B0aW9uKSB7XG5cdFx0XHR0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQob3B0aW9uKTtcblx0XHR9XG5cdH1cblxuXHR0b2dnbGVEcm9wZG93bigpIHtcblx0XHR0aGlzLmFjdGl2ZSA9ICF0aGlzLmFjdGl2ZTtcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdHRoaXMuc3RhdGUubmV4dCh0aGlzLmFjdGl2ZSk7XG5cdFx0fSwgMCk7XG5cdH1cblxuXHRuZ09uSW5pdCgpIHtcblx0XHR0aGlzLnN0YXRlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG5cdFx0XHRpZiAoc3RhdGUpIHtcblx0XHRcdFx0dGhpcy50ZXRoZXIgPSBuZXcgVGV0aGVyKHtcblx0XHRcdFx0XHRlbGVtZW50OiAnIycgKyB0aGlzLmlkICsgJ19tZW51Jyxcblx0XHRcdFx0XHR0YXJnZXQ6ICcjJyArIHRoaXMuaWQsXG5cdFx0XHRcdFx0YXR0YWNobWVudDogJ3RvcCBsZWZ0Jyxcblx0XHRcdFx0XHR0YXJnZXRBdHRhY2htZW50OiAnYm90dG9tIGxlZnQnLFxuXHRcdFx0XHRcdGNvbnN0cmFpbnRzOiBbXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHRvOiAnd2luZG93Jyxcblx0XHRcdFx0XHRcdFx0YXR0YWNobWVudDogJ3RvZ2V0aGVyJ1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy50ZXRoZXIucG9zaXRpb24oKTtcblxuXHRcdFx0XHQvLyBzZXQgdXAgY2xpY2sgbGlzdGVuZXIgYW5kIGxpc3RlbiBmb3IgY2xpY2sgb3V0c2lkZSBkcm9wZG93blxuXHRcdFx0XHR0aGlzLmNsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbihcblx0XHRcdFx0XHQnZG9jdW1lbnQnLFxuXHRcdFx0XHRcdCdjbGljaycsXG5cdFx0XHRcdFx0KGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dGhpcy5zdGF0ZS5uZXh0KHRoaXMuYWN0aXZlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gc2V0IHVwIGtleWJvYXJkIGxpc3RlbmVyIGFuZCBsaXN0ZW4gZm9yIGVzY2FwZSBrZXkgdXBcblx0XHRcdFx0dGhpcy5rZXl1cExpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oXG5cdFx0XHRcdFx0J2RvY3VtZW50Jyxcblx0XHRcdFx0XHQna2V5dXAnLFxuXHRcdFx0XHRcdChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuXHRcdFx0XHRcdFx0c3dpdGNoIChldmVudC5rZXkpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAnRXNjYXBlJzpcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuc3RhdGUubmV4dCh0aGlzLmFjdGl2ZSk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy50ZXRoZXIuZGVzdHJveSgpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0bmdPbkRlc3Ryb3koKSB7XG5cdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcblx0fVxuXG5cdHJlbW92ZUxpc3RlbmVycygpIHtcblx0XHRpZiAodGhpcy5jbGlja0xpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLmNsaWNrTGlzdGVuZXIoKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMua2V5dXBMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5rZXl1cExpc3RlbmVyKCk7XG5cdFx0fVxuXHR9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0VG90YWxzJ1xufSlcbmV4cG9ydCBjbGFzcyBHdFRvdGFsc1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblx0dHJhbnNmb3JtKFxuXHRcdHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBGdW5jdGlvbixcblx0XHRkYXRhOiBBcnJheTxhbnk+LFxuXHRcdG9iamVjdEtleTogc3RyaW5nLFxuXHRcdHJlZnJlc2g6IGJvb2xlYW5cblx0KTogYW55IHtcblx0XHRsZXQgb3V0cHV0O1xuXG5cdFx0aWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0cHV0ID0gdmFsdWUoZGF0YSwgb2JqZWN0S2V5KTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlKSB7XG5cdFx0XHRvdXRwdXQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3V0cHV0ID0gJyc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxufVxuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3RDb25maWdUb3RhbCB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtY29uZmlnLXRvdGFsJztcblxuQFBpcGUoe1xuXHRuYW1lOiAnZ3RUb3RhbHNQb3NpdGlvbidcbn0pXG5leHBvcnQgY2xhc3MgR3RUb3RhbHNQb3NpdGlvblBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblx0dHJhbnNmb3JtKFxuXHRcdGFycmF5OiBBcnJheTxHdENvbmZpZ1RvdGFsPixcblx0XHRwb3NpdGlvbjogJ2hlYWRlcicgfCAnZm9vdGVyJyA9ICdoZWFkZXInXG5cdCk6IEFycmF5PGFueT4ge1xuXHRcdHJldHVybiBhcnJheS5maWx0ZXIodG90YWwgPT4ge1xuXHRcdFx0Ly8gaWYgbm8gcG9zaXRpb24gaXMgZGVmaW5lZCBhc3N1bWUgcG9zaXRpb24gdG8gYmUgaGVhZGVyXG5cdFx0XHRjb25zdCB0b3RhbFBvc2l0aW9uID0gdG90YWwucG9zaXRpb24gPyB0b3RhbC5wb3NpdGlvbiA6ICdoZWFkZXInO1xuXHRcdFx0cmV0dXJuIHRvdGFsUG9zaXRpb24gPT09IHBvc2l0aW9uO1xuXHRcdH0pO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHdENvbmZpZ0ZpZWxkIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1jb25maWctZmllbGQnO1xuXG5AUGlwZSh7XG5cdG5hbWU6ICdndFJvd0NsYXNzJ1xufSlcbmV4cG9ydCBjbGFzcyBHdFJvd0NsYXNzUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHR0cmFuc2Zvcm0oYXJyYXk6IEFycmF5PGFueT4sIGd0RmllbGRzOiBBcnJheTxHdENvbmZpZ0ZpZWxkPGFueSwgYW55Pj4pOiBhbnkge1xuXHRcdGlmIChhcnJheSkge1xuXHRcdFx0Ly8gZmluZCBjb2x1bW5zIHdpdGggcm93Q2xhc3MgcHJvcGVydHkgZGVmaW5lZFxuXHRcdFx0Y29uc3QgQ09MVU1OU19XSVRIX0NMQVNTID0gZ3RGaWVsZHNcblx0XHRcdFx0Lm1hcChjb2x1bW4gPT4gY29sdW1uKVxuXHRcdFx0XHQuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4ucm93Q2xhc3MpO1xuXHRcdFx0Q09MVU1OU19XSVRIX0NMQVNTLm1hcChjb2x1bW4gPT4ge1xuXHRcdFx0XHQvLyBmb3IgZWFjaCBjb2x1bW4gd2l0aCByb3dDbGFzcyBwcm9wZXJ0eSBkZWZpbmVkLi4uXG5cdFx0XHRcdGFycmF5Lm1hcChyb3cgPT4ge1xuXHRcdFx0XHRcdC8vIGxvb3AgdGhyb3VnaCByb3dzIGFuZCBzZXQgcm93IGNsYXNzXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjb2x1bW4ucm93Q2xhc3MgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdC8vIGlmIHJvdyBjbGFzcyBpcyBhIGZ1bmN0aW9uLCB0cnkgdXNpbmcgdGhlIGZ1bmN0aW9uLi4uXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpZiAocm93LiQkZ3RSb3dDbGFzcykge1xuXHRcdFx0XHRcdFx0XHRcdHJvdy4kJGd0Um93Q2xhc3MgPSByb3cuJCRndFJvd0NsYXNzLmNvbmNhdChcblx0XHRcdFx0XHRcdFx0XHRcdCcgJyArIGNvbHVtbi5yb3dDbGFzcyhyb3csIGNvbHVtbilcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJvdy4kJGd0Um93Q2xhc3MgPSBjb2x1bW4ucm93Q2xhc3Mocm93LCBjb2x1bW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0XHRcdFx0XHQnRXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0IHJvdyBjbGFzcyBuYW1lIHVzaW5nIGZvcm11bGEuJyxcblx0XHRcdFx0XHRcdFx0XHRlcnJvclxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBpZiBub3QgYSBmdW5jdGlvbiwgcmV0dXJuIHBsYWluIHN0cmluZyB2YWx1ZVxuXHRcdFx0XHRcdFx0aWYgKHJvdy4kJGd0Um93Q2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0cm93LiQkZ3RSb3dDbGFzcyA9IHJvdy4kJGd0Um93Q2xhc3MuY29uY2F0KCcgJyArIGNvbHVtbi5yb3dDbGFzcyk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyb3cuJCRndFJvd0NsYXNzID0gY29sdW1uLnJvd0NsYXNzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG59XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHdENvbmZpZ0ZpZWxkIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1jb25maWctZmllbGQnO1xuaW1wb3J0IHsgR3RSb3cgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2d0LXJvdyc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0Q29sdW1uQ2xhc3MnXG59KVxuZXhwb3J0IGNsYXNzIEd0Q29sdW1uQ2xhc3NQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdHRyYW5zZm9ybShcblx0XHRndEZpZWxkczogQXJyYXk8R3RDb25maWdGaWVsZDxhbnksIGFueT4+LFxuXHRcdGNvbHVtbjogR3RDb25maWdGaWVsZDxHdFJvdywgYW55Pixcblx0XHRyb3c/OiBHdFJvd1xuXHQpOiBhbnkge1xuXHRcdC8vIGZpbmQgY29sdW1ucyB3aXRoIGNvbHVtbkNsYXNzIHByb3BlcnR5IGRlZmluZWRcblx0XHRjb25zdCBDT0xVTU5fV0lUSF9DTEFTUyA9IGd0RmllbGRzXG5cdFx0XHQubWFwKGZpZWxkID0+IGZpZWxkKVxuXHRcdFx0LmZpbHRlcihcblx0XHRcdFx0ZmllbGQgPT4gZmllbGQuY29sdW1uQ2xhc3MgJiYgZmllbGQub2JqZWN0S2V5ID09PSBjb2x1bW4ub2JqZWN0S2V5XG5cdFx0XHQpWzBdO1xuXHRcdGlmICghQ09MVU1OX1dJVEhfQ0xBU1MpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBDT0xVTU5fV0lUSF9DTEFTUy5jb2x1bW5DbGFzcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gaWYgY29sdW1uIGNsYXNzIGlzIGEgZnVuY3Rpb24sIHRyeSB1c2luZyB0aGUgZnVuY3Rpb24uLi5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBDT0xVTU5fV0lUSF9DTEFTUy5jb2x1bW5DbGFzcyhyb3csIGNvbHVtbik7XG5cdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0XHQnRXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0IGNvbHVtbiBjbGFzcyBuYW1lIHVzaW5nIGZvcm11bGEuJyxcblx0XHRcdFx0XHRlcnJvclxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpZiBub3QgYSBmdW5jdGlvbiwgcmV0dXJuIHBsYWluIHN0cmluZyB2YWx1ZVxuXHRcdFx0cmV0dXJuIENPTFVNTl9XSVRIX0NMQVNTLmNvbHVtbkNsYXNzO1xuXHRcdH1cblx0fVxufVxuIiwiaW1wb3J0IHtcblx0Q2hhbmdlRGV0ZWN0b3JSZWYsXG5cdERpcmVjdGl2ZSxcblx0RWxlbWVudFJlZixcblx0SG9zdExpc3RlbmVyLFxuXHRJbnB1dCxcblx0T25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcblx0c2VsZWN0b3I6ICdbZ3RDb2x1bW5XaWR0aF0nXG59KVxuZXhwb3J0IGNsYXNzIEd0Q29sdW1uV2lkdGhEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuXHRASW5wdXQoKSBvYmplY3RLZXk6IHN0cmluZztcblx0QElucHV0KCkgd2lkdGhzOiBPYmplY3Q7XG5cdEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnLCBbJyRldmVudCddKVxuXHRwdWJsaWMgb25SZXNpemUoJGV2ZW50OiBhbnkpIHtcblx0XHR0aGlzLmNoZWNrU2l6ZSgpO1xuXHR9XG5cdGNvbnN0cnVjdG9yKFxuXHRcdHByaXZhdGUgaG9zdEVsZW1lbnQ6IEVsZW1lbnRSZWYsXG5cdFx0cHJpdmF0ZSBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWZcblx0KSB7fVxuXHRuZ09uSW5pdCgpIHtcblx0XHR0aGlzLmNoZWNrU2l6ZSgpO1xuXHR9XG5cblx0Y2hlY2tTaXplKCkge1xuXHRcdHRoaXMud2lkdGhzW3RoaXMub2JqZWN0S2V5XSA9IHdpbmRvd1xuXHRcdFx0LmdldENvbXB1dGVkU3R5bGUodGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LCBudWxsKVxuXHRcdFx0LmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyk7XG5cdFx0dGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0RXZlbnRFbWl0dGVyLFxuXHRIb3N0QmluZGluZyxcblx0SW5wdXQsXG5cdE9uSW5pdCxcblx0T3V0cHV0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdndC1jaGVja2JveCcsXG5cdHRlbXBsYXRlOiBgXG4gICAgPGxhYmVsIGNsYXNzPVwiY3VzdG9tLWNvbnRyb2wgY3VzdG9tLWNoZWNrYm94IHAtMFwiIChjbGljayk9XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIj5cbiAgICAgIDxpbnB1dCAjY2hlY2tib3ggdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJjdXN0b20tY29udHJvbC1pbnB1dFwiIFsoY2hlY2tlZCldPVwiY2hlY2tlZFwiIChjaGFuZ2UpPVwidG9nZ2xlKCRldmVudCk7XCI+XG4gICAgICA8c3BhbiBjbGFzcz1cImN1c3RvbS1jb250cm9sLWxhYmVsXCI+PC9zcGFuPlxuICAgIDwvbGFiZWw+XG4gIGAsXG5cdHN0eWxlczogW11cbn0pXG5leHBvcnQgY2xhc3MgR3RDaGVja2JveENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cdGdldCBpbml0aWFsVmFsdWUoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luaXRpYWxWYWx1ZTtcblx0fVxuXG5cdEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzcyA9ICdkLWZsZXgganVzdGlmeS1jb250ZW50LWVuZCc7XG5cblx0QElucHV0KClcblx0c2V0IGluaXRpYWxWYWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuXHRcdHRoaXMuX2luaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXHR9XG5cdGdldCBjaGVja2VkKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2VkO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGNoZWNrZWQodmFsdWU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9jaGVja2VkID0gdmFsdWU7XG5cdH1cblxuXHRwcml2YXRlIF9jaGVja2VkOiBib29sZWFuO1xuXHRwcml2YXRlIF9pbml0aWFsVmFsdWU6IGJvb2xlYW47XG5cdEBPdXRwdXQoKSBjaGFuZ2VkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblx0Y29uc3RydWN0b3IoKSB7fVxuXG5cdG5nT25Jbml0KCkge31cblxuXHR0b2dnbGUoY2hlY2tlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuY2hhbmdlZC5lbWl0KHRoaXMuY2hlY2tlZCk7XG5cdH1cbn1cbiIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuXG5AUGlwZSh7XG5cdG5hbWU6ICdndElzT2JzZXJ2YWJsZSdcbn0pXG5leHBvcnQgY2xhc3MgR3RJc09ic2VydmFibGVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cdHRyYW5zZm9ybShpbnB1dDogYW55KTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIGlucHV0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZTtcblx0fVxufVxuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5cbkBQaXBlKHtcblx0bmFtZTogJ2d0SXNFZGl0YWJsZSdcbn0pXG5leHBvcnQgY2xhc3MgR3RJc0VkaXRhYmxlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHR0cmFuc2Zvcm0ocHJvcGVydHk6IGFueSwgcm93OiBhbnksIHJlZnJlc2hQaXBlOiBib29sZWFuKTogYm9vbGVhbiB7XG5cdFx0aWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIHByb3BlcnR5KHJvdyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBHZW5lcmljVGFibGVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZ2VuZXJpYy10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgR3RSZW5kZXJQaXBlIH0gZnJvbSAnLi9waXBlcy9ndC1yZW5kZXIucGlwZSc7XG5pbXBvcnQgeyBHdFZpc2libGVQaXBlIH0gZnJvbSAnLi9waXBlcy9ndC12aXNpYmxlLnBpcGUnO1xuaW1wb3J0IHsgRGFzaENhc2VQaXBlIH0gZnJvbSAnLi9waXBlcy9kYXNoLWNhc2UucGlwZSc7XG5pbXBvcnQgeyBHdFByb3BlcnR5UGlwZSB9IGZyb20gJy4vcGlwZXMvZ3QtcHJvcGVydHkucGlwZSc7XG5pbXBvcnQgeyBHdENodW5rUGlwZSB9IGZyb20gJy4vcGlwZXMvZ3QtY2h1bmsucGlwZSc7XG5pbXBvcnQgeyBHdEZpbHRlclBpcGUgfSBmcm9tICcuL3BpcGVzL2d0LWZpbHRlci5waXBlJztcbmltcG9ydCB7IEd0T3JkZXJCeVBpcGUgfSBmcm9tICcuL3BpcGVzL2d0LW9yZGVyLWJ5LnBpcGUnO1xuaW1wb3J0IHsgR3RFeHBhbmRpbmdSb3dDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZ3QtZXhwYW5kaW5nLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgR3RTZWFyY2hQaXBlIH0gZnJvbSAnLi9waXBlcy9ndC1zZWFyY2gucGlwZSc7XG5pbXBvcnQgeyBDb21wb25lbnRBbmNob3JEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvY29tcG9uZW50LWFuY2hvci5kaXJlY3RpdmUnO1xuaW1wb3J0IHtcblx0R3RQYWdpbmF0aW9uQ29tcG9uZW50LFxuXHRQYWdpbmF0aW9uUGlwZVxufSBmcm9tICcuL2NvbXBvbmVudHMvZ3QtcGFnaW5hdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtcblx0R3RUYWJsZUluZm9Db21wb25lbnQsXG5cdFRhYmxlSW5mb1BpcGVcbn0gZnJvbSAnLi9jb21wb25lbnRzL2d0LXRhYmxlLWluZm8uY29tcG9uZW50JztcbmltcG9ydCB7IEd0Q3VzdG9tQ29tcG9uZW50RmFjdG9yeSB9IGZyb20gJy4vY29tcG9uZW50cy9ndC1jdXN0b20tY29tcG9uZW50LWZhY3RvcnknO1xuaW1wb3J0IHsgR3RNZXRhUGlwZSB9IGZyb20gJy4vcGlwZXMvZ3QtbWV0YS5waXBlJztcbmltcG9ydCB7IEd0RHJvcGRvd25Db21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZ3QtZHJvcGRvd24uY29tcG9uZW50JztcbmltcG9ydCB7IEd0VG90YWxzUGlwZSB9IGZyb20gJy4vcGlwZXMvZ3QtdG90YWxzLnBpcGUnO1xuaW1wb3J0IHsgR3RUb3RhbHNQb3NpdGlvblBpcGUgfSBmcm9tICcuL3BpcGVzL2d0LXRvdGFscy1wb3NpdGlvbi5waXBlJztcbmltcG9ydCB7IEd0Um93Q2xhc3NQaXBlIH0gZnJvbSAnLi9waXBlcy9ndC1yb3ctY2xhc3MucGlwZSc7XG5pbXBvcnQgeyBHdENvbHVtbkNsYXNzUGlwZSB9IGZyb20gJy4vcGlwZXMvZ3QtY29sdW1uLWNsYXNzLnBpcGUnO1xuaW1wb3J0IHsgR3RDb2x1bW5XaWR0aERpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy9ndC1jb2x1bW4td2lkdGguZGlyZWN0aXZlJztcbmltcG9ydCB7IEd0RHJpbGxkb3duQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2d0LWRyaWxsZG93bi5jb21wb25lbnQnO1xuaW1wb3J0IHsgR3RDaGVja2JveENvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9ndC1jaGVja2JveC9ndC1jaGVja2JveC5jb21wb25lbnQnO1xuaW1wb3J0IHsgR3RIaWdobGlnaHRQaXBlIH0gZnJvbSAnLi9waXBlcy9ndC1oaWdobGlnaHQucGlwZSc7XG5pbXBvcnQgeyBHdElzT2JzZXJ2YWJsZVBpcGUgfSBmcm9tICcuL3BpcGVzL2d0LWlzLW9ic2VydmFibGUucGlwZSc7XG5pbXBvcnQgeyBHdElzRWRpdGFibGVQaXBlIH0gZnJvbSAnLi9waXBlcy9ndC1pcy1lZGl0YWJsZS5waXBlJztcblxuQE5nTW9kdWxlKHtcblx0ZGVjbGFyYXRpb25zOiBbXG5cdFx0Q29tcG9uZW50QW5jaG9yRGlyZWN0aXZlLFxuXHRcdEdlbmVyaWNUYWJsZUNvbXBvbmVudCxcblx0XHRHdFBhZ2luYXRpb25Db21wb25lbnQsXG5cdFx0R3RWaXNpYmxlUGlwZSxcblx0XHRHdFJlbmRlclBpcGUsXG5cdFx0RGFzaENhc2VQaXBlLFxuXHRcdEd0UHJvcGVydHlQaXBlLFxuXHRcdEd0Q2h1bmtQaXBlLFxuXHRcdEd0RmlsdGVyUGlwZSxcblx0XHRHdE9yZGVyQnlQaXBlLFxuXHRcdEd0RXhwYW5kaW5nUm93Q29tcG9uZW50LFxuXHRcdEd0Q3VzdG9tQ29tcG9uZW50RmFjdG9yeSxcblx0XHRHdFNlYXJjaFBpcGUsXG5cdFx0UGFnaW5hdGlvblBpcGUsXG5cdFx0R3RUYWJsZUluZm9Db21wb25lbnQsXG5cdFx0VGFibGVJbmZvUGlwZSxcblx0XHRHdE1ldGFQaXBlLFxuXHRcdEd0VG90YWxzUGlwZSxcblx0XHRHdFRvdGFsc1Bvc2l0aW9uUGlwZSxcblx0XHRHdFJvd0NsYXNzUGlwZSxcblx0XHRHdENvbHVtbkNsYXNzUGlwZSxcblx0XHRHdEhpZ2hsaWdodFBpcGUsXG5cdFx0R3RJc09ic2VydmFibGVQaXBlLFxuXHRcdEd0SXNFZGl0YWJsZVBpcGUsXG5cdFx0R3REcm9wZG93bkNvbXBvbmVudCxcblx0XHRHdENvbHVtbldpZHRoRGlyZWN0aXZlLFxuXHRcdEd0RHJpbGxkb3duQ29tcG9uZW50LFxuXHRcdEd0Q2hlY2tib3hDb21wb25lbnRcblx0XSxcblx0aW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRm9ybXNNb2R1bGVdLFxuXHRleHBvcnRzOiBbXG5cdFx0R2VuZXJpY1RhYmxlQ29tcG9uZW50LFxuXHRcdEd0UGFnaW5hdGlvbkNvbXBvbmVudCxcblx0XHRHdFRhYmxlSW5mb0NvbXBvbmVudCxcblx0XHRHdFByb3BlcnR5UGlwZSxcblx0XHRHdEhpZ2hsaWdodFBpcGUsXG5cdFx0R3RFeHBhbmRpbmdSb3dDb21wb25lbnQsXG5cdFx0R3REcm9wZG93bkNvbXBvbmVudCxcblx0XHRHdERyaWxsZG93bkNvbXBvbmVudCxcblx0XHRHdENoZWNrYm94Q29tcG9uZW50XG5cdF0sXG5cdGVudHJ5Q29tcG9uZW50czogW0d0RHJpbGxkb3duQ29tcG9uZW50LCBHdENoZWNrYm94Q29tcG9uZW50XSxcblx0cHJvdmlkZXJzOiBbR3RNZXRhUGlwZSwgR3RIaWdobGlnaHRQaXBlXSxcblx0Ym9vdHN0cmFwOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljVGFibGVNb2R1bGUge31cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFHQTs7MkJBUWUsSUFBSSxZQUFZLEVBQUs7OEJBRWxCLElBQUksWUFBWSxFQUFLOzs7OztJQUUvQixLQUFLO1FBQ1gsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7SUFHN0IsT0FBTyxDQUFDLE1BQVk7UUFDMUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7O0lBRTFCLFNBQVMsQ0FBQyxHQUFVLEVBQUUsTUFBa0I7UUFDOUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7WUFDakIsSUFBSSxFQUFFLGdCQUFnQjtZQUN0QixLQUFLLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUU7U0FDbEMsQ0FBQyxDQUFDOztDQUVKOzs7Ozs7QUFRRDs7MkJBYXlCLElBQUksWUFBWSxFQUFLOzhCQUNsQixJQUFJLFlBQVksRUFBSzs7Ozs7O0lBR2hELFdBQVcsQ0FBQyxRQUFXO1FBQ3RCLFFBQVEsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUN4QixRQUFRLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxX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